# Automated Findings Report

## Summary

🔥 Total: 7999 instances over 264 issues


### Medium

|Number|Issue|Instances|
|-|:-|:-:|
| [M&#x2011;1](#M1-missing-role-or-owner-modifiers-on-important-functions-for-the-protocol) | Missing role or owner modifiers on important functions for the protocol | 35 |

👉 Total: 35 instances over 1 issues


### Low

|Number|Issue|Instances|
|-|:-|:-:|
| [L&#x2011;1](#L1-approve-zero-first) | Approve zero first | 16 |
| [L&#x2011;2](#L2-blocknumber-means-different-things-on-different-l2s) | `block.number` means different things on different L2s | 5 |
| [L&#x2011;3](#L3-code-does-not-follow-the-best-practice-of-check-effects-interaction) | Code does not follow the best practice of check-effects-interaction | 28 |
| [L&#x2011;4](#L4-consider-bounding-input-array-length) | Consider bounding input array length | 1 |
| [L&#x2011;5](#L5-consider-implementing-two-step-procedure-for-updating-protocol-addresses) | Consider implementing two-step procedure for updating protocol addresses | 1 |
| [L&#x2011;6](#L6-constant-decimal-values) | Constant decimal values | 33 |
| [L&#x2011;7](#L7-constructor/initialize-function-lacks-parameter-validation) | `constructor`/`initialize` function lacks parameter validation | 7 |
| [L&#x2011;8](#L8-contracts-do-not-work-with-fee-on-transfer-tokens) | Contracts do not work with fee-on-transfer tokens | 42 |
| [L&#x2011;9](#L9-critical-functions-should-be-controlled-by-time-locks) | Critical functions should be controlled by time locks | 9 |
| [L&#x2011;10](#L10-decimals-is-not-a-part-of-the-erc-20-standard) | `decimals()` is not a part of the ERC-20 standard | 9 |
| [L&#x2011;11](#L11-deleting-mapping-in-struct-will-not-delete-the-mapping) | Deleting mapping in struct will not delete the mapping | 2 |
| [L&#x2011;12](#L12-external-calls-in-an-un-bounded-for-loop-may-result-in-a-dos) | External calls in an un-bounded `for`-loop may result in a DOS | 1 |
| [L&#x2011;13](#L13-file-allows-a-version-of-solidity-that-is-susceptible-to-selector-related-optimizer-bug) | File allows a version of solidity that is susceptible to `.selector`-related optimizer bug | 4 |
| [L&#x2011;14](#L14-functions-calling-contracts/addresses-with-transfer-hooks-are-missing-reentrancy-guards) | Functions calling contracts/addresses with transfer hooks are missing reentrancy guards | 25 |
| [L&#x2011;15](#L15-gas-grief-possible-on-unsafe-external-calls) | Gas grief possible on unsafe external calls | 3 |
| [L&#x2011;16](#L16-latestanswer-is-deprecated) | `latestAnswer()` is deprecated | 4 |
| [L&#x2011;17](#L17-loss-of-precision) | Loss of precision | 23 |
| [L&#x2011;18](#L18-low-level-calls-to-custom-addresses) | Low level calls to custom `address`es | 2 |
| [L&#x2011;19](#L19-missing-checks-for-address0-when-assigning-values-to-address-state-variables) | Missing checks for `address(0)` when assigning values to address state variables | 7 |
| [L&#x2011;20](#L20-missing-contract-existence-checks-before-low-level-calls) | Missing contract-existence checks before low-level calls | 2 |
| [L&#x2011;21](#L21-missing-zero-address-check-in-functions-with-address-parameters) | Missing zero address check in functions with address parameters | 54 |
| [L&#x2011;22](#L22-multiplication-on-the-result-of-a-division) | Multiplication on the result of a division | 5 |
| [L&#x2011;23](#L23-name-is-not-a-part-of-the-erc-20-standard) | `name()` is not a part of the ERC-20 standard | 1 |
| [L&#x2011;24](#L24-nft-doesnt-handle-hard-forks) | NFT doesn't handle hard forks | 1 |
| [L&#x2011;25](#L25-payable-function-does-not-transfer-eth) | `payable` function does not transfer Eth | 2 |
| [L&#x2011;26](#L26-return-values-of-approve-not-checked) | Return values of `approve()` not checked | 275 |
| [L&#x2011;27](#L27-return-values-of-transfer/transferfrom-not-checked) | Return values of `transfer()/transferFrom()` not checked | 194 |
| [L&#x2011;28](#L28-setters-should-prevent-re-setting-of-the-same-value) | Setters should prevent re-setting of the same value | 9 |
| [L&#x2011;29](#L29-some-popular-erc20-tokens-revert-on-approve-larger-than-uint96) | Some popular ERC20 tokens revert on approve larger than `uint96` | 34 |
| [L&#x2011;30](#L30-some-tokens-may-revert-when-zero-value-transfers-are-made) | Some tokens may revert when zero value transfers are made | 17 |
| [L&#x2011;31](#L31-some-tokens-may-revert-when-zero-value-transfers-are-made) | Some tokens may revert when zero value transfers are made | 10 |
| [L&#x2011;32](#L32-state-variables-not-capped-at-reasonable-values) | State variables not capped at reasonable values | 9 |
| [L&#x2011;33](#L33-symbol-is-not-a-part-of-the-erc-20-standard) | `symbol()` is not a part of the ERC-20 standard | 6 |
| [L&#x2011;34](#L34-tokenuri-does-not-follow-eip-721) | `tokenURI()` does not follow EIP-721 | 1 |
| [L&#x2011;35](#L35-unchecked-blocks-with-additions/multiplications-may-overflow) | `unchecked` blocks with additions/multiplications may overflow | 7 |
| [L&#x2011;36](#L36-unchecked-blocks-with-subtractions-may-underflow) | `unchecked` blocks with subtractions may underflow | 1 |
| [L&#x2011;37](#L37-unsafe-conversion-from-unsigned-to-signed-values) | Unsafe conversion from unsigned to signed values | 3 |
| [L&#x2011;38](#L38-unsafe-downcast) | Unsafe downcast | 1 |
| [L&#x2011;39](#L39-unused/empty-receive/fallback-function) | Unused/empty `receive()/fallback()` function | 1 |
| [L&#x2011;40](#L40-use-of-abiencodewithsignature/abiencodewithselector-instead-of-abiencodecall) | Use of `abi.encodeWithSignature`/`abi.encodeWithSelector` instead of `abi.encodeCall` | 8 |

👉 Total: 863 instances over 40 issues


### NonCritical

|Number|Issue|Instances|
|-|:-|:-:|
| [NC&#x2011;1](#NC1-add-inline-comments-for-unnamed-variables) | Add inline comments for unnamed variables | 9 |
| [NC&#x2011;2](#NC2-address-shouldnt-be-hard-coded) | `address` shouldn't be hard-coded | 2 |
| [NC&#x2011;3](#NC3-assembly-blocks-should-have-extensive-comments) | Assembly blocks should have extensive comments | 2 |
| [NC&#x2011;4](#NC4-avoid-mutating-function/modifier-parameters) | Avoid mutating `function`/`modifier` parameters | 7 |
| [NC&#x2011;5](#NC5-avoid-the-use-of-sensitive-terms) | Avoid the use of sensitive terms | 39 |
| [NC&#x2011;6](#NC6-codebase-should-implement-formal-verification-testing) | Codebase should implement formal verification testing | 1 |
| [NC&#x2011;7](#NC7-complicated-functions-should-have-explicit-comments) | Complicated functions should have explicit comments | 2 |
| [NC&#x2011;8](#NC8-consider-adding-a-block/deny-list) | Consider adding a block/deny-list | 11 |
| [NC&#x2011;9](#NC9-consider-disallowing-transfers-to-addressthis) | Consider disallowing transfers to `address(this)` | 6 |
| [NC&#x2011;10](#NC10-consider-enabling---via-ir-for-enhanced-code-transparency-and-auditability) | Consider enabling `--via-ir` for enhanced code transparency and auditability | 1 |
| [NC&#x2011;11](#NC11-consider-making-contracts-upgradeable) | Consider making contracts `Upgradeable` | 11 |
| [NC&#x2011;12](#NC12-consider-moving-duplicated-strings-to-constants) | Consider moving duplicated strings to constants | 34 |
| [NC&#x2011;13](#NC13-consider-moving-msgsender-checks-to-a-common-authorization-modifier) | Consider moving `msg.sender` checks to a common authorization `modifier` | 4 |
| [NC&#x2011;14](#NC14-consider-providing-a-ranged-getter-for-array-state-variables) | Consider providing a ranged getter for array state variables | 32 |
| [NC&#x2011;15](#NC15-consider-using-delete-rather-than-assigning-zero-to-clear-values) | Consider using `delete` rather than assigning zero to clear values | 8 |
| [NC&#x2011;16](#NC16-consider-using-named-function-arguments) | Consider using named function arguments | 41 |
| [NC&#x2011;17](#NC17-consider-using-named-mappings) | Consider using named mappings | 15 |
| [NC&#x2011;18](#NC18-consider-using-safetransferlibsafetransfereth-or-addresssendvalue) | Consider using `SafeTransferLib.safeTransferETH()` or `Address.sendValue()` | 3 |
| [NC&#x2011;19](#NC19-constants-in-comparisons-should-appear-on-the-left-side) | Constants in comparisons should appear on the left side | 83 |
| [NC&#x2011;20](#NC20-constants-should-be-defined-rather-than-using-magic-numbers) | `constant`s should be defined rather than using magic numbers | 101 |
| [NC&#x2011;21](#NC21-constants/immutables-redefined-elsewhere) | `constant`s/`immutable`s redefined elsewhere | 34 |
| [NC&#x2011;22](#NC22-constructor-should-emit-an-event) | `constructor` should emit an event | 10 |
| [NC&#x2011;23](#NC23-contract-uses-both-require/revert-as-well-as-custom-errors) | Contract uses both `require()`/`revert()` as well as custom errors | 2 |
| [NC&#x2011;24](#NC24-contract/library/interface-definitions-should-be-defined-in-separate-files) | `contract`/`library`/`interface` definitions should be defined in separate files | 62 |
| [NC&#x2011;25](#NC25-contracts-containing-only-utility-functions-should-be-made-into-libraries) | Contracts containing only utility functions should be made into libraries | 1 |
| [NC&#x2011;26](#NC26-contracts-should-have-all-public/external-functions-exposed-by-interfaces) | Contracts should have all `public`/`external` functions exposed by `interface`s | 11 |
| [NC&#x2011;27](#NC27-contracts-should-have-full-test-coverage) | Contracts should have full test coverage | 1 |
| [NC&#x2011;28](#NC28-control-structures-do-not-follow-the-solidity-style-guide) | Control structures do not follow the Solidity Style Guide | 1 |
| [NC&#x2011;29](#NC29-custom-error-without-details) | Custom `error` without details | 53 |
| [NC&#x2011;30](#NC30-custom-errors-should-be-used-rather-than-revert/require) | Custom errors should be used rather than `revert()`/`require()` | 17 |
| [NC&#x2011;31](#NC31-dependence-on-external-protocols) | Dependence on external protocols | 12 |
| [NC&#x2011;32](#NC32-do-not-cache-constants) | Do not cache constants | 1 |
| [NC&#x2011;33](#NC33-empty-bytes-check-is-missing) | Empty bytes check is missing | 46 |
| [NC&#x2011;34](#NC34-empty-function-body) | Empty function body | 2 |
| [NC&#x2011;35](#NC35-enum-values-should-be-used-instead-of-constant-array-indexes) | Enum values should be used instead of constant array indexes | 15 |
| [NC&#x2011;36](#NC36-error-messages-should-be-descriptive-rather-than-cryptic) | Error messages should be descriptive rather than cryptic | 12 |
| [NC&#x2011;37](#NC37-event-is-missing-indexed-fields) | Event is missing `indexed` fields | 32 |
| [NC&#x2011;38](#NC38-events-are-missing-sender-information) | Events are missing sender information | 13 |
| [NC&#x2011;39](#NC39-events-should-be-emitted-before-external-calls) | Events should be emitted before external calls | 21 |
| [NC&#x2011;40](#NC40-expressions-for-constant-values-should-use-immutable-rather-than-constant) | Expressions for `constant` values should use `immutable` rather than constant | 19 |
| [NC&#x2011;41](#NC41-for-loops-in-public-or-external-functions-should-be-avoided-due-to-high-gas-costs-and-possible-dos) | For loops in `public` or `external` functions should be avoided due to high gas costs and possible DOS | 4 |
| [NC&#x2011;42](#NC42-function-can-be-declared-as-pure) | Function can be declared as `pure` | 1 |
| [NC&#x2011;43](#NC43-function-can-be-declared-as-view) | Function can be declared as `view` | 8 |
| [NC&#x2011;44](#NC44-function-ordering-in-the-contract-does-not-follow-the-solidity-style-guide) | Function ordering in the contract does not follow the Solidity style guide | 155 |
| [NC&#x2011;45](#NC45-functions-contain-the-same-code) | Functions contain the same code | 5 |
| [NC&#x2011;46](#NC46-functions-not-used-internally-could-be-marked-external) | Functions not used internally could be marked external | 26 |
| [NC&#x2011;47](#NC47-functions-should-be-named-in-mixedcase-style) | Functions should be named in mixedCase style | 1 |
| [NC&#x2011;48](#NC48-high-cyclomatic-complexity) | High cyclomatic complexity | 10 |
| [NC&#x2011;49](#NC49-if-statement-can-be-converted-to-a-ternary) | `if`-statement can be converted to a ternary | 1 |
| [NC&#x2011;50](#NC50-imports-could-be-organized-more-systematically) | Imports could be organized more systematically | 1 |
| [NC&#x2011;51](#NC51-incorrect-withdraw-declaration) | Incorrect withdraw declaration | 4 |
| [NC&#x2011;52](#NC52-initialisms-should-be-capitalized) | Initialisms should be capitalized | 6 |
| [NC&#x2011;53](#NC53-interfaces-should-be-indicated-with-an-i-prefix-in-the-contract-name) | Interfaces should be indicated with an I prefix in the contract name | 1 |
| [NC&#x2011;54](#NC54-large-multiples-of-ten-should-use-scientific-notation) | Large multiples of ten should use scientific notation | 26 |
| [NC&#x2011;55](#NC55-large-numeric-literals-should-use-underscores-for-readability) | Large numeric literals should use underscores for readability | 25 |
| [NC&#x2011;56](#NC56-large-or-complicated-code-bases-should-implement-invariant-tests) | Large or complicated code bases should implement invariant tests | 1 |
| [NC&#x2011;57](#NC57-layout-order-does-not-comply-with-best-practices) | Layout order does not comply with best practices | 60 |
| [NC&#x2011;58](#NC58-lines-are-too-long) | Lines are too long | 20 |
| [NC&#x2011;59](#NC59-long-functions-should-be-refactored-into-multiple-smaller-functions) | Long functions should be refactored into multiple, smaller, functions | 2 |
| [NC&#x2011;60](#NC60-make-use-of-soliditys-using-keyword) | Make use of Solidity's `using` keyword | 13 |
| [NC&#x2011;61](#NC61-minting-to-the-zero-address-should-be-avoided) | Minting to the zero address should be avoided | 1 |
| [NC&#x2011;62](#NC62-missing-checks-for-address0) | Missing checks for `address(0)` | 184 |
| [NC&#x2011;63](#NC63-missing-checks-for-address0x0-in-the-constructor) | Missing checks for `address(0x0)` in the constructor | 27 |
| [NC&#x2011;64](#NC64-missing-checks-for-uint-state-variable-assignments) | Missing checks for uint state variable assignments | 19 |
| [NC&#x2011;65](#NC65-multiple-mappings-with-same-keys-can-be-combined-into-a-single-struct-mapping-for-readability) | Multiple mappings with same keys can be combined into a single struct mapping for readability | 4 |
| [NC&#x2011;66](#NC66-multiple-type-casts-create-complexity-within-the-code) | Multiple type casts create complexity within the code | 2 |
| [NC&#x2011;67](#NC67-named-imports-of-parent-contracts-are-missing) | Named imports of parent contracts are missing | 1 |
| [NC&#x2011;68](#NC68-names-of-private/internal-state-variables-should-be-prefixed-with-an-underscore) | Names of private/internal state variables should be prefixed with an underscore | 6 |
| [NC&#x2011;69](#NC69-natspec-documentation-for-constructor-is-missing) | NatSpec documentation for `constructor` is missing | 10 |
| [NC&#x2011;70](#NC70-natspec-constructor-declarations-should-have-@notice-tags) | NatSpec: Constructor declarations should have `@notice` tags | 10 |
| [NC&#x2011;71](#NC71-natspec-contract-declarations-should-have-@author-tags) | NatSpec: Contract declarations should have `@author` tags | 63 |
| [NC&#x2011;72](#NC72-natspec-contract-declarations-should-have-@dev-tags) | NatSpec: Contract declarations should have `@dev` tags | 64 |
| [NC&#x2011;73](#NC73-natspec-contract-declarations-should-have-@notice-tags) | NatSpec: Contract declarations should have `@notice` tags | 64 |
| [NC&#x2011;74](#NC74-natspec-contract-declarations-should-have-@title-tags) | NatSpec: Contract declarations should have `@title` tags | 64 |
| [NC&#x2011;75](#NC75-natspec-contract-declarations-should-have-natspec-descriptions) | NatSpec: Contract declarations should have NatSpec descriptions | 63 |
| [NC&#x2011;76](#NC76-natspec-error-declarations-should-have-@notice-tags) | NatSpec: Error declarations should have `@notice` tags | 53 |
| [NC&#x2011;77](#NC77-natspec-error-declarations-should-have-natspec-descriptions) | NatSpec: Error declarations should have NatSpec descriptions | 53 |
| [NC&#x2011;78](#NC78-natspec-error-missing-natspec-@dev-tag) | NatSpec: Error missing NatSpec `@dev` tag | 53 |
| [NC&#x2011;79](#NC79-natspec-event-declarations-should-have-@notice-tags) | NatSpec: Event declarations should have `@notice` tags | 34 |
| [NC&#x2011;80](#NC80-natspec-event-declarations-should-have-natspec-descriptions) | NatSpec: Event declarations should have NatSpec descriptions | 34 |
| [NC&#x2011;81](#NC81-natspec-event-missing-natspec-@dev-tag) | NatSpec: Event missing NatSpec `@dev` tag | 34 |
| [NC&#x2011;82](#NC82-natspec-event-missing-natspec-@param-tag) | NatSpec: Event missing NatSpec `@param` tag | 34 |
| [NC&#x2011;83](#NC83-natspec-file-is-missing-natspec-documentation) | NatSpec: File is missing NatSpec Documentation | 2 |
| [NC&#x2011;84](#NC84-natspec-function-declarations-should-have-@notice-tags) | NatSpec: Function declarations should have `@notice` tags | 308 |
| [NC&#x2011;85](#NC85-natspec-function-declarations-should-have-natspec-descriptions) | NatSpec: Function declarations should have NatSpec descriptions | 309 |
| [NC&#x2011;86](#NC86-natspec-functions-missing-natspec-@dev-tag) | NatSpec: Functions missing NatSpec `@dev` tag | 319 |
| [NC&#x2011;87](#NC87-natspec-functions-missing-natspec-@param-tag) | NatSpec: Functions missing NatSpec `@param` tag | 262 |
| [NC&#x2011;88](#NC88-natspec-functions-missing-natspec-@return-tag) | NatSpec: Functions missing NatSpec `@return` tag | 200 |
| [NC&#x2011;89](#NC89-natspec-modifier-declarations-should-have-natspec-descriptions) | NatSpec: Modifier declarations should have NatSpec descriptions | 14 |
| [NC&#x2011;90](#NC90-natspec-modifier-missing-natspec-@dev-tag) | NatSpec: Modifier missing NatSpec `@dev` tag | 14 |
| [NC&#x2011;91](#NC91-natspec-modifier-missing-natspec-@param-tag) | NatSpec: Modifier missing NatSpec `@param` tag | 1 |
| [NC&#x2011;92](#NC92-natspec-struct-declarations-should-have-@notice-tags) | NatSpec: Struct declarations should have `@notice` tags | 42 |
| [NC&#x2011;93](#NC93-natspec-struct-declarations-should-have-natspec-descriptions) | NatSpec: Struct declarations should have NatSpec descriptions | 42 |
| [NC&#x2011;94](#NC94-non-external/public-function-names-should-begin-with-an-underscore) | Non-`external`/`public` function names should begin with an underscore | 29 |
| [NC&#x2011;95](#NC95-non-external/public-state-variables-should-begin-with-an-underscore) | Non-`external`/`public` state variables should begin with an underscore | 160 |
| [NC&#x2011;96](#NC96-non-library/interface-files-should-use-fixed-compiler-versions-not-floating-ones) | Non-library/interface files should use fixed compiler versions, not floating ones | 6 |
| [NC&#x2011;97](#NC97-numeric-values-having-to-do-with-time-should-use-time-units-for-readability) | Numeric values having to do with time should use time units for readability | 1 |
| [NC&#x2011;98](#NC98-outdated-solidity-version) | Outdated Solidity version | 11 |
| [NC&#x2011;99](#NC99-overly-complicated-arithmetic) | Overly complicated arithmetic | 8 |
| [NC&#x2011;100](#NC100-overridden-function-has-no-body) | Overridden function has no body | 1 |
| [NC&#x2011;101](#NC101-parameter-change-does-not-emit-event) | Parameter change does not emit event | 9 |
| [NC&#x2011;102](#NC102-place-interface-files-into-a-dedicated-folder) | Place `interface` files into a dedicated folder | 53 |
| [NC&#x2011;103](#NC103-polymorphic-functions-make-security-audits-more-time-consuming-and-error-prone) | Polymorphic functions make security audits more time-consuming and error-prone | 12 |
| [NC&#x2011;104](#NC104-public-functions-not-called-by-the-contract-should-be-declared-external-instead) | `public` functions not called by the contract should be declared `external` instead | 26 |
| [NC&#x2011;105](#NC105-receive/payable-fallback-function-does-not-authorize-requests) | `receive()`/`payable fallback()` function does not authorize requests | 1 |
| [NC&#x2011;106](#NC106-returning-a-struct-instead-of-a-bunch-of-variables-is-better) | Returning a struct instead of a bunch of variables is better | 6 |
| [NC&#x2011;107](#NC107-simplify-complex-require-statements) | Simplify complex require statements | 1 |
| [NC&#x2011;108](#NC108-some-variables-have-a-implicit-default-visibility) | Some variables have a implicit default visibility | 19 |
| [NC&#x2011;109](#NC109-state-variables-should-include-comments) | State variables should include comments | 264 |
| [NC&#x2011;110](#NC110-top-level-declarations-should-be-separated-by-at-least-two-lines) | Top-level declarations should be separated by at least two lines | 338 |
| [NC&#x2011;111](#NC111-typos) | Typos | 5 |
| [NC&#x2011;112](#NC112-unnecessary-cast) | Unnecessary cast | 8 |
| [NC&#x2011;113](#NC113-unnecessary-struct-attribute-prefix) | Unnecessary struct attribute prefix | 21 |
| [NC&#x2011;114](#NC114-unsafe-erc20-operations) | Unsafe ERC20 operation(s) | 27 |
| [NC&#x2011;115](#NC115-unspecific-compiler-version-pragma) | Unspecific compiler version pragma | 7 |
| [NC&#x2011;116](#NC116-unused-function-parameter) | Unused function parameter | 1 |
| [NC&#x2011;117](#NC117-unused-struct-definition) | Unused `struct` definition | 7 |
| [NC&#x2011;118](#NC118-unusual-loop-variable) | Unusual loop variable | 1 |
| [NC&#x2011;119](#NC119-use-a-single-file-for-system-wide-constants) | Use a single file for system wide constants | 25 |
| [NC&#x2011;120](#NC120-use-a-struct-to-encapsulate-multiple-function-parameters) | Use a struct to encapsulate multiple function parameters | 12 |
| [NC&#x2011;121](#NC121-use-abiencodecall-instead-of-abiencodesignature/abiencodeselector) | Use `abi.encodeCall()` instead of `abi.encodeSignature()`/`abi.encodeSelector()` | 8 |
| [NC&#x2011;122](#NC122-use-bytesconcat-on-bytes-instead-of-abiencodepacked-for-clearer-semantic-meaning) | Use `bytes.concat()` on bytes instead of `abi.encodePacked()` for clearer semantic meaning | 12 |
| [NC&#x2011;123](#NC123-use-camelcase-for-contract-and-library-names) | Use CamelCase for contract and library names | 1 |
| [NC&#x2011;124](#NC124-use-delete-instead-of-assigning-values-to-false) | Use delete instead of assigning values to `false` | 4 |
| [NC&#x2011;125](#NC125-use-stringconcat-on-strings-instead-of-abiencodepacked-for-clearer-semantic-meaning) | Use `string.concat()` on strings instead of `abi.encodePacked()` for clearer semantic meaning | 12 |
| [NC&#x2011;126](#NC126-use-upper_case-for-constant) | Use UPPER_CASE for `constant` | 2 |
| [NC&#x2011;127](#NC127-use-upper_case-for-immutable) | Use UPPER_CASE for `immutable` | 9 |
| [NC&#x2011;128](#NC128-variable/struct/contract-names-should-be-descriptive-rather-than-cryptic) | `variable`/`struct`/`contract` names should be descriptive rather than cryptic | 97 |
| [NC&#x2011;129](#NC129-variables-need-not-be-initialized-to-zero) | Variables need not be initialized to zero | 2 |
| [NC&#x2011;130](#NC130-variables-should-be-named-in-mixedcase-style) | Variables should be named in mixedCase style | 33 |
| [NC&#x2011;131](#NC131-zero-as-a-function-argument-should-have-a-descriptive-meaning) | Zero as a function argument should have a descriptive meaning | 6 |

👉 Total: 4778 instances over 131 issues


### Gas

|Number|Issue|Instances|Estimated Gas Saved|
|-|:-|:-:|:-:|
| [GAS&#x2011;1](#GAS1-++i-costs-less-gas-than-i++/i-+=-1-same-for---i-vs-i--/i--+-1) | `++i` costs less gas than `i++`/`i += 1` (same for `--i` vs `i--`/`i -+ 1`) | 8 | 48 |
| [GAS&#x2011;2](#GAS2-++i/i++-should-be-unchecked-when-it-is-not-possible-for-them-to-overflow) | `++i`/`i++` should be `unchecked` when it is not possible for them to overflow | 4 | 240 |
| [GAS&#x2011;3](#GAS3---i-costs-less-gas-than-i--) | `--i` costs less gas than `i--` | 1 | 5 |
| [GAS&#x2011;4](#GAS4->=/<=-costs-less-gas-than->/<) | `>=`/`<=` costs less gas than `>`/`<` | 76 | 228 |
| [GAS&#x2011;5](#GAS5-abiencode-is-less-efficient-than-abiencodepacked-for-non-address-arguments) | `abi.encode()` is less efficient than `abi.encodePacked()` for non-address arguments | 45 | - |
| [GAS&#x2011;6](#GAS6-addressthis-should-be-cached-when-used-multiple-times) | `address(this)` should be cached when used multiple times | 11 | - |
| [GAS&#x2011;7](#GAS7-assigning-state-variables-directly-with-named-struct-constructors-wastes-gas) | Assigning state variables directly with named struct constructors wastes gas | 2 | 56 |
| [GAS&#x2011;8](#GAS8-avoid-contract-existence-checks-by-using-low-level-calls) | Avoid contract existence checks by using low-level calls | 98 | 9,800 |
| [GAS&#x2011;9](#GAS9-avoid-fetching-a-low-level-calls-return-data-by-using-assembly) | Avoid fetching a low-level call's return data by using assembly | 3 | 477 |
| [GAS&#x2011;10](#GAS10-avoid-unnecessary-public-variables) | Avoid unnecessary `public` variables | 61 | 1,342,000 |
| [GAS&#x2011;11](#GAS11-avoid-updating-storage-when-the-value-hasnt-changed) | Avoid updating storage when the value hasn't changed | 7 | 11,900 |
| [GAS&#x2011;12](#GAS12-avoid-zero-to-non-zero-storage-writes-where-possible) | Avoid zero to non-zero storage writes where possible | 35 | 773,500 |
| [GAS&#x2011;13](#GAS13-bytesconcat-can-be-used-in-place-of-abiencodepacked) | `bytes.concat()` can be used in place of `abi.encodePacked` | 12 | - |
| [GAS&#x2011;14](#GAS14-cache-array-length-outside-of-loop) | Cache array length outside of loop | 2 | 8 |
| [GAS&#x2011;15](#GAS15-cache-contracts-when-making-multiple-external-calls) | Cache contracts when making multiple external calls | 40 | 6,720 |
| [GAS&#x2011;16](#GAS16-consider-activating-via-ir-for-deploying) | Consider activating `via-ir` for deploying | 0 | 250 |
| [GAS&#x2011;17](#GAS17-consider-caching-repeated-computations) | Consider caching repeated computations | 4 | 240 |
| [GAS&#x2011;18](#GAS18-consider-pre-calculating-the-address-of-addressthis) | Consider pre-calculating the address of `address(this)` | 84 | - |
| [GAS&#x2011;19](#GAS19-consider-using-bytes32-rather-than-a-string) | Consider using `bytes32` rather than a `string` | 2 | 756 |
| [GAS&#x2011;20](#GAS20-consider-using-openzeppelins-enumerateset-instead-of-nested-mappings) | Consider using OpenZeppelin's `EnumerateSet` instead of nested mappings | 1 | 1,000 |
| [GAS&#x2011;21](#GAS21-consider-using-soladys-gas-optimized-lib-for-math) | Consider using Solady's gas optimized lib for Math | 66 | - |
| [GAS&#x2011;22](#GAS22-constructors-can-be-marked-payable) | Constructors can be marked `payable` | 10 | 210 |
| [GAS&#x2011;23](#GAS23-counting-down-in-for-statements-is-more-gas-efficient) | Counting down in `for` statements is more gas efficient | 5 | 80 |
| [GAS&#x2011;24](#GAS24-do-not-cache-state-variables-that-are-used-only-once) | Do not cache state variables that are used only once | 2 | 6 |
| [GAS&#x2011;25](#GAS25-do-while-is-cheaper-than-for-loops-when-the-initial-check-can-be-skipped) | `do`-`while` is cheaper than `for`-loops when the initial check can be skipped | 5 | 1,275 |
| [GAS&#x2011;26](#GAS26-dont-transfer-with-zero-amount-to-save-gas) | Don't transfer with zero amount to save gas | 10 | 200 |
| [GAS&#x2011;27](#GAS27-duplicated-require/revert-checks-should-be-refactored-to-a-modifier-or-function) | Duplicated `require()/revert()` checks should be refactored to a modifier or function | 72 | - |
| [GAS&#x2011;28](#GAS28-emitting-constants-wastes-gas) | Emitting constants wastes gas | 1 | 8 |
| [GAS&#x2011;29](#GAS29-empty-blocks-should-be-removed-or-emit-something) | Empty blocks should be removed or emit something | 2 | - |
| [GAS&#x2011;30](#GAS30-fixed-size-arrays-are-cheaper-than-dynamic-size-arrays) | Fixed-size arrays are cheaper than dynamic-size arrays | 13 | - |
| [GAS&#x2011;31](#GAS31-function-names-can-be-optimized) | Function names can be optimized | 42 | 5,376 |
| [GAS&#x2011;32](#GAS32-integer-increments-by-one-can-be-unchecked) | Integer increments by one can be unchecked | 5 | 300 |
| [GAS&#x2011;33](#GAS33-internal-functions-only-used-once-can-be-inlined-so-save-gas) | `internal` functions only used once can be inlined so save gas | 4 | 120 |
| [GAS&#x2011;34](#GAS34-low-level-call-can-be-optimized-with-assembly) | Low-level `call` can be optimized with assembly | 2 | 318 |
| [GAS&#x2011;35](#GAS35-mappings-are-cheaper-to-use-than-storage-arrays) | Mappings are cheaper to use than storage arrays | 32 | 67,200 |
| [GAS&#x2011;36](#GAS36-multiple-accesses-of-the-same-mapping/array-key/index-should-be-cached) | Multiple accesses of the same mapping/array key/index should be cached | 22 | 924 |
| [GAS&#x2011;37](#GAS37-multiple-address/id-mappings-can-be-combined-into-a-single-mapping-of-an-address/id-to-a-struct) | Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct` | 4 | 80,000 |
| [GAS&#x2011;38](#GAS38-nesting-if-statements-is-cheaper-than-using-&&) | Nesting `if`-statements is cheaper than using `&&` | 12 | 360 |
| [GAS&#x2011;39](#GAS39-newer-versions-of-solidity-are-more-gas-efficient) | Newer versions of solidity are more gas efficient | 11 | - |
| [GAS&#x2011;40](#GAS40-not-using-the-named-return-variables-when-a-function-returns-wastes-deployment-gas) | Not using the named return variables when a function returns, wastes deployment gas | 239 | - |
| [GAS&#x2011;41](#GAS41-optimize-deployment-size-by-fine-tuning-ipfs-hash) | Optimize Deployment Size by Fine-tuning IPFS Hash | 11 | 116,600 |
| [GAS&#x2011;42](#GAS42-optimize-ether-deposits-using-the-receive-function) | Optimize Ether deposits using the `receive()` function | 3 | 135 |
| [GAS&#x2011;43](#GAS43-order-of-checks-in-a-function-can-be-optimized) | Order of checks in a function can be optimized | 7 | 14,700 |
| [GAS&#x2011;44](#GAS44-pre-increments/pre-decrements-are-cheaper-than-+1/+=1-or--1/-=1) | Pre-increments/pre-decrements are cheaper than `+1`/`+=1` or `-1`/`-=1` | 3 | 33 |
| [GAS&#x2011;45](#GAS45-prefer-using-storage-instead-of-memory-for-state-variables-saves-gas) | Prefer using `storage` instead of `memory` for state variables saves gas | 1 | 2,100 |
| [GAS&#x2011;46](#GAS46-private-functions-used-once-can-be-inlined) | `private` functions used once can be inlined | 6 | 180 |
| [GAS&#x2011;47](#GAS47-refactor-modifiers-to-call-a-local-function) | Refactor modifiers to call a local function | 14 | 8,400 |
| [GAS&#x2011;48](#GAS48-require-or-revert-statements-that-check-input-arguments-should-be-at-the-top-of-the-function) | `require()` or `revert()` statements that check input arguments should be at the top of the function | 2 | - |
| [GAS&#x2011;49](#GAS49-same-cast-is-done-multiple-times) | Same cast is done multiple times | 19 | - |
| [GAS&#x2011;50](#GAS50-shortcircuit-rules-can-be-be-used-to-optimize-some-gas-usage) | Shortcircuit rules can be be used to optimize some gas usage | 5 | 10,500 |
| [GAS&#x2011;51](#GAS51-simple-checks-for-zero-can-be-done-using-assembly-to-save-gas) | Simple checks for zero can be done using assembly to save gas | 76 | 456 |
| [GAS&#x2011;52](#GAS52-sort-solidity-operations-using-short-circuit-mode) | Sort Solidity operations using short-circuit mode | 35 | - |
| [GAS&#x2011;53](#GAS53-splitting-revert-statements-saves-gas) | Splitting `revert()` statements saves gas | 4 | 8 |
| [GAS&#x2011;54](#GAS54-stack-variable-is-only-used-once) | Stack variable is only used once | 62 | 186 |
| [GAS&#x2011;55](#GAS55-state-variable-read-in-a-loop) | State variable read in a loop | 2 | 194 |
| [GAS&#x2011;56](#GAS56-state-variables-can-be-packed-into-fewer-storage-slots-by-truncating-timestamp-bytes) | State variables can be packed into fewer storage slots by truncating timestamp bytes | 1 | 240,000 |
| [GAS&#x2011;57](#GAS57-state-variables-can-be-reordered-to-fit-into-fewer-storage-slots) | State variables can be reordered to fit into fewer storage slots | 2 | 40,000 |
| [GAS&#x2011;58](#GAS58-state-variables-only-set-in-the-constructor-should-be-declared-immutable) | State variables only set in the constructor should be declared `immutable` | 19 | 39,843 |
| [GAS&#x2011;59](#GAS59-state-variables-only-set-in-their-definitions-should-be-declared-constant) | State variables only set in their definitions should be declared `constant` | 1 | 2,097 |
| [GAS&#x2011;60](#GAS60-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage) | State variables should be cached in stack variables rather than re-reading them from storage | 90 | 9,000 |
| [GAS&#x2011;61](#GAS61-struct-can-be-reordered-to-fit-into-fewer-storage-slots) | Struct can be reordered to fit into fewer storage slots | 2 | 40,000 |
| [GAS&#x2011;62](#GAS62-structs-can-be-assigned-more-efficiently) | Structs can be assigned more efficiently | 3 | 390 |
| [GAS&#x2011;63](#GAS63-the-result-of-a-function-call-should-be-cached-rather-than-re-calling-the-function) | The result of a function call should be cached rather than re-calling the function | 17 | 1,700 |
| [GAS&#x2011;64](#GAS64-unchecked-{}-can-be-used-on-the-division-of-two-uints-in-order-to-save-gas) | `unchecked {}` can be used on the division of two `uint`s in order to save gas | 2 | 120 |
| [GAS&#x2011;65](#GAS65-usage-of-uints/ints-smaller-than-32-bytes-256-bits-incurs-overhead) | Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead | 22 | 132 |
| [GAS&#x2011;66](#GAS66-use-arrayunsafeaccess-to-avoid-repeated-array-length-checks) | Use `Array.unsafeAccess()` to avoid repeated array length checks | 1 | 2,100 |
| [GAS&#x2011;67](#GAS67-use-assembly-for-small-keccak256-hashes) | Use assembly for small `keccak256` hashes | 33 | 2,640 |
| [GAS&#x2011;68](#GAS68-use-assembly-in-place-of-abidecode) | Use assembly in place of `abi.decode` | 2 | 224 |
| [GAS&#x2011;69](#GAS69-use-assembly-scratch-space-to-build-calldata-for-event-emits) | Use assembly scratch space to build calldata for event emits | 26 | 5,720 |
| [GAS&#x2011;70](#GAS70-use-assembly-scratch-space-to-build-calldata-for-external-calls) | Use assembly scratch space to build calldata for external calls | 331 | 72,820 |
| [GAS&#x2011;71](#GAS71-use-assembly-to-perform-efficient-back-to-back-calls) | Use assembly to perform efficient back-to-back calls | 8 | 2,400 |
| [GAS&#x2011;72](#GAS72-use-assembly-to-validate-msgsender) | Use assembly to validate `msg.sender` | 17 | 204 |
| [GAS&#x2011;73](#GAS73-use-assembly-to-write-address/contract-storage-values) | Use `assembly` to write address/contract storage values | 58 | 2,900 |
| [GAS&#x2011;74](#GAS74-use-bitwise-operators-rather-than-boolean-operators-to-save-gas) | Use bitwise operators rather than boolean operators, to save gas | 2 | - |
| [GAS&#x2011;75](#GAS75-use-calldata-instead-of-memory-for-function-arguments-that-do-not-get-mutated) | Use `calldata` instead of `memory` for function arguments that do not get mutated | 22 | 6,600 |
| [GAS&#x2011;76](#GAS76-use-constants-instead-of-typeuint<n>max-/-min) | Use constants instead of `type(uint<n>).max` / `.min` | 1 | 4 |
| [GAS&#x2011;77](#GAS77-use-custom-errors-rather-than-revert/require-strings-to-save-gas) | Use custom errors rather than `revert()`/`require()` strings to save gas | 17 | 493 |
| [GAS&#x2011;78](#GAS78-use-gas-efficient-version-of-min/max) | Use gas-efficient version of `min`()/`max`() | 4 | - |
| [GAS&#x2011;79](#GAS79-use-if-statements-instead-of-ternary-operators) | Use `if` statements instead of ternary operators | 6 | - |
| [GAS&#x2011;80](#GAS80-use-immutable-when-you-have-storage-variable-that-is-not-going-to-change) | Use immutable when you have storage variable that is not going to change | 4 | - |
| [GAS&#x2011;81](#GAS81-use-revert-to-gain-maximum-gas-savings) | Use `revert()` to gain maximum gas savings | 104 | 30,311 |
| [GAS&#x2011;82](#GAS82-use-scratch-space-when-building-emitted-events) | Use scratch space when building emitted events | 27 | 1,026 |
| [GAS&#x2011;83](#GAS83-use-selfbalance-instead-of-addressthisbalance) | Use `selfbalance()` instead of `address(this).balance` | 1 | - |
| [GAS&#x2011;84](#GAS84-use-shift-right/left-instead-of-division/multiplication-if-possible) | Use shift right/left instead of division/multiplication if possible | 9 | 180 |
| [GAS&#x2011;85](#GAS85-use-short-circuit-evaluation-to-avoid-external-calls) | Use short-circuit evaluation to avoid external calls | 2 | - |
| [GAS&#x2011;86](#GAS86-use-the-inputs/results-of-assignments-rather-than-re-reading-state-variables) | Use the inputs/results of assignments rather than re-reading state variables | 17 | 1,649 |
| [GAS&#x2011;87](#GAS87-use-uint2561/uint2562-instead-of-true/false) | Use `uint256(1)`/`uint256(2)` instead of `true`/`false` | 18 | 307,800 |
| [GAS&#x2011;88](#GAS88-using-bools-for-storage-incurs-overhead) | Using `bool`s for storage incurs overhead | 15 | 256,500 |
| [GAS&#x2011;89](#GAS89-using-constants-directly-rather-than-caching-the-value-saves-gas) | Using `constant`s directly, rather than caching the value, saves gas | 1 | - |
| [GAS&#x2011;90](#GAS90-using-private-rather-than-public-saves-gas) | Using `private` rather than `public`, saves gas | 92 | 331,752 |
| [GAS&#x2011;91](#GAS91-using-storage-instead-of-memory-for-structs/arrays-saves-gas) | Using `storage` instead of `memory` for structs/arrays saves gas | 32 | 67,200 |
| [GAS&#x2011;92](#GAS92-x-+-y-is-more-efficient-than-using-+=-for-state-variables-likewise-for--=) | `x + y` is more efficient than using `+=` for state variables (likewise for `-=`) | 9 | 2,232 |

👉 Total: 2323 instances over 92 issues, saving ~ 3,924,884 gas

**❗ Disclaimer:** Gas totals are estimates based on data from the Ethereum Yellowpaper. The estimates use the lower bounds of ranges and count two iterations of each `for`-loop. All values above are runtime, not deployment, values; deployment values are listed in the individual issue descriptions. The table above as well as its gas numbers do not include any of the excluded findings.


### Disputed

The issues below may be reported by other bots/wardens, but can be penalized/ignored since either the rule or the specified instances are invalid.

|Number|Issue|Instances|
|-|:-|:-:|
| [D&#x2011;1](#D1-file-allows-a-version-of-solidity-that-is-susceptible-to-selector-related-optimizer-bug) | ~~File allows a version of solidity that is susceptible to `.selector`-related optimizer bug~~ | 7 |
| [D&#x2011;2](#D2-functions-contain-the-same-code) | ~~Functions contain the same code~~ | 23 |
| [D&#x2011;3](#D3-functions-should-be-named-in-mixedcase-style) | ~~Functions should be named in mixedCase style~~ | 6 |
| [D&#x2011;4](#D4-abiencode-is-less-efficient-than-abiencodepacked-for-non-address-arguments) | ~~`abi.encode()` is less efficient than `abi.encodePacked()` for non-address arguments~~ | 10 |
| [D&#x2011;5](#D5-multiple-address/id-mappings-can-be-combined-into-a-single-mapping-of-an-address/id-to-a-struct) | ~~Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`~~ | 1 |
| [D&#x2011;6](#D6-stack-variable-is-only-used-once) | ~~Stack variable is only used once~~ | 1 |
| [D&#x2011;7](#D7-state-variable-read-in-a-loop) | ~~State variable read in a loop~~ | 4 |
| [D&#x2011;8](#D8-use-local-variables-for-emitting) | ~~Use local variables for emitting~~ | 15 |
| [D&#x2011;9](#D9-all-interfaces-used-within-a-project-should-be-imported) | ~~All interfaces used within a project should be imported~~ | 63 |
| [D&#x2011;10](#D10-array-lengths-not-checked) | ~~Array lengths not checked~~ | 2 |
| [D&#x2011;11](#D11-avoid-unnecessary-public-variables) | ~~Avoid unnecessary `public` variables~~ | 3 |
| [D&#x2011;12](#D12-bad-bot-rules) | ~~Bad bot rules~~ | 0 |
| [D&#x2011;13](#D13-consider-adding-a-block/deny-list) | ~~Consider adding a block/deny-list~~ | 11 |
| [D&#x2011;14](#D14-consider-merging-sequential-for-loops) | ~~Consider merging sequential for loops~~ | 2 |
| [D&#x2011;15](#D15-default-bool-values-are-manually-reset) | ~~Default `bool` values are manually reset~~ | 17 |
| [D&#x2011;16](#D16-event-names-should-use-camelcase) | ~~Event names should use CamelCase~~ | 34 |
| [D&#x2011;17](#D17-inconsistent-comment-spacing) | ~~Inconsistent comment spacing~~ | 3 |
| [D&#x2011;18](#D18-integer-increments-by-one-can-be-unchecked-to-save-on-gas-fees) | ~~Integer increments by one can be unchecked to save on gas fees~~ | 16 |
| [D&#x2011;19](#D19-magic-numbers-should-be-replaced-with-constants) | ~~Magic numbers should be replaced with constants~~ | 2 |
| [D&#x2011;20](#D20-misplaced-spdx-identifier) | ~~Misplaced SPDX identifier~~ | 11 |
| [D&#x2011;21](#D21-multiple-mappings-with-same-keys-can-be-combined-into-a-single-struct-mapping-for-readability) | ~~Multiple mappings with same keys can be combined into a single struct mapping for readability~~ | 6 |
| [D&#x2011;22](#D22-prefer-double-quotes-for-string-quoting) | ~~Prefer double quotes for string quoting~~ | 3 |
| [D&#x2011;23](#D23-timestamp-may-be-manipulation) | ~~Timestamp may be manipulation~~ | 1 |
| [D&#x2011;24](#D24-unchecked-{}-can-be-used-on-the-division-of-two-uints-in-order-to-save-gas) | ~~`unchecked {}` can be used on the division of two `uint`s in order to save gas~~ | 8 |
| [D&#x2011;25](#D25-unsafe-downcast) | ~~Unsafe downcast~~ | 228 |
| [D&#x2011;26](#D26-unused-named-return-variables-without-optimizer-waste-gas) | ~~Unused named return variables without optimizer waste gas~~ | 2 |
| [D&#x2011;27](#D27-use-!=-0-instead-of->-0-for-unsigned-integer-comparison) | ~~Use != 0 instead of > 0 for unsigned integer comparison~~ | 13 |
| [D&#x2011;28](#D28-use-assembly-to-emit-events-in-order-to-save-gas) | ~~Use assembly to emit events, in order to save gas~~ | 11 |
| [D&#x2011;29](#D29-use-safecast-to-safely-cast-variables) | ~~Use SafeCast to safely cast variables~~ | 209 |
| [D&#x2011;30](#D30-use-stringconcat-on-strings-instead-of-abiencodepacked-for-clearer-semantic-meaning) | ~~Use `string.concat()` on strings instead of `abi.encodePacked()` for clearer semantic meaning~~ | 1 |
| [D&#x2011;31](#D31-using-bools-for-storage-incurs-overhead) | ~~Using `bool`s for storage incurs overhead~~ | 15 |

👉 Total: 728 instances over 31 issues


## Medium


---
### [M&#x2011;1] Missing role or owner modifiers on important functions for the protocol
Consider to adding some sort of role or owner modifiers for liquidity interaction functions, otherwise this will lead to loss of funds or exploits.

<details>
<summary><i>There are 35 instances of this issue:</i></summary>

```solidity
📁 File: InvestorStrategyProxy.sol

43:     function mint(address strategy, uint256 amount) public auth returns (uint256) { 
44:         asset.approve(strategy, amount);
45:         return IStrategy(strategy).mint(amount);
46:     }

48:     function burn(address strategy, uint256 shares) public auth returns (uint256) { 
49:         uint256 amount = IStrategy(strategy).burn(shares);
50:         asset.transfer(msg.sender, amount);
51:         return amount;
52:     }
```


```solidity
📁 File: PositionManager.sol

150:     function setApprovalForAll(address operator, bool approved) public { 
151:         isApprovedForAll[msg.sender][operator] = approved;
152:         emit ApprovalForAll(msg.sender, operator, approved);
153:     }

244:     function burn(uint256 id) public auth(id) { 
245:         IInvestor.Position memory p = investor.getPosition(id);
246:         require(p.collateral == 0, "NOT_CLOSED");
247:         address owner = _ownerOf[id];
248:         require(owner != address(0), "NOT_MINTED");
249:         moveId(owner, address(0), id);
250:     }
```


```solidity
📁 File: Store.sol

47:     function setUint(bytes32 key, uint256 value) external auth returns (uint256) { 
48:         uintValues[key] = value;
49:         return value;
50:     }
51:     function setUintDelta(bytes32 key, int256 value) external auth returns (uint256) {
52:         uint256 prev = uintValues[key];
53:         uint256 next = uint256(int256(prev) + value);
54:         if (value > 0 && next < prev) revert OverOrUnderflow();
55:         if (value < 0 && next > prev) revert OverOrUnderflow();
56:         uintValues[key] = next;
57:         return next;
58:     }
59:     function removeUint(bytes32 key) external auth {
60:         delete uintValues[key];
61:     }

65:     function setInt(bytes32 key, int256 value) external auth returns (int256) { 
66:         intValues[key] = value;
67:         return value;
68:     }
69:     function setIntDelta(bytes32 key, int256 value) external auth returns (int256) {
70:         int256 next = intValues[key] + value;
71:         intValues[key] = next;
72:         return next;
73:     }
74:     function removeInt(bytes32 key) external auth {
75:         delete intValues[key];
76:     }

80:     function setAddress(bytes32 key, address value) external auth returns (address) { 
81:         addressValues[key] = value;
82:         return value;
83:     }
84:     function removeAddress(bytes32 key) external auth {
85:         delete addressValues[key];
86:     }

90:     function setBool(bytes32 key, bool value) external auth returns (bool) { 
91:         boolValues[key] = value;
92:         return value;
93:     }
94:     function removeBool(bytes32 key) external auth {
95:         delete boolValues[key];
96:     }

100:     function setString(bytes32 key, string memory value) external auth returns (string memory) { 
101:         stringValues[key] = value;
102:         return value;
103:     }
104:     function removeString(bytes32 key) external auth {
105:         delete stringValues[key];
106:     }

110:     function setBytes32(bytes32 key, bytes32 value) external auth returns (bytes32) { 
111:         bytes32Values[key] = value;
112:         return value;
113:     }
114:     function removeBytes32(bytes32 key) external auth {
115:         delete bytes32Values[key];
116:     }

121:     function setBytes32Array(bytes32 key, bytes32[] memory value) external auth { 
122:         bytes32ArrayValues[key] = value;
123:     }
124:     function removeBytes32Array(bytes32 key) external auth {
125:         delete bytes32ArrayValues[key];
126:     }

147:     function removeBytes32(bytes32 key, bytes32 value) external auth { 
148:         Bytes32Set storage s = bytes32Sets[key];
149:         uint256 position = s.positions[value];
150:         if (position != 0) {
151:             uint256 valueIndex = position-1;
152:             uint256 lastIndex = s.values.length-1;
153:             if (valueIndex != lastIndex) {
154:                 bytes32 lastValue = s.values[lastIndex];
155:                 s.values[valueIndex] = lastValue;
156:                 s.positions[lastValue] = position;
157:             }
158:             s.values.pop();
159:             delete s.positions[value];
160:         }
161:     }
```


```solidity
📁 File: StrategyCamelotV3.sol

119:     function setPathToLp(bytes calldata newPathToLp) external auth { 
120:         pathToLp = newPathToLp;
121:     }

123:     function setNitroPool(address _nitroPool) external auth { 
124:         if (tokenId == 0) revert TokenIdNeededFirst();
125:         if (_nitroPool == address(0)) {
126:             nitroPool.withdraw(tokenId);
127:         } else {
128:             nftPool.safeTransferFrom(address(this), _nitroPool, tokenId, "");
129:         }
130:         nitroPool = INitroPool(_nitroPool);
131:     }

141:     function mint(uint256 amount) external auth loop returns (uint256) { 
142:         asset.transferFrom(msg.sender, address(this), amount);
143:         address tgtAst = targetAsset;
144:         uint256 slp = slippage;
145:         uint256 tma = totalManagedAssets();
146: 
147:         asset.approve(address(strategyHelper), amount);
148:         strategyHelper.swap(address(asset), tgtAst, amount, slp, address(this));
149: 
150:         uint256 liq;
151:         {
152:             uint256 tgtAmt = IERC20(tgtAst).balanceOf(address(this));
153:             (uint256 amt0, uint256 amt1) = quoteAndSwap(tgtAst, tgtAmt, slp);
154:             address hyp = address(hypervisor);
155:             hypervisor.token0().approve(hyp, amt0);
156:             hypervisor.token1().approve(hyp, amt1);
157:             liq = uniProxy.deposit(amt0, amt1, address(this), hyp, [uint256(0), 0, 0, 0]);
158:             stake(liq);
159:         }
160: 
161:         uint256 val = valueLiquidity() * liq / totalManagedAssets();
162:         if (val < strategyHelper.value(address(asset), amount) * (10000 - slp) / 10000) revert PriceSlipped();
163:         uint256 shares = tma == 0 ? liq : liq * totalShares / tma;
164: 
165:         totalShares += shares;
166:         emit Mint(amount, shares);
167:         return shares;
168:     }

170:     function burn(uint256 shares) external auth loop returns (uint256) { 
171:         uint256 tma = totalManagedAssets();
172:         uint256 amt = (shares * tma) / totalShares;
173:         uint256 val = valueLiquidity() * amt / tma;
174:         unstake(amt);
175:         (uint256 amt0, uint256 amt1) = hypervisor.withdraw(amt, address(this), address(this), [uint256(0), 0, 0, 0]);
176: 
177:         address strategyHelperAddress = address(strategyHelper);
178:         hypervisor.token0().approve(strategyHelperAddress, amt0);
179:         hypervisor.token1().approve(strategyHelperAddress, amt1);
180: 
181:         uint256 bal;
182:         uint256 slp = slippage;
183:         bal += strategyHelper.swap(address(hypervisor.token0()), address(asset), amt0, slp, msg.sender);
184:         bal += strategyHelper.swap(address(hypervisor.token1()), address(asset), amt1, slp, msg.sender);
185: 
186:         if (strategyHelper.value(address(asset), bal) < val * (10000 - slp) / 10000) revert PriceSlipped();
187: 
188:         totalShares -= shares;
189:         emit Burn(bal, shares);
190:         return bal;
191:     }
```


```solidity
📁 File: StrategyGMXGM.sol

143:     function mint(uint256 amount) external auth loop returns (uint256) { 
144:         uint256 slp = slippage;
145:         uint256 tot = totalShares;
146:         uint256 tma = rate(tot);
147: 
148:         asset.transferFrom(msg.sender, address(this), amount);
149:         asset.approve(address(strategyHelper), amount);
150:         uint256 bal = strategyHelper.swap(address(asset), tokenShort, amount, slp, address(this));
151:         uint256 val = strategyHelper.value(tokenShort, bal);
152:         uint256 shares = (tma == 0 || tot == 0) ? val : val * tot / tma;
153: 
154:         totalShares += shares;
155:         emit Mint(amount, shares);
156:         return shares;
157:     }

159:     function burn(uint256 shares) external auth loop returns (uint256) { 
160:         uint256 slp = slippage;
161:         uint256 val = rate(shares);
162:         uint256 amt = (val * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort);
163:         IERC20(tokenShort).approve(address(strategyHelper), amt);
164:         uint256 bal = strategyHelper.swap(tokenShort, address(asset), amt, slp, msg.sender);
165: 
166:         totalShares -= shares;
167:         emit Burn(bal, shares);
168:         return bal;
169:     }
```


```solidity
📁 File: StrategySushiswap.sol

90:     function mint(uint256 amount) public auth loop returns (uint256) {  
91:         asset.transferFrom(msg.sender, address(this), amount);
92:         IUniswapV2Pair pair = pool;
93:         IERC20 tok0 = IERC20(pair.token0());
94:         IERC20 tok1 = IERC20(pair.token1());
95:         uint256 slp = slippage;
96:         uint256 tma = totalManagedAssets();
97:         {
98:             uint256 haf = amount / 2;
99:             asset.approve(address(strategyHelper), amount);
100:             strategyHelper.swap(address(asset), address(tok0), haf, slp, address(this));
101:             strategyHelper.swap(address(asset), address(tok1), amount - haf, slp, address(this));
102:             IERC20(tok0).transfer(address(pair), tok0.balanceOf(address(this)));
103:             IERC20(tok1).transfer(address(pair), tok1.balanceOf(address(this)));
104:         }
105:         pair.mint(address(this));
106:         pair.skim(address(this));
107:         uint256 liq = IERC20(address(pair)).balanceOf(address(this));
108:         IERC20(address(pair)).approve(address(rewarder), liq);
109:         rewarder.deposit(poolId, liq, address(this));
110:         uint256 shares = tma == 0 ? liq : liq * totalShares / tma;
111: 
112:         totalShares += shares;
113:         emit Mint(amount, shares);
114:         return shares;
115:     }

117:     function burn(uint256 shares) public auth loop returns (uint256) { 
118:         IUniswapV2Pair pair = pool;
119:         uint256 slp = slippage;
120:         {
121:             uint256 tma = totalManagedAssets();
122:             uint256 amt = shares * tma / totalShares;
123:             rewarder.withdraw(poolId, amt, address(pair));
124:             pair.burn(address(this));
125:         }
126:         IERC20 tok0 = IERC20(pair.token0());
127:         IERC20 tok1 = IERC20(pair.token1());
128:         uint256 bal0 = tok0.balanceOf(address(this));
129:         uint256 bal1 = tok1.balanceOf(address(this));
130:         tok0.approve(address(strategyHelper), bal0);
131:         tok1.approve(address(strategyHelper), bal1);
132:         uint256 amt0 = strategyHelper.swap(address(tok0), address(asset), bal0, slp, msg.sender);
133:         uint256 amt1 = strategyHelper.swap(address(tok1), address(asset), bal1, slp, msg.sender);
134:         uint256 amount =  amt0 + amt1;
135: 
136:         totalShares -= shares;
137:         emit Burn(amount, shares);
138:         return amount;
139:     }
```


</details>


## Low


---
### [L&#x2011;1] Approve zero first
Some ERC20 tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. For example Tether (USDT)'s approve() function will revert if the current approval is not zero, to protect against front-running changes of approvals.

<details>
<summary><i>There are 16 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @audit Approve zero first, line 58
/// @audit Approve zero first, line 71
48:     function executeOperation( 
49:       address,
50:       uint256 amount,
51:       uint256 premium,
52:       address initiator,
53:       bytes calldata params
54:     ) external returns (bool) {
55:         require(msg.sender == address(lender), "!lender");
56:         require(initiator == address(this), "!me");
57:         uint256 id = uint256(bytes32(params));
58:         asset.approve(address(investor), amount);
59:         (address casset, bytes memory data) = investor.kill(id);
60:         (bytes32 strategy, address[] memory assets) = abi.decode(data, (bytes32, address[]));
61:         swap(casset);
62: 
63:         if (strategy == "sushi") {
64:             address a = assets[0];
65:             IERC20(a).transfer(a, IERC20(a).balanceOf(address(this)));
66:             ISushi(a).burn(address(this));
67:             swap(ISushi(a).token0());
68:             swap(ISushi(a).token1());
69:         }
70: 
71:         asset.approve(address(lender), amount+premium);
72:         asset.transfer(msg.sender, asset.balanceOf(address(this)) - amount - premium);
73:         return true;
74:     }

/// @audit Approve zero first, line 79
76:     function swap(address _fromAsset) internal { 
77:         IERC20 fromAsset = IERC20(_fromAsset);
78:         uint256 amount = fromAsset.balanceOf(address(this));
79:         fromAsset.approve(address(sh), amount);
80:         sh.swap(_fromAsset, address(asset), amount, slippage, address(this));
81:     }
```


```solidity
📁 File: Investor.sol

/// @audit Approve zero first, line 411
396:     function kill(uint256 id) external loop returns (address, bytes memory) { 
397:         IBank bank = IBank(store.getAddress(BANK));
398:         IPool pool = IPool(store.getAddress(POOL));
399:         Position memory p = getPosition(id);
400:         Strategy memory s = getStrategy(p.strategy); 
401:         address poolAsset = pool.asset();
402:         if (_life(p) >= 1e18) revert PositionNotLiquidatable();
403:         if (store.getUint(STATUS) < STATUS_LIQUIDATE || s.status < STATUS_LIQUIDATE) revert WrongStatus();
404:         if (lastBlock[id] == block.number) revert NoEditingInSameBlock();
405:         lastBlock[id] = block.number;
406: 
407:         // Repay borrow using liquidator funds
408:         uint256 borrow = p.borrow * pool.getUpdatedIndex() / 1e18;
409:         uint256 fee = borrow * killCollateralPadding / 10000 / 2;
410:         IERC20(poolAsset).transferFrom(msg.sender, address(this), borrow + fee);
411:         IERC20(poolAsset).approve(address(pool), borrow);
412:         pool.repay(p.borrow);
413: 
414:         uint256 amount = IStrategy(s.implementation).rate(p.shares);
415:         uint256 shares;
416:         uint256 collat;
417:         {
418:             // Transfer collateral to liquidator
419:             uint256 target = helper.value(poolAsset, borrow + (fee * 2));
420:             if (amount < target) {
421:                 // Only use collateral if needed, some "in profit" position
422:                 // could be liquidatable if "expired/forced to exit"
423:                 collat = (target - amount) * 1e18 / helper.price(p.token);
424:                 if (collat > p.collateral) collat = p.collateral;
425:                 bank.transfer(p.token, msg.sender, collat);
426:             }
427: 
428:             // Transfer underlying to liquidator
429:             // scale shares to target. when just repaying borrow on an in
430:             // profit position, we don't want to use all shares
431:             shares = p.shares * target / amount;
432:             if (shares > p.shares) shares = p.shares;
433:         }
434:         bytes memory data = strategyProxy.kill(s.implementation, shares, msg.sender);
435: 
436:         // Update state
437:         p.collateral = p.collateral - collat;
438:         p.shares = p.shares - shares;
439:         p.borrow = 0;
440:         setPosition(id, p);
441: 
442:         emit Kill(id, borrow, amount, collat, shares, fee);
443:         return (p.token, data);
444:     }
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit Approve zero first, line 44
43:     function mint(address strategy, uint256 amount) public auth returns (uint256) { 
44:         asset.approve(strategy, amount);
45:         return IStrategy(strategy).mint(amount);
46:     }
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit Approve zero first, line 147
141:     function mint(uint256 amount) external auth loop returns (uint256) { 
142:         asset.transferFrom(msg.sender, address(this), amount);
143:         address tgtAst = targetAsset;
144:         uint256 slp = slippage;
145:         uint256 tma = totalManagedAssets();
146: 
147:         asset.approve(address(strategyHelper), amount);
148:         strategyHelper.swap(address(asset), tgtAst, amount, slp, address(this));
149: 
150:         uint256 liq;
151:         {
152:             uint256 tgtAmt = IERC20(tgtAst).balanceOf(address(this));
153:             (uint256 amt0, uint256 amt1) = quoteAndSwap(tgtAst, tgtAmt, slp);
154:             address hyp = address(hypervisor);
155:             hypervisor.token0().approve(hyp, amt0);
156:             hypervisor.token1().approve(hyp, amt1);
157:             liq = uniProxy.deposit(amt0, amt1, address(this), hyp, [uint256(0), 0, 0, 0]);
158:             stake(liq);
159:         }
160: 
161:         uint256 val = valueLiquidity() * liq / totalManagedAssets();
162:         if (val < strategyHelper.value(address(asset), amount) * (10000 - slp) / 10000) revert PriceSlipped();
163:         uint256 shares = tma == 0 ? liq : liq * totalShares / tma;
164: 
165:         totalShares += shares;
166:         emit Mint(amount, shares);
167:         return shares;
168:     }

/// @audit Approve zero first, line 207
206:     function stake(uint256 amount) internal { 
207:         IERC20(address(hypervisor)).approve(address(nftPool), amount);
208:         if (tokenId != 0 && totalManagedAssets() > 0) {
209:             nftPool.addToPosition(tokenId, amount);
210:         } else {
211:             // Clear the token if it's already set from a position that
212:             // went to 0 and got burned
213:             if (tokenId != 0) tokenId = 0;
214:             nftPool.createPosition(amount, 0);
215:         }
216:     }
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit Approve zero first, line 149
143:     function mint(uint256 amount) external auth loop returns (uint256) { 
144:         uint256 slp = slippage;
145:         uint256 tot = totalShares;
146:         uint256 tma = rate(tot);
147: 
148:         asset.transferFrom(msg.sender, address(this), amount);
149:         asset.approve(address(strategyHelper), amount);
150:         uint256 bal = strategyHelper.swap(address(asset), tokenShort, amount, slp, address(this));
151:         uint256 val = strategyHelper.value(tokenShort, bal);
152:         uint256 shares = (tma == 0 || tot == 0) ? val : val * tot / tma;
153: 
154:         totalShares += shares;
155:         emit Mint(amount, shares);
156:         return shares;
157:     }

/// @audit Approve zero first, line 163
159:     function burn(uint256 shares) external auth loop returns (uint256) { 
160:         uint256 slp = slippage;
161:         uint256 val = rate(shares);
162:         uint256 amt = (val * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort);
163:         IERC20(tokenShort).approve(address(strategyHelper), amt);
164:         uint256 bal = strategyHelper.swap(tokenShort, address(asset), amt, slp, msg.sender);
165: 
166:         totalShares -= shares;
167:         emit Burn(bal, shares);
168:         return bal;
169:     }

/// @audit Approve zero first, line 349
345:     function afterWithdrawalExecution(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 
346:         if (msg.sender != withdrawalHandler) revert NotGMX();
347:         amountPendingWithdraw = 0;
348:         uint256 bal = IERC20(tokenLong).balanceOf(address(this));
349:         IERC20(tokenLong).approve(address(strategyHelper), bal);
350:         try strategyHelper.swap(tokenLong, tokenShort, bal, slippage, address(this)) {} catch {}
351:     }
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit Approve zero first, line 108
90:     function mint(uint256 amount) public auth loop returns (uint256) {  
91:         asset.transferFrom(msg.sender, address(this), amount);
92:         IUniswapV2Pair pair = pool;
93:         IERC20 tok0 = IERC20(pair.token0());
94:         IERC20 tok1 = IERC20(pair.token1());
95:         uint256 slp = slippage;
96:         uint256 tma = totalManagedAssets();
97:         {
98:             uint256 haf = amount / 2;
99:             asset.approve(address(strategyHelper), amount);
100:             strategyHelper.swap(address(asset), address(tok0), haf, slp, address(this));
101:             strategyHelper.swap(address(asset), address(tok1), amount - haf, slp, address(this));
102:             IERC20(tok0).transfer(address(pair), tok0.balanceOf(address(this)));
103:             IERC20(tok1).transfer(address(pair), tok1.balanceOf(address(this)));
104:         }
105:         pair.mint(address(this));
106:         pair.skim(address(this));
107:         uint256 liq = IERC20(address(pair)).balanceOf(address(this));
108:         IERC20(address(pair)).approve(address(rewarder), liq);
109:         rewarder.deposit(poolId, liq, address(this));
110:         uint256 shares = tma == 0 ? liq : liq * totalShares / tma;
111: 
112:         totalShares += shares;
113:         emit Mint(amount, shares);
114:         return shares;
115:     }

/// @audit Approve zero first, line 130
/// @audit Approve zero first, line 131
117:     function burn(uint256 shares) public auth loop returns (uint256) { 
118:         IUniswapV2Pair pair = pool;
119:         uint256 slp = slippage;
120:         {
121:             uint256 tma = totalManagedAssets();
122:             uint256 amt = shares * tma / totalShares;
123:             rewarder.withdraw(poolId, amt, address(pair));
124:             pair.burn(address(this));
125:         }
126:         IERC20 tok0 = IERC20(pair.token0());
127:         IERC20 tok1 = IERC20(pair.token1());
128:         uint256 bal0 = tok0.balanceOf(address(this));
129:         uint256 bal1 = tok1.balanceOf(address(this));
130:         tok0.approve(address(strategyHelper), bal0);
131:         tok1.approve(address(strategyHelper), bal1);
132:         uint256 amt0 = strategyHelper.swap(address(tok0), address(asset), bal0, slp, msg.sender);
133:         uint256 amt1 = strategyHelper.swap(address(tok1), address(asset), bal1, slp, msg.sender);
134:         uint256 amount =  amt0 + amt1;
135: 
136:         totalShares -= shares;
137:         emit Burn(amount, shares);
138:         return amount;
139:     }

/// @audit Approve zero first, line 163
/// @audit Approve zero first, line 171
153:     function earn() public payable loop { 
154:         if (!keepers[msg.sender]) revert NotKeeper();
155:         uint256 before = rate(totalShares);
156: 
157:         IUniswapV2Pair pair = pool;
158:         IERC20 rew = IERC20(rewarder.SUSHI());
159:         rewarder.harvest(poolId, address(this));
160:         uint256 amt = rew.balanceOf(address(this));
161:         uint256 haf = amt / 2;
162:         if (strategyHelper.value(address(rew), amt) < 0.5e18) return;
163:         rew.approve(address(strategyHelper), amt);
164:         strategyHelper.swap(address(rew), pair.token0(), haf, slippage, address(this));
165:         strategyHelper.swap(address(rew), pair.token1(), amt - haf, slippage, address(this));
166:         IERC20(pair.token0()).transfer(address(pair), IERC20(pair.token0()).balanceOf(address(this)));
167:         IERC20(pair.token1()).transfer(address(pair), IERC20(pair.token1()).balanceOf(address(this)));
168:         pair.mint(address(this));
169:         pair.skim(address(this));
170:         uint256 liq = IERC20(address(pair)).balanceOf(address(this));
171:         IERC20(address(pair)).approve(address(rewarder), liq);
172:         rewarder.deposit(poolId, liq, address(this));
173:         uint256 current = rate(totalShares);
174:         emit Earn(current, current - min(current, before));
175:     }

/// @audit Approve zero first, line 192
186:     function move(address old) public auth { 
187:         require(totalShares == 0, "ts=0");
188:         totalShares = StrategySushiswap(old).totalShares();
189:         IERC20 lp = IERC20(address(pool));
190:         uint256 bal = lp.balanceOf(address(this));
191:         totalShares = bal;
192:         lp.approve(address(rewarder), bal);
193:         rewarder.deposit(poolId, bal, address(this));
194:     }
```


</details>


---
### [L&#x2011;2] `block.number` means different things on different L2s
On Optimism, `block.number` is the L2 block number, but on Arbitrum, it's the L1 block number, and `ArbSys(address(100)).arbBlockNumber()` must be used. Furthermore, L2 block numbers often occur much more frequently than L1 block numbers (any may even occur on a per-transaction basis), so using block numbers for timing results in inconsistencies, especially when voting is involved across multiple chains. As of version 4.9, OpenZeppelin has <a href="https://blog.openzeppelin.com/introducing-openzeppelin-contracts-v4.9#governor">modified</a> their governor code to use a clock rather than block numbers, to avoid these sorts of issues, but this still requires that the project <a href="https://docs.openzeppelin.com/contracts/4.x/governance#token_2">implement</a> a <a href="https://eips.ethereum.org/EIPS/eip-6372">clock</a> for each L2.


<i>There are 5 instaces of this issue:</i>

```solidity
📁 File: Investor.sol

260:         lastBlock[id] = block.number; 

307:         if (lastBlock[id] == block.number) revert NoEditingInSameBlock(); 
308:         lastBlock[id] = block.number;

404:         if (lastBlock[id] == block.number) revert NoEditingInSameBlock(); 
405:         lastBlock[id] = block.number;
```



---
### [L&#x2011;3] Code does not follow the best practice of check-effects-interaction
Code should follow the best-practice of [check-effects-interaction](https://blockchain-academy.hs-mittweida.de/courses/solidity-coding-beginners-to-intermediate/lessons/solidity-11-coding-patterns/topic/checks-effects-interactions/), where state variables are updated before any external calls are made. Doing so prevents a large class of reentrancy bugs.

<details>
<summary><i>There are 28 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

431:             shares = p.shares * target / amount; 
432:             if (shares > p.shares) shares = p.shares;
```


```solidity
📁 File: StrategyCamelotV3.sol

61:         asset = IERC20(_asset); 
62:         strategyHelper = IStrategyHelper(_strategyHelper);

68:         nftPool = INFTPool(_nftPool); 
69:         targetAsset = _targetAsset;
70:         pathToLp = _pathToLp;
71:         name = string(abi.encodePacked("Camelot V3 ", hypervisor.token0().symbol(), "/", hypervisor.token1().symbol()));

130:         nitroPool = INitroPool(_nitroPool); 

165:         totalShares += shares; 

198:         totalShares -= shares; 

213:             if (tokenId != 0) tokenId = 0; 
```


```solidity
📁 File: StrategyGMXGM.sol

59:         asset = IERC20(_asset); 
60:         strategyHelper = IStrategyHelper(_strategyHelper);
61:         exchangeRouter = IExchangeRouter(_exchangeRouter);
62:         reader = IReader(_reader);
63:         depositHandler = _depositHandler;
64:         withdrawalHandler = _withdrawalHandler;
65:         depositVault = IHandler(_depositHandler).depositVault();
66:         withdrawalVault = IHandler(_withdrawalHandler).withdrawalVault();

73:         name = string( 
74:             abi.encodePacked(
75:                 "GMX GM ", IERC20(marketInfo.longToken).symbol(), "/", IERC20(marketInfo.shortToken).symbol()
76:             )
77:         );

154:         totalShares += shares; 

176:         totalShares -= shares; 

209:             amountPendingDeposit = minOut; 

270:             amountPendingWithdraw = amt; 
```


```solidity
📁 File: StrategySushiswap.sol

112:         totalShares += shares; 

136:         totalShares -= shares; 

191:         totalShares = bal; 
```


</details>


---
### [L&#x2011;4] Consider bounding input array length
The functions below take in an unbounded array, and make function calls for entries in the array. While the function will revert if it eventually runs out of gas, it may be a nicer user experience to `require()` that the length of the array is below some reasonable maximum, so that the user doesn't have to use up a full transaction's gas only to see that the transaction reverts.


<i>There is one instance of this issue:</i>

```solidity
📁 File: Whitelist.sol

/// @audit addresses.length not bounded
36:         for (uint256 i = 0; i < l; i++) { 
37:             whitelist[addresses[i]] = status;
38:         }
```



---
### [L&#x2011;5] Consider implementing two-step procedure for updating protocol addresses
A copy-paste error or a typo may end up bricking protocol functionality, or sending tokens to an address with no known private key. Consider implementing a two-step procedure for updating protocol addresses, where the recipient is set as pending, and must 'accept' the assignment by making an affirmative call. A straight forward way of doing this would be to have the target contracts implement [EIP-165](https://eips.ethereum.org/EIPS/eip-165), and to have the 'set' functions ensure that the recipient is of the right interface type.


<i>There is one instance of this issue:</i>

```solidity
📁 File: Store.sol

/// @audit line 81
80:     function setAddress(bytes32 key, address value) external auth returns (address) { 
81:         addressValues[key] = value;
82:         return value;
83:     }
```



---
### [L&#x2011;6] Constant decimal values
The use of fixed decimal values such as 1e18 or 1e8 in Solidity contracts can lead to inaccuracies, bugs, and vulnerabilities, particularly when interacting with tokens having different decimal configurations. Not all ERC20 tokens follow the standard 18 decimal places, and assumptions about decimal places can lead to miscalculations.

<details>
<summary><i>There are 33 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

190:             if (data > 1e18) revert InvalidFile(); 

196:             if (data > 1e18) revert InvalidFile(); 

199:             if (data > 1e18) revert InvalidFile(); 

288:         if (_life(p) < 1e18) revert Undercollateralized(); 

335:             uint256 repaying = amount * 1e18 / index; 

341:                 uint256 needed = p.borrow * index / 1e18; 

382:         if (_life(p) < 1e18) revert Undercollateralized(); 

391:         uint256 borrow = p.borrow * pool.getUpdatedIndex() / 1e18; 

402:         if (_life(p) >= 1e18) revert PositionNotLiquidatable(); 

408:         uint256 borrow = p.borrow * pool.getUpdatedIndex() / 1e18; 

423:                 collat = (target - amount) * 1e18 / helper.price(p.token); 

459:         uint256 value = (sharesValue + collateralValue) * factor / 1e18; 
460:         uint256 price = (uint256(oracle.latestAnswer()) * 1e18) / (10 ** oracle.decimals());
461:         uint256 scaled = (p.borrow * 1e18) / (10 ** IERC20(pool.asset()).decimals());
462:         uint256 borrow = (scaled * pool.getUpdatedIndex() / 1e18) * price / 1e18;
463:         return value * 1e18 / borrow;
```


```solidity
📁 File: PositionManager.sol

344:             (p.borrow * IPool(pool).getUpdatedIndex() / 1e18) * 1e18 / (10 ** IERC20(IPool(pool).asset()).decimals()) 
```


```solidity
📁 File: StrategyCamelotV3.sol

242:             if (strategyHelper.value(rewardToken1, balance) > 1e18) { 

250:             if (strategyHelper.value(rewardToken2, balance) > 1e18) { 

258:             if (strategyHelper.value(rewardToken3, balance) > 1e18) { 

265:         if (strategyHelper.value(tgtAsset, amt) < 1e18) return; 

314:         uint256 toLp0 = amt * 1e18 / ((((start + end) / 2) * 1e18 / out1) + 1e18); 
```


```solidity
📁 File: StrategyGMXGM.sol

208:             uint256 minOut = (have - need) * 1e18 / marketTokenPrice(true); 

242:             uint256 amt = (need - have) * 1e18 / marketTokenPrice(true); 

299:         val += bal * marketTokenPrice(true) / 1e18; 

331:         price = price * (10 ** (30 - decimals)) / 1e18; 
```


```solidity
📁 File: StrategySushiswap.sol

81:             reserve0 = uint256(r0) * 1e18 / (10 ** IERC20(pair.token0()).decimals()); 
82:             reserve1 = uint256(r1) * 1e18 / (10 ** IERC20(pair.token1()).decimals());

87:         return sha * (val * amt / 1e18) / totalShares; 
```


</details>


---
### [L&#x2011;7] `constructor`/`initialize` function lacks parameter validation
Constructors and initialization functions play a critical role in contracts by setting important initial states when the contract is first deployed before the system starts. The parameters passed to the constructor and initialization functions directly affect the behavior of the contract / protocol. If incorrect parameters are provided, the system may fail to run, behave abnormally, be unstable, or lack security. Therefore, it's crucial to carefully check each parameter in the constructor and initialization functions. If an exception is found, the transaction should be rolled back.

<details>
<summary><i>There are 7 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @audit _investor , _asset , _lender , _sh 
36:     constructor(address _investor, address _asset, address _lender, address _sh) { 
```


```solidity
📁 File: Investor.sol

/// @audit _store , _helper 
144:     constructor(address _store, address _helper) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit _asset 
24:     constructor(address _asset) { 
```


```solidity
📁 File: PositionManager.sol

/// @audit _investor 
91:     constructor(address _investor) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit _asset , _strategyHelper , _xgrail , _strategyHelperUniswapV3 , _uniProxy , _quoter , _hypervisor , _nftPool , _pathToLp 
48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _xgrail,
52:         address _strategyHelperUniswapV3,
53:         address _uniProxy,
54:         address _quoter,
55:         address _hypervisor,
56:         address _nftPool,
57:         address _targetAsset,
58:         bytes memory _pathToLp
59:     ) {
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit _asset , _strategyHelper , _exchangeRouter , _reader , _depositHandler , _withdrawalHandler , _dataStore , _market 
48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _exchangeRouter,
52:         address _reader,
53:         address _depositHandler,
54:         address _withdrawalHandler,
55:         address _dataStore,
56:         address _market
57:     ) {
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit _asset , _strategyHelper , _rewarder , _poolId 
29:     constructor(address _asset, address _strategyHelper, address _rewarder, uint256 _poolId) { 
```


</details>


---
### [L&#x2011;8] Contracts do not work with fee-on-transfer tokens
Some tokens take a transfer fee (e.g. STA, PAXG), some do not currently charge a fee but may do so in the future (e.g. USDT, USDC).

<details>
<summary><i>There are 42 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

41:     function transfer(address token, address to, uint256 amount) external auth { 

43:         if (!IERC20(token).transfer(to, amount)) revert TransferFailed(); 
```


```solidity
📁 File: Helper.sol

48:     function executeOperation( 

65:             IERC20(a).transfer(a, IERC20(a).balanceOf(address(this))); 

72:         asset.transfer(msg.sender, asset.balanceOf(address(this)) - amount - premium); 
```


```solidity
📁 File: Investor.sol

251:     function collect(address token) external auth { 
252:         IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));

396:     function kill(uint256 id) external loop returns (address, bytes memory) { 

410:         IERC20(poolAsset).transferFrom(msg.sender, address(this), borrow + fee); 

499:     function push(address asset, address user, uint256 amount) internal { 

501:         if (!IERC20(asset).transfer(user, amount)) { 

506:     function pullToBank(address asset, address user, uint256 amount) internal { 

508:         if (!IERC20(asset).transferFrom(user, store.getAddress(BANK), amount)) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

48:     function burn(address strategy, uint256 shares) public auth returns (uint256) { 

50:         asset.transfer(msg.sender, amount); 
```


```solidity
📁 File: PositionManager.sol

262:     function pull(address ast, address usr, uint256 amt) internal { 
263:         if (!IERC20(ast).transferFrom(usr, address(this), amt)) revert TransferFailed();

266:     function push(address ast, address usr) internal { 

269:         if (bal > 0 && !asset.transfer(usr, bal)) revert TransferFailed(); 
```


```solidity
📁 File: StrategyCamelotV3.sol

141:     function mint(uint256 amount) external auth loop returns (uint256) { 
142:         asset.transferFrom(msg.sender, address(this), amount);

338:     function swap(address trgtAst, address ast, bytes memory path, uint256 toLp, uint256 slp) private { 

340:         IERC20(trgtAst).transfer(address(strategyHelperUniswapV3), toLp); 
```


```solidity
📁 File: StrategyGMXGM.sol

138:     function withdrawAirdrop(address token) external auth { 

140:       IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))); 

143:     function mint(uint256 amount) external auth loop returns (uint256) { 

148:         asset.transferFrom(msg.sender, address(this), amount); 

171:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

174:         IERC20(tokenShort).transfer(to, amount); 

283:     function exit(address strategy) external auth { 

287:         IERC20(market).transfer(strategy, IERC20(market).balanceOf(address(this))); 
288:         IERC20(tokenLong).transfer(strategy, IERC20(tokenLong).balanceOf(address(this)));
289:         IERC20(tokenShort).transfer(strategy, IERC20(tokenShort).balanceOf(address(this)));
```


```solidity
📁 File: StrategySushiswap.sol

90:     function mint(uint256 amount) public auth loop returns (uint256) {  
91:         asset.transferFrom(msg.sender, address(this), amount);

102:             IERC20(tok0).transfer(address(pair), tok0.balanceOf(address(this))); 
103:             IERC20(tok1).transfer(address(pair), tok1.balanceOf(address(this)));
```


</details>


---
### [L&#x2011;9] Critical functions should be controlled by time locks
It is a good practice to give time for users to react and adjust to critical changes. A timelock provides more guarantees and reduces the level of trust required, thus decreasing risk for users. It also indicates that the project is legitimate (less risk of a malicious owner making a sandwich attack on a user).

<details>
<summary><i>There are 9 instances of this issue:</i></summary>

```solidity
📁 File: Store.sol

59:     function removeUint(bytes32 key) external auth { 
60:         delete uintValues[key];
61:     }

74:     function removeInt(bytes32 key) external auth { 
75:         delete intValues[key];
76:     }

84:     function removeAddress(bytes32 key) external auth { 
85:         delete addressValues[key];
86:     }

94:     function removeBool(bytes32 key) external auth { 
95:         delete boolValues[key];
96:     }

104:     function removeString(bytes32 key) external auth { 
105:         delete stringValues[key];
106:     }

114:     function removeBytes32(bytes32 key) external auth { 
115:         delete bytes32Values[key];
116:     }

124:     function removeBytes32Array(bytes32 key) external auth { 
125:         delete bytes32ArrayValues[key];
126:     }
```


```solidity
📁 File: StrategyCamelotV3.sol

119:     function setPathToLp(bytes calldata newPathToLp) external auth { 
120:         pathToLp = newPathToLp;
121:     }

123:     function setNitroPool(address _nitroPool) external auth { 
124:         if (tokenId == 0) revert TokenIdNeededFirst();
125:         if (_nitroPool == address(0)) {
126:             nitroPool.withdraw(tokenId);
127:         } else {
128:             nftPool.safeTransferFrom(address(this), _nitroPool, tokenId, "");
129:         }
130:         nitroPool = INitroPool(_nitroPool);
131:     }
```


</details>


---
### [L&#x2011;10] `decimals()` is not a part of the ERC-20 standard
The `decimals()` function is not a part of the [ERC-20 standard](https://eips.ethereum.org/EIPS/eip-20), and was added later as an [optional extension](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol). As such, some valid ERC20 tokens do not support this interface, so it is unsafe to blindly cast all tokens to this interface, and then call this function.

<details>
<summary><i>There are 9 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

460:         uint256 price = (uint256(oracle.latestAnswer()) * 1e18) / (10 ** oracle.decimals()); 
461:         uint256 scaled = (p.borrow * 1e18) / (10 ** IERC20(pool.asset()).decimals());
```


```solidity
📁 File: PositionManager.sol

344:             (p.borrow * IPool(pool).getUpdatedIndex() / 1e18) * 1e18 / (10 ** IERC20(IPool(pool).asset()).decimals()) 
345:         ) * uint256(oracle.latestAnswer()) / (10 ** oracle.decimals());
```


```solidity
📁 File: StrategyGMXGM.sol

162:         uint256 amt = (val * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort); 

173:         uint256 amount = (value * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort); 

328:             decimals = IERC20(token).decimals(); 
```


```solidity
📁 File: StrategySushiswap.sol

81:             reserve0 = uint256(r0) * 1e18 / (10 ** IERC20(pair.token0()).decimals()); 
82:             reserve1 = uint256(r1) * 1e18 / (10 ** IERC20(pair.token1()).decimals());
```


</details>


---
### [L&#x2011;11] Deleting mapping in struct will not delete the mapping
<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

168:             delete i.positions[id]; 
```


```solidity
📁 File: Store.sol

159:             delete s.positions[value]; 
```


</details>


---
### [L&#x2011;12] External calls in an un-bounded `for`-loop may result in a DOS
Consider limiting the number of iterations in `for`-loops that make external calls


<i>There is one instance of this issue:</i>

```solidity
📁 File: UtilFarmingBalances.sol

/// @audit line 21
20:         for (uint256 y = start; y < max; y++) { 
21:             (,,,,,uint256 value,) = i.positions(y);
22:             (bool ok, bytes memory data) = address(pm).staticcall(abi.encodeWithSelector(IPositionManager.ownerOf.selector, y));
23:             if (ok) {
24:               users[y-start] = abi.decode(data, (address));
25:               balances[y-start] = value;
26:             }
27:         }
```



---
### [L&#x2011;13] File allows a version of solidity that is susceptible to `.selector`-related optimizer bug
In solidity versions prior to 0.8.21, there is a legacy code generation [bug](https://soliditylang.org/blog/2023/07/19/missing-side-effects-on-selector-access-bug/) where if `foo().selector` is called, `foo()` doesn't actually get evaluated. It is listed as low-severity, because projects usually use the contract name rather than a function call to look up the selector. I've flagged all files using `.selector` where the version is vulnerable.

<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

2: pragma solidity 0.8.17; 
```


```solidity
📁 File: StrategyCamelotV3.sol

2: pragma solidity 0.8.17; 
```


```solidity
📁 File: StrategyGMXGM.sol

2: pragma solidity 0.8.17; 
```


```solidity
📁 File: UtilFarmingBalances.sol

2: pragma solidity ^0.8.0; 
```


</details>


---
### [L&#x2011;14] Functions calling contracts/addresses with transfer hooks are missing reentrancy guards
Adherence to the check-effects-interaction pattern is commendable, but without a reentrancy guard in functions, especially with transfer hooks, users are exposed to read-only reentrancy risks. This can lead to malicious actions without altering the contract state. Adding a reentrancy guard is vital for security, protecting against both traditional and read-only reentrancy attacks, ensuring a robust and safe protocol.

<details>
<summary><i>There are 25 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit transfer() on line 43
41:     function transfer(address token, address to, uint256 amount) external auth { 
```


```solidity
📁 File: Helper.sol

/// @audit transfer() on line 72
/// @audit transfer() on line 65
48:     function executeOperation( 
```


```solidity
📁 File: Investor.sol

/// @audit transfer() on line 252
251:     function collect(address token) external auth { 

/// @audit transfer() on line 379
/// @audit transfer() on line 347
295:     function edit(uint256 id, int256 borrow, int256 collateral) external loop { 

/// @audit transferFrom() on line 410
/// @audit transfer() on line 425
396:     function kill(uint256 id) external loop returns (address, bytes memory) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit transfer() on line 50
48:     function burn(address strategy, uint256 shares) public auth returns (uint256) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit safeTransferFrom() on line 128
123:     function setNitroPool(address _nitroPool) external auth { 

/// @audit transferFrom() on line 142
141:     function mint(uint256 amount) external auth loop returns (uint256) { 

/// @audit transfer() on line 196
193:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit safeTransferFrom() on line 281
276:     function exit(address strategy) external auth { 

/// @audit safeTransferFrom() on line 289
284:     function move(address old) external auth { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit transfer() on line 140
138:     function withdrawAirdrop(address token) external auth { 

/// @audit transferFrom() on line 148
143:     function mint(uint256 amount) external auth loop returns (uint256) { 

/// @audit transfer() on line 174
171:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit transfer() on line 287
/// @audit transfer() on line 288
/// @audit transfer() on line 289
283:     function exit(address strategy) external auth { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit transferFrom() on line 91
/// @audit transfer() on line 102
/// @audit transfer() on line 103
90:     function mint(uint256 amount) public auth loop returns (uint256) {  

/// @audit transfer() on line 166
/// @audit transfer() on line 167
153:     function earn() public payable loop { 
```


</details>


---
### [L&#x2011;15] Gas grief possible on unsafe external calls
There is no limit specified on the amount of gas used, so the recipient can use up all of the transaction's gas, causing it to revert. Use `addr.call{gas: <amount>}("")` or [this](https://github.com/nomad-xyz/ExcessivelySafeCall) library instead.

<details>
<summary><i>There are 3 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit line 37
35:     function transferNative(address to, uint256 amount) external auth { 
36:         if (amount == 0) return;
37:         (bool s,) = to.call{value: amount}("");
38:         if (!s) revert TransferFailed();
39:     }
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit line 59
58:     function call(address strategy, uint256 value, bytes calldata data) public auth { 
59:         (bool success,) = strategy.call{value: value}(data);
60:         if (!success) {
61:             assembly {
62:                 returndatacopy(0, 0, returndatasize())
63:                 revert(0, returndatasize())
64:             }
65:         }
66:     }
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit line 134
133:     function withdrawEth() external auth { 
134:         (bool success,) = address(msg.sender).call{value: address(this).balance}("");
135:         if (!success) revert ErrorSendingETH();
136:     }
```


</details>


---
### [L&#x2011;16] `latestAnswer()` is deprecated
Use `latestRoundData()` instead so that you can tell whether the answer is stale or not. The `latestAnswer()` function returns zero if it is unable to fetch data, which may be the case if ChainLink stops supporting this API. The API and its deprecation message no longer even appear on the ChainLink website, so it is dangerous to continue using it.

<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

14:     function latestAnswer() external view returns (int256); 

460:         uint256 price = (uint256(oracle.latestAnswer()) * 1e18) / (10 ** oracle.decimals()); 
```


```solidity
📁 File: PositionManager.sol

16:     function latestAnswer() external view returns (int256); 

345:         ) * uint256(oracle.latestAnswer()) / (10 ** oracle.decimals()); 
```


</details>


---
### [L&#x2011;17] Loss of precision
Division by large numbers may result in the result being zero, due to solidity not supporting fractions. Consider requiring a minimum amount for the numerator to ensure that it is always larger than the denominator

<details>
<summary><i>There are 23 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

460:         uint256 price = (uint256(oracle.latestAnswer()) * 1e18) / (10 ** oracle.decimals()); 
461:         uint256 scaled = (p.borrow * 1e18) / (10 ** IERC20(pool.asset()).decimals());
```


```solidity
📁 File: PositionManager.sol

376:         uint256 r = n / (10 ** (d - f)) % (10 ** f); 

381:         return string(abi.encodePacked(Strings.toString(n / x), ".", sr)); 
```


```solidity
📁 File: StrategyCamelotV3.sol

172:         uint256 amt = (shares * tma) / totalShares; 

298:         uint256 lp0Amt = amt / 2; 

314:         uint256 toLp0 = amt * 1e18 / ((((start + end) / 2) * 1e18 / out1) + 1e18); 

352:         uint160 midX96 = TickMath.getSqrtRatioAtTick(int24((tickCumulatives[1] - tickCumulatives[0]) / int32(period))); 
```


```solidity
📁 File: StrategyGMXGM.sol

162:         uint256 amt = (val * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort); 

173:         uint256 amount = (value * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort); 

205:             uint256 haf = amt / 2; 

319:         return price < 0 ? 0 : uint256(price) / 1e12; 
```


```solidity
📁 File: StrategySushiswap.sol

86:         uint256 val = 2 * ((sqrt(reserve0 * reserve1) * sqrt(price0 * price1)) / tot); 

98:             uint256 haf = amount / 2; 

161:         uint256 haf = amt / 2; 

205:             result = (result + a / result) >> 1; 
206:             result = (result + a / result) >> 1;
207:             result = (result + a / result) >> 1;
208:             result = (result + a / result) >> 1;
209:             result = (result + a / result) >> 1;
210:             result = (result + a / result) >> 1;
211:             result = (result + a / result) >> 1;
212:             return min(result, a / result);
```


</details>


---
### [L&#x2011;18] Low level calls to custom `address`es
Low-level calls (such as `.call()`, `.delegatecall()`, or `.callcode()`) in Solidity provide a way to interact with other contracts or addresses. However, when these calls are made to addresses that are provided as parameters or are not well-validated, they pose a significant security risk. Untrusted addresses might contain malicious code leading to unexpected behavior, loss of funds, or vulnerabilities.

**Resolution**: Prefer using high-level Solidity function calls or interface-based interactions with known contracts to ensure security. If low-level calls are necessary, rigorously validate the addresses and test all possible interactions. Implementing additional checks and fail-safes can help mitigate potential risks associated with low-level calls.

<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit low level call to 'to' on line 37
35:     function transferNative(address to, uint256 amount) external auth { 
36:         if (amount == 0) return;
37:         (bool s,) = to.call{value: amount}("");
38:         if (!s) revert TransferFailed();
39:     }
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit low level call to 'strategy' on line 59
58:     function call(address strategy, uint256 value, bytes calldata data) public auth { 
59:         (bool success,) = strategy.call{value: value}(data);
60:         if (!success) {
61:             assembly {
62:                 returndatacopy(0, 0, returndatasize())
63:                 revert(0, returndatasize())
64:             }
65:         }
66:     }
```


</details>


---
### [L&#x2011;19] Missing checks for `address(0)` when assigning values to address state variables
<details>
<summary><i>There are 7 instances of this issue:</i></summary>

```solidity
📁 File: StrategyCamelotV3.sol

96:             rewardToken1 = data; 

98:             rewardToken2 = data; 

100:             rewardToken3 = data; 
```


```solidity
📁 File: StrategyGMXGM.sol

63:         depositHandler = _depositHandler; 
64:         withdrawalHandler = _withdrawalHandler;

104:             depositHandler = data; 

107:             withdrawalHandler = data; 
```


</details>


---
### [L&#x2011;20] Missing contract-existence checks before low-level calls
Low-level calls return success if there is no code present at the specified address.

<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit line 37
35:     function transferNative(address to, uint256 amount) external auth { 
36:         if (amount == 0) return;
37:         (bool s,) = to.call{value: amount}("");
38:         if (!s) revert TransferFailed();
39:     }
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit line 59
58:     function call(address strategy, uint256 value, bytes calldata data) public auth { 
59:         (bool success,) = strategy.call{value: value}(data);
60:         if (!success) {
61:             assembly {
62:                 returndatacopy(0, 0, returndatasize())
63:                 revert(0, returndatasize())
64:             }
65:         }
66:     }
```


</details>


---
### [L&#x2011;21] Missing zero address check in functions with address parameters
Adding a zero address check for each address type parameter can prevent errors.

<details>
<summary><i>There are 54 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit data
26:     function file(bytes32 what, address data) external auth { 

/// @audit to
35:     function transferNative(address to, uint256 amount) external auth { 

/// @audit token, to
41:     function transfer(address token, address to, uint256 amount) external auth { 
```


```solidity
📁 File: Helper.sol

/// @audit initiator
48:     function executeOperation( 
49:       address,
50:       uint256 amount,
51:       uint256 premium,
52:       address initiator,
53:       bytes calldata params
54:     ) external returns (bool) {

/// @audit _fromAsset
76:     function swap(address _fromAsset) internal { 
```


```solidity
📁 File: Investor.sol

/// @audit data
162:     function file(bytes32 what, address data) external auth { 

/// @audit implementation
210:     function strategyNew(uint256 index, address implementation) external auth { 

/// @audit implementation
219:     function strategyUgrade(uint256 index, address implementation) external auth { 

/// @audit token
239:     function collateralSetFactor(address token, uint256 factor) external auth { 

/// @audit token
245:     function collateralSetCap(address token, uint256 cap) external auth { 

/// @audit token
251:     function collect(address token) external auth { 

/// @audit token
255:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external loop returns (uint256) { 

/// @audit asset, user
499:     function push(address asset, address user, uint256 amount) internal { 

/// @audit asset, user
506:     function pullToBank(address asset, address user, uint256 amount) internal { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit data
34:     function file(bytes32 what, address data) public auth { 

/// @audit strategy
43:     function mint(address strategy, uint256 amount) public auth returns (uint256) { 

/// @audit strategy
48:     function burn(address strategy, uint256 shares) public auth returns (uint256) { 

/// @audit strategy, target
54:     function kill(address strategy, uint256 shares, address target) public auth returns (bytes memory) { 

/// @audit strategy
58:     function call(address strategy, uint256 value, bytes calldata data) public auth { 
```


```solidity
📁 File: PositionManager.sol

/// @audit data
101:     function file(bytes32 what, address data) external admin { 

/// @audit owner
118:     function balanceOf(address owner) public view returns (uint256) { 

/// @audit owner
123:     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) { 

/// @audit owner
127:     function tokensOfOwner(address owner, uint256 start, uint256 end) external view returns (uint256[] memory v) { 

/// @audit spender
143:     function approve(address spender, uint256 id) public { 

/// @audit operator
150:     function setApprovalForAll(address operator, bool approved) public { 

/// @audit from
155:     function moveId(address from, address to, uint256 id) internal { 

/// @audit from, to
182:     function transferFrom(address from, address to, uint256 id) public auth(id) { 

/// @audit from, to
188:     function safeTransferFrom(address from, address to, uint256 id) public { 

/// @audit from, to
198:     function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public { 

/// @audit token, to
214:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow, address to) public returns (uint256) { 

/// @audit ast
258:     function rely(address ast, uint256 amt) internal { 

/// @audit ast, usr
262:     function pull(address ast, address usr, uint256 amt) internal { 

/// @audit ast, usr
266:     function push(address ast, address usr) internal { 
```


```solidity
📁 File: Store.sol

/// @audit data
35:     function file(bytes32 what, address data) external auth { 

/// @audit value
80:     function setAddress(bytes32 key, address value) external auth returns (address) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit data
90:     function file(bytes32 what, address data) external auth { 

/// @audit to
193:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit strategy
276:     function exit(address strategy) external auth { 

/// @audit old
284:     function move(address old) external auth { 

/// @audit trgtAst
297:     function quoteAddLiquidity(uint256 amt, address trgtAst, bytes memory path) private returns (uint256, uint256) { 

/// @audit trgtAst
320:     function quoteAndSwap(address trgtAst, uint256 amt, uint256 slp) private returns (uint256 amt0, uint256 amt1) { 

/// @audit trgtAst, ast
338:     function swap(address trgtAst, address ast, bytes memory path, uint256 toLp, uint256 slp) private { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit data
94:     function file(bytes32 what, address data) external auth { 

/// @audit token
138:     function withdrawAirdrop(address token) external auth { 

/// @audit to
171:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit strategy
283:     function exit(address strategy) external auth { 

/// @audit old
292:     function move(address old) external auth {} 

/// @audit token
325:     function gmxPrice(address token, bool isIndex) internal view returns (IPrice.Props memory) { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit data
52:     function file(bytes32 what, address data) external auth { 

/// @audit to
141:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit strategy
182:     function exit(address strategy) public auth { 

/// @audit old
186:     function move(address old) public auth { 
```


```solidity
📁 File: Whitelist.sol

/// @audit data
23:     function file(bytes32 what, address data) external auth { 

/// @audit user
42:     function check(address user) external view returns (bool) { 
```


</details>


---
### [L&#x2011;22] Multiplication on the result of a division
Dividing an integer by another integer will often result in loss of precision.
When the result is multiplied by another number, the loss of precision is magni'fied, often to material magnitudes. `(X / Z) * Y` should be re-written as `(X * Y) / Z`

Example:
```solidity
contract A {
  function f(uint n) public {
       coins = (oldSupply / n) * interest;
   }
}
```

If `n` is greater than `oldSupply`, coins will be zero. For example, with `oldSupply = 5; n = 10, interest = 2`, coins will be zero.
If `(oldSupply * interest / n)` was used, coins would have been 1. In general, it's usually a good idea to re-arrange arithmetic to perform `multiplication before division`, unless the limit of a smaller type makes this dangerous.


<details>
<summary><i>There are 5 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

462:         uint256 borrow = (scaled * pool.getUpdatedIndex() / 1e18) * price / 1e18; 
```


```solidity
📁 File: PositionManager.sol

343:         uint256 amt = ( 
344:             (p.borrow * IPool(pool).getUpdatedIndex() / 1e18) * 1e18 / (10 ** IERC20(IPool(pool).asset()).decimals())
345:         ) * uint256(oracle.latestAnswer()) / (10 ** oracle.decimals());
```


```solidity
📁 File: StrategyCamelotV3.sol

314:         uint256 toLp0 = amt * 1e18 / ((((start + end) / 2) * 1e18 / out1) + 1e18); 
```


```solidity
📁 File: StrategySushiswap.sol

87:         return sha * (val * amt / 1e18) / totalShares; 
```


</details>


---
### [L&#x2011;23] `name()` is not a part of the ERC-20 standard
The `name()` function is not a part of the [ERC-20 standard](https://eips.ethereum.org/EIPS/eip-20), and was added later as an [optional extension](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol). As such, some valid ERC20 tokens do not support this interface, so it is unsafe to blindly cast all tokens to this interface, and then call this function.


<i>There is one instance of this issue:</i>

```solidity
📁 File: PositionManager.sol

317:                 IStrategy(s.implementation).name(), 
```



---
### [L&#x2011;24] NFT doesn't handle hard forks
When there are hard forks, users often have to go through [many hoops](https://twitter.com/elerium115/status/1558471934924431363) to ensure that they control ownership on every fork. Consider adding `require(1 == chain.chainId)`, or the chain ID of whichever chain you prefer, to the functions below, or at least include the chain ID in the URI, so that there is no confusion about which chain is the owner of the NFT.


<i>There is one instance of this issue:</i>

```solidity
📁 File: PositionManager.sol

272:     function tokenURI(uint256 id) public view returns (string memory) { 
273:         string memory image = generateImage(id);
274:         return string(
275:             abi.encodePacked(
276:                 "data:application/json;base64,",
277:                 Base64.encode(
278:                     bytes(
279:                         abi.encodePacked(
280:                             '{"name":"#',
281:                             Strings.toString(id),
282:                             '","description":"This NFT represents a leveraged farming position on Rodeo Finance. The owner of this NFT can modify or redeem the position.","image":"',
283:                             "data:image/svg+xml;base64,",
284:                             image,
285:                             '"}'
286:                         )
287:                     )
288:                 )
289:             )
290:         );
291:     }
```



---
### [L&#x2011;25] `payable` function does not transfer Eth
Funds sent along with the call to this function will be lost.

<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: StrategyCamelotV3.sol

228:     function earn() external payable loop { 
229:         if (!keepers[msg.sender]) revert NotKeeper();
230:         uint256 before = rate(totalShares);
231: 
232:         if (tokenId == 0) return;
233:         uint256 slp = slippage;
234:         address tgtAsset = targetAsset;
235:         nftPool.harvestPosition(tokenId);
236:         if (address(nitroPool) != address(0)) {
237:             nitroPool.harvest();
238:         }
239: 
240:         if (rewardToken1 != address(0)) {
241:             uint256 balance = IERC20(rewardToken1).balanceOf(address(this));
242:             if (strategyHelper.value(rewardToken1, balance) > 1e18) {
243:                 IERC20(rewardToken1).approve(address(strategyHelper), balance);
244:                 strategyHelper.swap(rewardToken1, tgtAsset, balance, slp, address(this));
245:             }
246:         }
247: 
248:         if (rewardToken2 != address(0)) {
249:             uint256 balance = IERC20(rewardToken2).balanceOf(address(this));
250:             if (strategyHelper.value(rewardToken2, balance) > 1e18) {
251:                 IERC20(rewardToken2).approve(address(strategyHelper), balance);
252:                 strategyHelper.swap(rewardToken2, tgtAsset, balance, slp, address(this));
253:             }
254:         }
255: 
256:         if (rewardToken3 != address(0)) {
257:             uint256 balance = IERC20(rewardToken3).balanceOf(address(this));
258:             if (strategyHelper.value(rewardToken3, balance) > 1e18) {
259:                 IERC20(rewardToken3).approve(address(strategyHelper), balance);
260:                 strategyHelper.swap(rewardToken3, tgtAsset, balance, slp, address(this));
261:             }
262:         }
263: 
264:         uint256 amt = IERC20(tgtAsset).balanceOf(address(this));
265:         if (strategyHelper.value(tgtAsset, amt) < 1e18) return;
266:         (uint256 amt0, uint256 amt1) = quoteAndSwap(tgtAsset, amt, slp);
267:         address h = address(hypervisor);
268:         IHypervisor(h).token0().approve(h, amt0);
269:         IHypervisor(h).token1().approve(h, amt1);
270:         stake(uniProxy.deposit(amt0, amt1, address(this), h, [uint256(0), 0, 0, 0]));
271: 
272:         uint256 current = rate(totalShares);
273:         emit Earn(current, current - min(current, before));
274:     }
```


```solidity
📁 File: StrategySushiswap.sol

153:     function earn() public payable loop { 
154:         if (!keepers[msg.sender]) revert NotKeeper();
155:         uint256 before = rate(totalShares);
156: 
157:         IUniswapV2Pair pair = pool;
158:         IERC20 rew = IERC20(rewarder.SUSHI());
159:         rewarder.harvest(poolId, address(this));
160:         uint256 amt = rew.balanceOf(address(this));
161:         uint256 haf = amt / 2;
162:         if (strategyHelper.value(address(rew), amt) < 0.5e18) return;
163:         rew.approve(address(strategyHelper), amt);
164:         strategyHelper.swap(address(rew), pair.token0(), haf, slippage, address(this));
165:         strategyHelper.swap(address(rew), pair.token1(), amt - haf, slippage, address(this));
166:         IERC20(pair.token0()).transfer(address(pair), IERC20(pair.token0()).balanceOf(address(this)));
167:         IERC20(pair.token1()).transfer(address(pair), IERC20(pair.token1()).balanceOf(address(this)));
168:         pair.mint(address(this));
169:         pair.skim(address(this));
170:         uint256 liq = IERC20(address(pair)).balanceOf(address(this));
171:         IERC20(address(pair)).approve(address(rewarder), liq);
172:         rewarder.deposit(poolId, liq, address(this));
173:         uint256 current = rate(totalShares);
174:         emit Earn(current, current - min(current, before));
175:     }
```


</details>


---
### [L&#x2011;26] Return values of `approve()` not checked
Not all IERC20 implementations `revert()` when there's a failure in `approve()`. The function signature has a boolean return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually approving anything

<details>
<summary><i>There are 275 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

58:         asset.approve(address(investor), amount); 

71:         asset.approve(address(lender), amount+premium); 

79:         fromAsset.approve(address(sh), amount); 
```


```solidity
📁 File: Investor.sol

348:                     IERC20(p.token).approve(address(helper), cAmount); 

354:             IERC20(poolAsset).approve(address(pool), amount); 

411:         IERC20(poolAsset).approve(address(pool), borrow); 
```


```solidity
📁 File: InvestorStrategyProxy.sol

44:         asset.approve(strategy, amount); 
```


```solidity
📁 File: PositionManager.sol

259:         if (!IERC20(ast).approve(address(investor), amt)) revert TransferFailed(); 
```


```solidity
📁 File: StrategyCamelotV3.sol

147:         asset.approve(address(strategyHelper), amount); 

207:         IERC20(address(hypervisor)).approve(address(nftPool), amount); 

243:                 IERC20(rewardToken1).approve(address(strategyHelper), balance); 

251:                 IERC20(rewardToken2).approve(address(strategyHelper), balance); 

259:                 IERC20(rewardToken3).approve(address(strategyHelper), balance); 
```


```solidity
📁 File: StrategyGMXGM.sol

149:         asset.approve(address(strategyHelper), amount); 

163:         IERC20(tokenShort).approve(address(strategyHelper), amt); 

195:             IERC20(tokenLong).approve(address(strategyHelper), bal); 

206:             IERC20(tokenShort).approve(address(strategyHelper), haf); 

232:             IERC20(marketInfo.longToken).approve(router, out); 
233:             IERC20(marketInfo.shortToken).approve(router, amt - haf);

272:             IERC20(market).approve(exchangeRouter.router(), amt); 

349:         IERC20(tokenLong).approve(address(strategyHelper), bal); 
```


```solidity
📁 File: StrategySushiswap.sol

99:             asset.approve(address(strategyHelper), amount); 

108:         IERC20(address(pair)).approve(address(rewarder), liq); 

130:         tok0.approve(address(strategyHelper), bal0); 
131:         tok1.approve(address(strategyHelper), bal1);

163:         rew.approve(address(strategyHelper), amt); 

171:         IERC20(address(pair)).approve(address(rewarder), liq); 

192:         lp.approve(address(rewarder), bal); 
```


</details>


---
### [L&#x2011;27] Return values of `transfer()/transferFrom()` not checked
Some tokens (like USDT) don't correctly implement the EIP20 standard and their transfer/transferFrom function return void instead of a successful boolean. Calling these functions with the correct EIP20 function signatures will always revert.

<details>
<summary><i>There are 194 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

65:             IERC20(a).transfer(a, IERC20(a).balanceOf(address(this))); 

72:         asset.transfer(msg.sender, asset.balanceOf(address(this)) - amount - premium); 
```


```solidity
📁 File: Investor.sol

252:         IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))); 

410:         IERC20(poolAsset).transferFrom(msg.sender, address(this), borrow + fee); 

501:         if (!IERC20(asset).transfer(user, amount)) { 

508:         if (!IERC20(asset).transferFrom(user, store.getAddress(BANK), amount)) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

50:         asset.transfer(msg.sender, amount); 
```


```solidity
📁 File: PositionManager.sol

263:         if (!IERC20(ast).transferFrom(usr, address(this), amt)) revert TransferFailed(); 

269:         if (bal > 0 && !asset.transfer(usr, bal)) revert TransferFailed(); 
```


```solidity
📁 File: StrategyCamelotV3.sol

142:         asset.transferFrom(msg.sender, address(this), amount); 

340:         IERC20(trgtAst).transfer(address(strategyHelperUniswapV3), toLp); 
```


```solidity
📁 File: StrategyGMXGM.sol

140:       IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))); 

148:         asset.transferFrom(msg.sender, address(this), amount); 

174:         IERC20(tokenShort).transfer(to, amount); 

287:         IERC20(market).transfer(strategy, IERC20(market).balanceOf(address(this))); 
288:         IERC20(tokenLong).transfer(strategy, IERC20(tokenLong).balanceOf(address(this)));
289:         IERC20(tokenShort).transfer(strategy, IERC20(tokenShort).balanceOf(address(this)));
```


```solidity
📁 File: StrategySushiswap.sol

91:         asset.transferFrom(msg.sender, address(this), amount); 

102:             IERC20(tok0).transfer(address(pair), tok0.balanceOf(address(this))); 
103:             IERC20(tok1).transfer(address(pair), tok1.balanceOf(address(this)));

166:         IERC20(pair.token0()).transfer(address(pair), IERC20(pair.token0()).balanceOf(address(this))); 
167:         IERC20(pair.token1()).transfer(address(pair), IERC20(pair.token1()).balanceOf(address(this)));
```


</details>


---
### [L&#x2011;28] Setters should prevent re-setting of the same value
This especially problematic when the setter also emits the same value, which may be confusing to offline parsers

<details>
<summary><i>There are 9 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

/// @note Confidence: 50.00%
150:     function setApprovalForAll(address operator, bool approved) public { 
151:         isApprovedForAll[msg.sender][operator] = approved;
152:         emit ApprovalForAll(msg.sender, operator, approved);
153:     }
```


```solidity
📁 File: Store.sol

/// @note Confidence: 50.00%
47:     function setUint(bytes32 key, uint256 value) external auth returns (uint256) { 
48:         uintValues[key] = value;
49:         return value;
50:     }

/// @note Confidence: 50.00%
65:     function setInt(bytes32 key, int256 value) external auth returns (int256) { 
66:         intValues[key] = value;
67:         return value;
68:     }

/// @note Confidence: 50.00%
80:     function setAddress(bytes32 key, address value) external auth returns (address) { 
81:         addressValues[key] = value;
82:         return value;
83:     }

/// @note Confidence: 50.00%
90:     function setBool(bytes32 key, bool value) external auth returns (bool) { 
91:         boolValues[key] = value;
92:         return value;
93:     }

/// @note Confidence: 50.00%
100:     function setString(bytes32 key, string memory value) external auth returns (string memory) { 
101:         stringValues[key] = value;
102:         return value;
103:     }

/// @note Confidence: 50.00%
110:     function setBytes32(bytes32 key, bytes32 value) external auth returns (bytes32) { 
111:         bytes32Values[key] = value;
112:         return value;
113:     }

/// @note Confidence: 50.00%
121:     function setBytes32Array(bytes32 key, bytes32[] memory value) external auth { 
122:         bytes32ArrayValues[key] = value;
123:     }
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @note Confidence: 100.00%
119:     function setPathToLp(bytes calldata newPathToLp) external auth { 
120:         pathToLp = newPathToLp;
121:     }
```


</details>


---
### [L&#x2011;29] Some popular ERC20 tokens revert on approve larger than `uint96`
Some tokens (e.g. `UNI`, `COMP`) revert if the value passed to `approve` or `transfer` is larger than `uint96`.

Both of the above tokens have special case logic in `approve` that sets `allowance` to `type(uint96).max` if the approval amount is `uint256(-1)`, which may cause issues with systems that expect the value passed to `approve` to be reflected in the `allowances` mapping.

<details>
<summary><i>There are 34 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

58:         asset.approve(address(investor), amount); 

71:         asset.approve(address(lender), amount+premium); 

79:         fromAsset.approve(address(sh), amount); 
```


```solidity
📁 File: Investor.sol

348:                     IERC20(p.token).approve(address(helper), cAmount); 

354:             IERC20(poolAsset).approve(address(pool), amount); 

411:         IERC20(poolAsset).approve(address(pool), borrow); 
```


```solidity
📁 File: InvestorStrategyProxy.sol

44:         asset.approve(strategy, amount); 
```


```solidity
📁 File: PositionManager.sol

259:         if (!IERC20(ast).approve(address(investor), amt)) revert TransferFailed(); 
```


```solidity
📁 File: StrategyCamelotV3.sol

147:         asset.approve(address(strategyHelper), amount); 

155:             hypervisor.token0().approve(hyp, amt0); 
156:             hypervisor.token1().approve(hyp, amt1);

178:         hypervisor.token0().approve(strategyHelperAddress, amt0); 
179:         hypervisor.token1().approve(strategyHelperAddress, amt1);

207:         IERC20(address(hypervisor)).approve(address(nftPool), amount); 

243:                 IERC20(rewardToken1).approve(address(strategyHelper), balance); 

251:                 IERC20(rewardToken2).approve(address(strategyHelper), balance); 

259:                 IERC20(rewardToken3).approve(address(strategyHelper), balance); 

268:         IHypervisor(h).token0().approve(h, amt0); 
269:         IHypervisor(h).token1().approve(h, amt1);
```


```solidity
📁 File: StrategyGMXGM.sol

149:         asset.approve(address(strategyHelper), amount); 

163:         IERC20(tokenShort).approve(address(strategyHelper), amt); 

195:             IERC20(tokenLong).approve(address(strategyHelper), bal); 

206:             IERC20(tokenShort).approve(address(strategyHelper), haf); 

232:             IERC20(marketInfo.longToken).approve(router, out); 
233:             IERC20(marketInfo.shortToken).approve(router, amt - haf);

272:             IERC20(market).approve(exchangeRouter.router(), amt); 

349:         IERC20(tokenLong).approve(address(strategyHelper), bal); 
```


```solidity
📁 File: StrategySushiswap.sol

99:             asset.approve(address(strategyHelper), amount); 

108:         IERC20(address(pair)).approve(address(rewarder), liq); 

130:         tok0.approve(address(strategyHelper), bal0); 
131:         tok1.approve(address(strategyHelper), bal1);

163:         rew.approve(address(strategyHelper), amt); 

171:         IERC20(address(pair)).approve(address(rewarder), liq); 

192:         lp.approve(address(rewarder), bal); 
```


</details>


---
### [L&#x2011;30] Some tokens may revert when zero value transfers are made
In spite of the fact that EIP-20 [states](https://github.com/ethereum/EIPs/blob/46b9b698815abbfa628cd1097311deee77dd45c5/EIPS/eip-20.md?plain=1#L116) that zero-valued transfers must be accepted, some tokens, such as LEND will revert if this is attempted, which may cause transactions that involve other tokens (such as batch operations) to fully revert. Consider skipping the transfer if the amount is zero, which will also save gas.

<details>
<summary><i>There are 17 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

43:         if (!IERC20(token).transfer(to, amount)) revert TransferFailed(); 
```


```solidity
📁 File: Helper.sol

65:             IERC20(a).transfer(a, IERC20(a).balanceOf(address(this))); 

72:         asset.transfer(msg.sender, asset.balanceOf(address(this)) - amount - premium); 
```


```solidity
📁 File: Investor.sol

252:         IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))); 

501:         if (!IERC20(asset).transfer(user, amount)) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

50:         asset.transfer(msg.sender, amount); 
```


```solidity
📁 File: PositionManager.sol

269:         if (bal > 0 && !asset.transfer(usr, bal)) revert TransferFailed(); 
```


```solidity
📁 File: StrategyCamelotV3.sol

340:         IERC20(trgtAst).transfer(address(strategyHelperUniswapV3), toLp); 
```


```solidity
📁 File: StrategyGMXGM.sol

140:       IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))); 

174:         IERC20(tokenShort).transfer(to, amount); 

287:         IERC20(market).transfer(strategy, IERC20(market).balanceOf(address(this))); 
288:         IERC20(tokenLong).transfer(strategy, IERC20(tokenLong).balanceOf(address(this)));
289:         IERC20(tokenShort).transfer(strategy, IERC20(tokenShort).balanceOf(address(this)));
```


```solidity
📁 File: StrategySushiswap.sol

102:             IERC20(tok0).transfer(address(pair), tok0.balanceOf(address(this))); 
103:             IERC20(tok1).transfer(address(pair), tok1.balanceOf(address(this)));

166:         IERC20(pair.token0()).transfer(address(pair), IERC20(pair.token0()).balanceOf(address(this))); 
167:         IERC20(pair.token1()).transfer(address(pair), IERC20(pair.token1()).balanceOf(address(this)));
```


</details>


---
### [L&#x2011;31] Some tokens may revert when zero value transfers are made
In spite of the fact that EIP-20 [states](https://github.com/ethereum/EIPs/blob/46b9b698815abbfa628cd1097311deee77dd45c5/EIPS/eip-20.md?plain=1#L116) that zero-valued transfers must be accepted, some tokens, such as `LEND` will revert if this is attempted, which may cause transactions that involve other tokens (such as batch operations) to fully revert. Consider skipping the transfer if the amount is zero, which will also save **gas**.

<details>
<summary><i>There are 10 instances of this issue:</i></summary>

```solidity
📁 File: InvestorStrategyProxy.sol

50:         asset.transfer(msg.sender, amount); 
```


```solidity
📁 File: PositionManager.sol

189:         transferFrom(from, to, id); 

199:         transferFrom(from, to, id); 

263:         if (!IERC20(ast).transferFrom(usr, address(this), amt)) revert TransferFailed(); 
```


```solidity
📁 File: StrategyCamelotV3.sol

142:         asset.transferFrom(msg.sender, address(this), amount); 

196:         hypervisor.transfer(to, amount); 

340:         IERC20(trgtAst).transfer(address(strategyHelperUniswapV3), toLp); 
```


```solidity
📁 File: StrategyGMXGM.sol

148:         asset.transferFrom(msg.sender, address(this), amount); 

174:         IERC20(tokenShort).transfer(to, amount); 
```


```solidity
📁 File: StrategySushiswap.sol

91:         asset.transferFrom(msg.sender, address(this), amount); 
```


</details>


---
### [L&#x2011;32] State variables not capped at reasonable values
Consider adding minimum/maximum value checks to ensure that the state variables below can never be used to excessively harm users, including via griefing

<details>
<summary><i>There are 9 instances of this issue:</i></summary>

```solidity
📁 File: StrategyCamelotV3.sol

/// @audit totalShares on line 188
170:     function burn(uint256 shares) external auth loop returns (uint256) { 
171:         uint256 tma = totalManagedAssets();
172:         uint256 amt = (shares * tma) / totalShares;
173:         uint256 val = valueLiquidity() * amt / tma;
174:         unstake(amt);
175:         (uint256 amt0, uint256 amt1) = hypervisor.withdraw(amt, address(this), address(this), [uint256(0), 0, 0, 0]);
176: 
177:         address strategyHelperAddress = address(strategyHelper);
178:         hypervisor.token0().approve(strategyHelperAddress, amt0);
179:         hypervisor.token1().approve(strategyHelperAddress, amt1);
180: 
181:         uint256 bal;
182:         uint256 slp = slippage;
183:         bal += strategyHelper.swap(address(hypervisor.token0()), address(asset), amt0, slp, msg.sender);
184:         bal += strategyHelper.swap(address(hypervisor.token1()), address(asset), amt1, slp, msg.sender);
185: 
186:         if (strategyHelper.value(address(asset), bal) < val * (10000 - slp) / 10000) revert PriceSlipped();
187: 
188:         totalShares -= shares;
189:         emit Burn(bal, shares);
190:         return bal;
191:     }

/// @audit totalShares on line 198
193:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 
194:         uint256 amount = shares * totalManagedAssets() / totalShares;
195:         unstake(amount);
196:         hypervisor.transfer(to, amount);
197: 
198:         totalShares -= shares;
199:         emit Kill(amount, shares);
200: 
201:         address[] memory assets = new address[](1);
202:         assets[0] = address(hypervisor);
203:         return abi.encode(bytes32("camelotv3"), assets);
204:     }

/// @audit tokenId on line 392
390:     function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external returns (bytes4) { 
391:         if (msg.sender == address(nftPool) && tokenId == 0) {
392:             tokenId = _tokenId;
393:         }
394:         return StrategyCamelotV3.onERC721Received.selector;
395:     }
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit totalShares on line 166
159:     function burn(uint256 shares) external auth loop returns (uint256) { 
160:         uint256 slp = slippage;
161:         uint256 val = rate(shares);
162:         uint256 amt = (val * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort);
163:         IERC20(tokenShort).approve(address(strategyHelper), amt);
164:         uint256 bal = strategyHelper.swap(tokenShort, address(asset), amt, slp, msg.sender);
165: 
166:         totalShares -= shares;
167:         emit Burn(bal, shares);
168:         return bal;
169:     }

/// @audit totalShares on line 176
171:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 
172:         uint256 value = rate(shares);
173:         uint256 amount = (value * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort);
174:         IERC20(tokenShort).transfer(to, amount);
175: 
176:         totalShares -= shares;
177:         emit Kill(amount, shares);
178: 
179:         address[] memory assets = new address[](1);
180:         assets[0] = tokenShort;
181:         return abi.encode(bytes32("gmxgm"), assets);
182:     }
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit poolId on line 34
29:     constructor(address _asset, address _strategyHelper, address _rewarder, uint256 _poolId) { 
30:         exec[msg.sender] = true;
31:         asset = IERC20(_asset);
32:         strategyHelper = IStrategyHelper(_strategyHelper);
33:         rewarder = ISushiswapMiniChefV2(_rewarder);
34:         poolId = _poolId;
35:         pool = IUniswapV2Pair(rewarder.lpToken(poolId));
36:         name =
37:             string(abi.encodePacked("SushiSwap ", IERC20(pool.token0()).symbol(), "/", IERC20(pool.token1()).symbol()));
38:     }

/// @audit slippage on line 65
63:     function file(bytes32 what, uint256 data) external auth { 
64:         if (what == "slippage") {
65:             slippage = data;
66:         } else {
67:             revert InvalidFile();
68:         }
69:         emit File(what, data);
70:     }

/// @audit totalShares on line 136
117:     function burn(uint256 shares) public auth loop returns (uint256) { 
118:         IUniswapV2Pair pair = pool;
119:         uint256 slp = slippage;
120:         {
121:             uint256 tma = totalManagedAssets();
122:             uint256 amt = shares * tma / totalShares;
123:             rewarder.withdraw(poolId, amt, address(pair));
124:             pair.burn(address(this));
125:         }
126:         IERC20 tok0 = IERC20(pair.token0());
127:         IERC20 tok1 = IERC20(pair.token1());
128:         uint256 bal0 = tok0.balanceOf(address(this));
129:         uint256 bal1 = tok1.balanceOf(address(this));
130:         tok0.approve(address(strategyHelper), bal0);
131:         tok1.approve(address(strategyHelper), bal1);
132:         uint256 amt0 = strategyHelper.swap(address(tok0), address(asset), bal0, slp, msg.sender);
133:         uint256 amt1 = strategyHelper.swap(address(tok1), address(asset), bal1, slp, msg.sender);
134:         uint256 amount =  amt0 + amt1;
135: 
136:         totalShares -= shares;
137:         emit Burn(amount, shares);
138:         return amount;
139:     }

/// @audit totalShares on line 145
141:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 
142:         uint256 amount = shares * totalManagedAssets() / totalShares;
143:         rewarder.withdraw(poolId, amount, to);
144: 
145:         totalShares -= shares;
146:         emit Kill(amount, shares);
147: 
148:         address[] memory assets = new address[](1);
149:         assets[0] = address(pool);
150:         return abi.encode(bytes32("sushi"), assets);
151:     }
```


</details>


---
### [L&#x2011;33] `symbol()` is not a part of the ERC-20 standard
The `symbol()` function is not a part of the [ERC-20 standard](https://eips.ethereum.org/EIPS/eip-20), and was added later as an [optional extension](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol). As such, some valid ERC20 tokens do not support this interface, so it is unsafe to blindly cast all tokens to this interface, and then call this function.

<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: StrategyCamelotV3.sol

71:         name = string(abi.encodePacked("Camelot V3 ", hypervisor.token0().symbol(), "/", hypervisor.token1().symbol())); 
```


```solidity
📁 File: StrategyGMXGM.sol

75:                 "GMX GM ", IERC20(marketInfo.longToken).symbol(), "/", IERC20(marketInfo.shortToken).symbol() 
```


```solidity
📁 File: StrategySushiswap.sol

37:             string(abi.encodePacked("SushiSwap ", IERC20(pool.token0()).symbol(), "/", IERC20(pool.token1()).symbol())); 
```


</details>


---
### [L&#x2011;34] `tokenURI()` does not follow EIP-721
The [EIP](https://eips.ethereum.org/EIPS/eip-721) states that `tokenURI()` "Throws if `_tokenId` is not a valid NFT", which the code below does not do. If the NFT has not yet been minted, `tokenURI()` should revert


<i>There is one instance of this issue:</i>

```solidity
📁 File: PositionManager.sol

272:     function tokenURI(uint256 id) public view returns (string memory) { 
273:         string memory image = generateImage(id);
274:         return string(
275:             abi.encodePacked(
276:                 "data:application/json;base64,",
277:                 Base64.encode(
278:                     bytes(
279:                         abi.encodePacked(
280:                             '{"name":"#',
281:                             Strings.toString(id),
282:                             '","description":"This NFT represents a leveraged farming position on Rodeo Finance. The owner of this NFT can modify or redeem the position.","image":"',
283:                             "data:image/svg+xml;base64,",
284:                             image,
285:                             '"}'
286:                         )
287:                     )
288:                 )
289:             )
290:         );
291:     }
```



---
### [L&#x2011;35] `unchecked` blocks with additions/multiplications may overflow
There aren't any checks to avoid an overflow which can happen inside an unchecked block, so the following expressions may overflow silently.


<i>There are 7 instaces of this issue:</i>

```solidity
📁 File: StrategySushiswap.sol

/// @audit unchecked block 204-213
205:             result = (result + a / result) >> 1; 
/// @audit unchecked block 204-213
206:             result = (result + a / result) >> 1;
/// @audit unchecked block 204-213
207:             result = (result + a / result) >> 1;
/// @audit unchecked block 204-213
208:             result = (result + a / result) >> 1;
/// @audit unchecked block 204-213
209:             result = (result + a / result) >> 1;
/// @audit unchecked block 204-213
210:             result = (result + a / result) >> 1;
/// @audit unchecked block 204-213
211:             result = (result + a / result) >> 1;
```



---
### [L&#x2011;36] `unchecked` blocks with subtractions may underflow
There aren't any checks to avoid an underflow which can happen inside an `unchecked` block, so the following subtractions may underflow silently.


<i>There is one instance of this issue:</i>

```solidity
📁 File: PositionManager.sol

157:             unchecked { _balanceOf[from]--; } 
```



---
### [L&#x2011;37] Unsafe conversion from unsigned to signed values
Solidity follows [two's complement](https://en.wikipedia.org/wiki/Two%27s_complement) rules for its integers, meaning that the most significant bit for signed integers is used to denote the sign, and converting between the two requires inverting all of the bits and adding one. Because of this, casting an unsigned integer to a signed one may result in a change of the sign and or magnitude of the value. For example, `int8(type(uint8).max)` is not equal to `type(int8).max`, but is equal to `-1`. `type(uint8).max` in binary is `11111111`, which if cast to a signed value, means the first binary `1` indicates a negative value, and the binary `1`s, invert to all zeroes, and when one is added, it becomes one, but negative, and therefore the decimal value of binary `11111111` is `-1`.

<details>
<summary><i>There are 3 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

/// @audit uint256 -> int256
377:             collateralAdjusted = -int256(amt); 
```


```solidity
📁 File: Store.sol

/// @audit uint256 -> int256
53:         uint256 next = uint256(int256(prev) + value); 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit uint32 -> int32
352:         uint160 midX96 = TickMath.getSqrtRatioAtTick(int24((tickCumulatives[1] - tickCumulatives[0]) / int32(period))); 
```


</details>


---
### [L&#x2011;38] Unsafe downcast
When a type is downcast to a smaller type, the higher order bits are discarded, resulting in the application of a modulo operation to the original value.

If the downcasted value is large enough, this may result in an overflow that will not revert.


<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyCamelotV3.sol

/// @audit int56 -> int24
352:         uint160 midX96 = TickMath.getSqrtRatioAtTick(int24((tickCumulatives[1] - tickCumulatives[0]) / int32(period))); 
```



---
### [L&#x2011;39] Unused/empty `receive()/fallback()` function
If the intention is for the Ether to be used, the function should call another function or emit an event, otherwise it should revert.


<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

80:     receive() external payable {} 
```



---
### [L&#x2011;40] Use of `abi.encodeWithSignature`/`abi.encodeWithSelector` instead of `abi.encodeCall`
Consider refactoring the code by using `abi.encodeCall` instead of `abi.encodeWithSignature`/`abi.encodeWithSelector`, as the former keeps the code [typo/type safe](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3693).

<details>
<summary><i>There are 8 instances of this issue:</i></summary>

```solidity
📁 File: StrategyGMXGM.sol

235:             data[0] = abi.encodeWithSelector(IExchangeRouter.sendWnt.selector, vault, params.executionFee); 
236:             data[1] = abi.encodeWithSelector(IExchangeRouter.sendTokens.selector, marketInfo.longToken, vault, out);

238:                 abi.encodeWithSelector(IExchangeRouter.sendTokens.selector, marketInfo.shortToken, vault, amt - haf); 
239:             data[3] = abi.encodeWithSelector(IExchangeRouter.createDeposit.selector, params);

273:             data[0] = abi.encodeWithSelector(IExchangeRouter.sendWnt.selector, withdrawalVault, params.executionFee); 
274:             data[1] = abi.encodeWithSelector(IExchangeRouter.sendTokens.selector, market, withdrawalVault, amt);
275:             data[2] = abi.encodeWithSelector(IExchangeRouter.createWithdrawal.selector, params);
```


```solidity
📁 File: UtilFarmingBalances.sol

22:             (bool ok, bytes memory data) = address(pm).staticcall(abi.encodeWithSelector(IPositionManager.ownerOf.selector, y)); 
```


</details>


## NonCritical


---
### [NC&#x2011;1] Add inline comments for unnamed variables
`function foo(address x, address)` -> `function foo(address x, address /* y */)`

<details>
<summary><i>There are 9 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

48:     function executeOperation( 
49:       address,
50:       uint256 amount,
51:       uint256 premium,
52:       address initiator,
53:       bytes calldata params
54:     ) external returns (bool) {
```


```solidity
📁 File: StrategyCamelotV3.sol

390:     function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external returns (bytes4) { 

397:     function onNFTHarvest(address, address, uint256, uint256, uint256) public pure returns (bool) { 

401:     function onNFTAddToPosition(address, uint256, uint256) public pure returns (bool) { 

405:     function onNFTWithdraw(address, uint256, uint256) public pure returns (bool) { 
```


```solidity
📁 File: StrategyGMXGM.sol

335:     function afterDepositExecution(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 

340:     function afterDepositCancellation(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 

345:     function afterWithdrawalExecution(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 

353:     function afterWithdrawalCancellation(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 
```


</details>


---
### [NC&#x2011;2] `address` shouldn't be hard-coded
It is often better to declare `address`es as `immutable` (instead of constant), and assign them via constructor arguments. This allows the code to remain the same across deployments on different networks, and avoids recompilation when addresses need to change.


<i>There are 2 instaces of this issue:</i>

```solidity
📁 File: UtilFarmingBalances.sol

/// @audit 0x8accf43Dd31DfCd4919cc7d65912A475BfA60369
15:         IInvestor i = IInvestor(0x8accf43Dd31DfCd4919cc7d65912A475BfA60369); 
/// @audit 0x5e4d7F61cC608485A2E4F105713D26D58a9D0cF6
16:         IPositionManager pm = IPositionManager(0x5e4d7F61cC608485A2E4F105713D26D58a9D0cF6);
```



---
### [NC&#x2011;3] Assembly blocks should have extensive comments
Assembly blocks take a lot more time to audit than normal Solidity code, and often have gotchas and side-effects that the Solidity versions of the same code do not. Consider adding more comments explaining what is being done in every step of the assembly code, and describe why assembly is being used instead of Solidity.

<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: InvestorStrategyProxy.sol

61:             assembly { 
62:                 returndatacopy(0, 0, returndatasize())
63:                 revert(0, returndatasize())
64:             }
```


```solidity
📁 File: StrategyCamelotV3.sol

379:         assembly { 
380:             key := or(shl(24, or(shl(24, owner), and(minTick, 0xFFFFFF))), and(maxTick, 0xFFFFFF))
381:         }
```


</details>


---
### [NC&#x2011;4] Avoid mutating `function`/`modifier` parameters
Use a local variable instead
> ❗ Issue is removed from: (sme6en)


<i>There are 7 instaces of this issue:</i>

```solidity
📁 File: StrategySushiswap.sol

/// @audit value
220:                 value >>= 128; 

/// @audit value
224:                 value >>= 64; 

/// @audit value
228:                 value >>= 32; 

/// @audit value
232:                 value >>= 16; 

/// @audit value
236:                 value >>= 8; 

/// @audit value
240:                 value >>= 4; 

/// @audit value
244:                 value >>= 2; 
```



---
### [NC&#x2011;5] Avoid the use of sensitive terms
Use [alternative variants](https://www.zdnet.com/article/mysql-drops-master-slave-and-blacklist-whitelist-terminology/), e.g. allowlist/denylist instead of whitelist/blacklist

<details>
<summary><i>There are 39 instances of this issue:</i></summary>

```solidity
📁 File: Deploy.s.sol

10: import {Whitelist} from "./Whitelist.sol"; 

96:     function whitelist() internal { 

100:         Whitelist w = new Whitelist(); 
101:         w.file("whitelist", deployer);
102:         i.file("whitelist", address(w));
103:         pm.file("whitelist", address(w));
104:         w.file("whitelist", address(pm));
```


```solidity
📁 File: Investor.sol

61: interface IWhitelist { 

68:     IWhitelist public whitelist; 

113:     error NotWhitelisted(); 

165:         } else if (what == "whitelist") { 
166:             whitelist = IWhitelist(data);

256:         if (address(whitelist) != address(0)) { 
257:             if (!whitelist.check(msg.sender)) revert NotWhitelisted();
```


```solidity
📁 File: PositionManager.sol

55: interface IWhitelist { 

68:     IWhitelist public whitelist; 

84:     error NotWhitelisted(); 

106:         } else if (what == "whitelist") { 
107:             whitelist = IWhitelist(data);

215:         if (address(whitelist) != address(0)) { 
216:             if (!whitelist.check(msg.sender)) revert NotWhitelisted();
```


```solidity
📁 File: Whitelist.sol

4: contract Whitelist { 

6:     mapping(address => bool) public whitelist; 

9:     event BatchWhitelist(address[] addresses, bool status); 

26:         } else if (what == "whitelist") { 
27:             whitelist[data] = !whitelist[data];

34:     function batchWhitelist(address[] memory addresses, bool status) external auth { 

37:             whitelist[addresses[i]] = status; 

39:         emit BatchWhitelist(addresses, status); 

43:         return whitelist[user]; 
```


</details>


---
### [NC&#x2011;6] Codebase should implement formal verification testing
Formal verification is the act of proving or disproving the correctness of intended algorithms underlying a system with respect to a certain formal specification/property/invariant, using formal methods of mathematics.

Some tools that are currently available to perform these tests on smart contracts are [SMTChecker](https://docs.soliditylang.org/en/latest/smtchecker.html) and [Certora Prover](https://www.certora.com/).


---
### [NC&#x2011;7] Complicated functions should have explicit comments
Large and/or complex functions should have more comments to better explain the purpose of each logic step.

<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

/// @audit function is 91 lines long
295:     function edit(uint256 id, int256 borrow, int256 collateral) external loop { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit function is 97 lines long
184:     function earn() external payable loop { 
```


</details>


---
### [NC&#x2011;8] Consider adding a block/deny-list
Doing so will significantly increase centralization, but will help to prevent hackers from using stolen tokens

<details>
<summary><i>There are 11 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

8: contract Bank { 
9:     mapping(address => bool) public exec;
10: 
11:     event File(bytes32 indexed what, address data);
12: 
13:     error InvalidFile();
14:     error Unauthorized();
15:     error TransferFailed();
16: 
17:     constructor() {
18:         exec[msg.sender] = true;
```


```solidity
📁 File: Helper.sol

29: contract Helper { 
30:     IInvestor public investor;
31:     IERC20 public asset;
32:     IAavePool public lender; // 0x794a61358D6845594F94dc1DB02A252b5b4814aD
33:     IStrategyHelper public sh;
34:     uint256 public slippage = 2500;
35: 
36:     constructor(address _investor, address _asset, address _lender, address _sh) {
37:         investor = IInvestor(_investor);
38:         asset = IERC20(_asset);
39:         lender = IAavePool(_lender);
```


```solidity
📁 File: Investor.sol

65: contract Investor { 
66:     IStore public store;
67:     IHelper public helper;
68:     IWhitelist public whitelist;
69:     IStrategyProxy public strategyProxy;
70:     uint256 public slippage = 200;
71:     uint256 public performanceFee = 2000;
72:     uint256 public killCollateralPadding = 500;
73:     uint256 public closeCollateralPadding = 400;
74:     bool internal entered;
75:     mapping(uint256 => uint256) private lastBlock;
```


```solidity
📁 File: InvestorStrategyProxy.sol

15: contract InvestorStrategyProxy { 
16:     IERC20 public asset;
17:     mapping(address => bool) public exec;
18: 
19:     event File(bytes32 indexed what, address data);
20: 
21:     error InvalidFile();
22:     error Unauthorized();
23: 
24:     constructor(address _asset) {
25:         asset = IERC20(_asset);
```


```solidity
📁 File: PositionManager.sol

64: contract PositionManager { 
65:     string public constant name = "Rodeo V2 Position";
66:     string public constant symbol = "RP2";
67:     IInvestor public investor;
68:     IWhitelist public whitelist;
69:     mapping(address => bool) public exec;
70:     mapping(uint256 => address) internal _ownerOf;
71:     mapping(address => uint256) internal _balanceOf;
72:     mapping(address => Ids) internal _ownerIds;
73:     mapping(uint256 => address) public getApproved;
74:     mapping(address => mapping(address => bool)) public isApprovedForAll;
```


```solidity
📁 File: Store.sol

4: contract Store { 
5:     mapping(address => bool) public exec;
6:     mapping(bytes32 => uint256) public uintValues;
7:     mapping(bytes32 => int256) public intValues;
8:     mapping(bytes32 => address) public addressValues;
9:     mapping(bytes32 => bool) public boolValues;
10:     mapping(bytes32 => string) public stringValues;
11:     mapping(bytes32 => bytes32) public bytes32Values;
12:     mapping(bytes32 => bytes32[]) public bytes32ArrayValues;
13:     mapping(bytes32 => Bytes32Set) internal bytes32Sets;
14: 
```


```solidity
📁 File: StrategyCamelotV3.sol

7: contract StrategyCamelotV3 { 
8:     string public name;
9:     uint256 public totalShares = 1_000_000;
10:     uint256 public slippage = 500;
11:     bool internal entered;
12:     IERC20 public asset;
13:     IStrategyHelper public strategyHelper;
14:     mapping(address => bool) public exec;
15:     mapping(address => bool) public keepers;
16: 
17:     IXGrail public immutable xgrail;
```


```solidity
📁 File: StrategyGMXGM.sol

4: contract StrategyGMXGM { 
5:     string public name;
6:     uint256 public totalShares = 1_000_000;
7:     uint256 public slippage = 500;
8:     bool internal entered;
9:     IERC20 public asset;
10:     IStrategyHelper public strategyHelper;
11:     mapping(address => bool) public exec;
12:     mapping(address => bool) public keepers;
13: 
14:     IExchangeRouter public exchangeRouter;
```


```solidity
📁 File: StrategySushiswap.sol

4: contract StrategySushiswap { 
5:     string public name;
6:     uint256 public totalShares = 1_000_000;
7:     uint256 public slippage = 500;
8:     bool internal entered;
9:     IERC20 public asset;
10:     IStrategyHelper public strategyHelper;
11:     ISushiswapMiniChefV2 public rewarder;
12:     IUniswapV2Pair public pool;
13:     uint256 public poolId;
14:     mapping(address => bool) public exec;
```


```solidity
📁 File: UtilFarmingBalances.sol

13: contract UtilFarmingBalances { 
14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) {
15:         IInvestor i = IInvestor(0x8accf43Dd31DfCd4919cc7d65912A475BfA60369);
16:         IPositionManager pm = IPositionManager(0x5e4d7F61cC608485A2E4F105713D26D58a9D0cF6);
17:         uint256 max = i.nextPosition();
18:         address[] memory users = new address[](max-start);
19:         uint256[] memory balances = new uint256[](max-start);
20:         for (uint256 y = start; y < max; y++) {
21:             (,,,,,uint256 value,) = i.positions(y);
22:             (bool ok, bytes memory data) = address(pm).staticcall(abi.encodeWithSelector(IPositionManager.ownerOf.selector, y));
23:             if (ok) {
```


```solidity
📁 File: Whitelist.sol

4: contract Whitelist { 
5:     mapping(address => bool) public exec;
6:     mapping(address => bool) public whitelist;
7: 
8:     event File(bytes32 indexed what, address data);
9:     event BatchWhitelist(address[] addresses, bool status);
10: 
11:     error InvalidFile();
12:     error Unauthorized();
13: 
14:     constructor() {
```


</details>


---
### [NC&#x2011;9] Consider disallowing transfers to `address(this)`
<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

35:     function transferNative(address to, uint256 amount) external auth { 

41:     function transfer(address token, address to, uint256 amount) external auth { 
```


```solidity
📁 File: PositionManager.sol

182:     function transferFrom(address from, address to, uint256 id) public auth(id) { 

188:     function safeTransferFrom(address from, address to, uint256 id) public { 

198:     function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public { 
```


```solidity
📁 File: StrategyGMXGM.sol

138:     function withdrawAirdrop(address token) external auth { 
```


</details>


---
### [NC&#x2011;10] Consider enabling `--via-ir` for enhanced code transparency and auditability
The `--via-ir` command line option enables Solidity's IR-based code generator, offering a level of transparency and auditability superior to the traditional, direct-to-EVM method. The Intermediate Representation (IR) in Yul serves as an intermediary, offering a more transparent view of how the Solidity code is transformed into EVM bytecode.

While it does introduce slight semantic variations, these are mostly in areas unlikely to impact the typical contract's behavior.
It is encouraged to test this feature to gain its benefits, which include making the code generation process more transparent and auditable.

[Solidity Documentation](https://docs.soliditylang.org/en/v0.8.20/ir-breaking-changes.html#solidity-ir-based-codegen-changes).
> ❗ Issue is removed from: (pech)


---
### [NC&#x2011;11] Consider making contracts `Upgradeable`
This allows for bugs to be fixed in production, at the expense of *significantly* increasing centralization.

<details>
<summary><i>There are 11 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit contract Bank is not upgradeable
8: contract Bank { 
```


```solidity
📁 File: Helper.sol

/// @audit contract Helper is not upgradeable
29: contract Helper { 
```


```solidity
📁 File: Investor.sol

/// @audit contract Investor is not upgradeable
65: contract Investor { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit contract InvestorStrategyProxy is not upgradeable
15: contract InvestorStrategyProxy { 
```


```solidity
📁 File: PositionManager.sol

/// @audit contract PositionManager is not upgradeable
64: contract PositionManager { 
```


```solidity
📁 File: Store.sol

/// @audit contract Store is not upgradeable
4: contract Store { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit contract StrategyCamelotV3 is not upgradeable
7: contract StrategyCamelotV3 { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit contract StrategyGMXGM is not upgradeable
4: contract StrategyGMXGM { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit contract StrategySushiswap is not upgradeable
4: contract StrategySushiswap { 
```


```solidity
📁 File: UtilFarmingBalances.sol

/// @audit contract UtilFarmingBalances is not upgradeable
13: contract UtilFarmingBalances { 
```


```solidity
📁 File: Whitelist.sol

/// @audit contract Whitelist is not upgradeable
4: contract Whitelist { 
```


</details>


---
### [NC&#x2011;12] Consider moving duplicated strings to constants
<details>
<summary><i>There are 34 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit 'exec' is seen 9 times
27:         if (what == "exec") { 
```


```solidity
📁 File: Helper.sol

/// @audit 'sushi' is seen 2 times
63:         if (strategy == "sushi") { 
```


```solidity
📁 File: Investor.sol

/// @audit 'exec' is seen 9 times
163:         if (what == "exec") { 

/// @audit 'whitelist' is seen 3 times
165:         } else if (what == "whitelist") { 

/// @audit 'slippage' is seen 4 times
189:         if (what == "slippage") { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit 'exec' is seen 9 times
35:         if (what == "exec") { 
```


```solidity
📁 File: PositionManager.sol

/// @audit 'exec' is seen 9 times
102:         if (what == "exec") { 

/// @audit 'whitelist' is seen 3 times
106:         } else if (what == "whitelist") { 

/// @audit 'NOT_MINTED' is seen 3 times
115:         require((owner = _ownerOf[id]) != address(0), "NOT_MINTED"); 

/// @audit 'NOT_AUTHORIZED' is seen 2 times
138:             "NOT_AUTHORIZED" 

/// @audit 'NOT_AUTHORIZED' is seen 2 times
145:         require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED"); 

/// @audit 'INVALID_RECIPIENT' is seen 2 times
184:         require(to != address(0), "INVALID_RECIPIENT"); 

/// @audit 'UNSAFE_RECIPIENT' is seen 3 times
194:             "UNSAFE_RECIPIENT" 

/// @audit 'UNSAFE_RECIPIENT' is seen 3 times
204:             "UNSAFE_RECIPIENT" 

/// @audit 'INVALID_RECIPIENT' is seen 2 times
221:         require(to != address(0), "INVALID_RECIPIENT"); 

/// @audit 'UNSAFE_RECIPIENT' is seen 3 times
228:             "UNSAFE_RECIPIENT" 

/// @audit 'NOT_MINTED' is seen 3 times
248:         require(owner != address(0), "NOT_MINTED"); 

/// @audit 'NOT_MINTED' is seen 3 times
254:         require(owner != address(0), "NOT_MINTED"); 

/// @audit '</text></g>' is seen 3 times
334:                 "</text></g>" 

/// @audit '</text></g>' is seen 3 times
354:                 "</text></g>" 

/// @audit '</text></g>' is seen 3 times
369:                 "</text></g>" 
```


```solidity
📁 File: Store.sol

/// @audit 'exec' is seen 9 times
36:         if (what == "exec") { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit 'exec' is seen 9 times
91:         if (what == "exec") { 

/// @audit 'keeper' is seen 3 times
93:         } else if (what == "keeper") { 

/// @audit 'slippage' is seen 4 times
108:         if (what == "slippage") { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit 'exec' is seen 9 times
95:         if (what == "exec") { 

/// @audit 'keeper' is seen 3 times
97:         } else if (what == "keeper") { 

/// @audit 'slippage' is seen 4 times
116:         if (what == "slippage") { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit 'exec' is seen 9 times
53:         if (what == "exec") { 

/// @audit 'keeper' is seen 3 times
55:         } else if (what == "keeper") { 

/// @audit 'slippage' is seen 4 times
64:         if (what == "slippage") { 

/// @audit 'sushi' is seen 2 times
150:         return abi.encode(bytes32("sushi"), assets); 
```


```solidity
📁 File: Whitelist.sol

/// @audit 'exec' is seen 9 times
24:         if (what == "exec") { 

/// @audit 'whitelist' is seen 3 times
26:         } else if (what == "whitelist") { 
```


</details>


---
### [NC&#x2011;13] Consider moving `msg.sender` checks to a common authorization `modifier`

<i>There are 4 instaces of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

336:         if (msg.sender != depositHandler) revert NotGMX(); 

341:         if (msg.sender != depositHandler) revert NotGMX(); 

346:         if (msg.sender != withdrawalHandler) revert NotGMX(); 

354:         if (msg.sender != withdrawalHandler) revert NotGMX(); 
```



---
### [NC&#x2011;14] Consider providing a ranged getter for array state variables
While the compiler automatically provides a getter for accessing single elements within a public state variable array, it doesn't provide a way to fetch the whole array, or subsets thereof. Consider adding a function to allow the fetching of slices of the array, especially if the contract doesn't already have multicall functionality.

<details>
<summary><i>There are 32 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

87:         uint256[] values; 
```


```solidity
📁 File: Store.sol

12:     mapping(bytes32 => bytes32[]) public bytes32ArrayValues; 

16:         bytes32[] values; 
```


```solidity
📁 File: StrategyGMXGM.sol

407:         address[] longTokenSwapPath; 
408:         address[] shortTokenSwapPath;

420:         address[] longTokenSwapPath; 
421:         address[] shortTokenSwapPath;

512:         address[] longTokenSwapPath; 
513:         address[] shortTokenSwapPath;

543:         address[] longTokenSwapPath; 
544:         address[] shortTokenSwapPath;

573:         AddressKeyValue[] items; 
574:         AddressArrayKeyValue[] arrayItems;

578:         UintKeyValue[] items; 
579:         UintArrayKeyValue[] arrayItems;

583:         IntKeyValue[] items; 
584:         IntArrayKeyValue[] arrayItems;

588:         BoolKeyValue[] items; 
589:         BoolArrayKeyValue[] arrayItems;

593:         Bytes32KeyValue[] items; 
594:         Bytes32ArrayKeyValue[] arrayItems;

598:         BytesKeyValue[] items; 
599:         BytesArrayKeyValue[] arrayItems;

603:         StringKeyValue[] items; 
604:         StringArrayKeyValue[] arrayItems;

614:         address[] value; 

624:         uint256[] value; 

634:         int256[] value; 

644:         bool[] value; 

654:         bytes32[] value; 

664:         bytes[] value; 

674:         string[] value; 
```


</details>


---
### [NC&#x2011;15] Consider using `delete` rather than assigning zero to clear values
The `delete` keyword more closely matches the semantics of what is being done, and draws more attention to the changing of state, which may lead to a more thorough audit of its associated logic.

<details>
<summary><i>There are 8 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

339:                 p.basis = 0; 

439:         p.borrow = 0; 
```


```solidity
📁 File: StrategyCamelotV3.sol

213:             if (tokenId != 0) tokenId = 0; 

349:         secondsAgos[1] = 0; 
```


```solidity
📁 File: StrategyGMXGM.sol

337:         amountPendingDeposit = 0; 

342:         amountPendingDeposit = 0; 

347:         amountPendingWithdraw = 0; 

355:         amountPendingWithdraw = 0; 
```


</details>


---
### [NC&#x2011;16] Consider using named function arguments
When calling functions in external contracts with multiple arguments, consider using [named](https://docs.soliditylang.org/en/latest/control-structures.html#function-calls-with-named-parameters) function parameters, rather than positional ones.

<details>
<summary><i>There are 41 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

45:         lender.flashLoanSimple(address(this), address(asset), repay, abi.encodePacked(id), 0); 

80:         sh.swap(_fromAsset, address(asset), amount, slippage, address(this)); 
```


```solidity
📁 File: Investor.sol

344:                     uint256 cAmount = helper.convert(poolAsset, p.token, needed - amount); 

349:                     uint256 topup = helper.swap(p.token, poolAsset, cAmount, slippage, address(this)); 

434:         bytes memory data = strategyProxy.kill(s.implementation, shares, msg.sender); 
```


```solidity
📁 File: PositionManager.sol

192:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") 

202:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) 

220:         uint256 id = investor.open(strategy, token, collateral, borrow); 

226:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") 

239:         investor.edit(id, borrow, collateral); 
```


```solidity
📁 File: StrategyCamelotV3.sol

148:         strategyHelper.swap(address(asset), tgtAst, amount, slp, address(this)); 

157:             liq = uniProxy.deposit(amt0, amt1, address(this), hyp, [uint256(0), 0, 0, 0]); 

175:         (uint256 amt0, uint256 amt1) = hypervisor.withdraw(amt, address(this), address(this), [uint256(0), 0, 0, 0]); 

183:         bal += strategyHelper.swap(address(hypervisor.token0()), address(asset), amt0, slp, msg.sender); 
184:         bal += strategyHelper.swap(address(hypervisor.token1()), address(asset), amt1, slp, msg.sender);

244:                 strategyHelper.swap(rewardToken1, tgtAsset, balance, slp, address(this)); 

252:                 strategyHelper.swap(rewardToken2, tgtAsset, balance, slp, address(this)); 

260:                 strategyHelper.swap(rewardToken3, tgtAsset, balance, slp, address(this)); 

270:         stake(uniProxy.deposit(amt0, amt1, address(this), h, [uint256(0), 0, 0, 0])); 

313:             uniProxy.getDepositAmount(address(hypervisor), address(hypervisor.token0()), out0); 

339:         uint256 minOut = strategyHelper.convert(trgtAst, ast, toLp) * (10000 - slp) / 10000; 

341:         strategyHelperUniswapV3.swap(trgtAst, path, toLp, minOut, address(this)); 
```


```solidity
📁 File: StrategyGMXGM.sol

150:         uint256 bal = strategyHelper.swap(address(asset), tokenShort, amount, slp, address(this)); 

164:         uint256 bal = strategyHelper.swap(tokenShort, address(asset), amt, slp, msg.sender); 

196:             strategyHelper.swap(tokenLong, tokenShort, bal, slp, address(this)); 

207:             uint256 out = strategyHelper.swap(tokenShort, tokenLong, haf, slp, address(this)); 

245:             (uint256 longOut, uint256 shortOut) = reader.getWithdrawalAmountOut( 
246:                 dataStore,
247:                 marketInfo,
248:                 IMarket.Prices({
249:                     indexTokenPrice: gmxPrice(marketInfo.indexToken, true),
250:                     longTokenPrice: gmxPrice(marketInfo.longToken, false),
251:                     shortTokenPrice: gmxPrice(marketInfo.shortToken, false)
252:                 }),
253:                 amt,
254:                 address(0)
255:             );

308:         (int256 price,) = r.getMarketTokenPrice( 
309:             store,
310:             marketInfo,
311:             gmxPrice(marketInfo.indexToken, true),
312:             gmxPrice(marketInfo.longToken, false),
313:             gmxPrice(marketInfo.shortToken, false),
314:             isDeposit ? MAX_PNL_FACTOR_FOR_DEPOSITS : MAX_PNL_FACTOR_FOR_WITHDRAWALS,
315:             false // maximize
316:         );

350:         try strategyHelper.swap(tokenLong, tokenShort, bal, slippage, address(this)) {} catch {} 
```


```solidity
📁 File: StrategySushiswap.sol

100:             strategyHelper.swap(address(asset), address(tok0), haf, slp, address(this)); 
101:             strategyHelper.swap(address(asset), address(tok1), amount - haf, slp, address(this));

109:         rewarder.deposit(poolId, liq, address(this)); 

123:             rewarder.withdraw(poolId, amt, address(pair)); 

132:         uint256 amt0 = strategyHelper.swap(address(tok0), address(asset), bal0, slp, msg.sender); 
133:         uint256 amt1 = strategyHelper.swap(address(tok1), address(asset), bal1, slp, msg.sender);

143:         rewarder.withdraw(poolId, amount, to); 

164:         strategyHelper.swap(address(rew), pair.token0(), haf, slippage, address(this)); 
165:         strategyHelper.swap(address(rew), pair.token1(), amt - haf, slippage, address(this));

172:         rewarder.deposit(poolId, liq, address(this)); 

183:         rewarder.withdraw(poolId, totalShares, strategy); 

193:         rewarder.deposit(poolId, bal, address(this)); 
```


</details>


---
### [NC&#x2011;17] Consider using named mappings
Consider moving to solidity version 0.8.18 or later, and using [named mappings](https://ethereum.stackexchange.com/a/145555) to make it easier to understand the purpose of each mapping

<details>
<summary><i>There are 15 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

9:     mapping(address => bool) public exec; 
```


```solidity
📁 File: Investor.sol

75:     mapping(uint256 => uint256) private lastBlock; 
76:     mapping(address => bool) public exec;
```


```solidity
📁 File: Store.sol

5:     mapping(address => bool) public exec; 
6:     mapping(bytes32 => uint256) public uintValues;
7:     mapping(bytes32 => int256) public intValues;
8:     mapping(bytes32 => address) public addressValues;
9:     mapping(bytes32 => bool) public boolValues;
10:     mapping(bytes32 => string) public stringValues;
11:     mapping(bytes32 => bytes32) public bytes32Values;
12:     mapping(bytes32 => bytes32[]) public bytes32ArrayValues;
13:     mapping(bytes32 => Bytes32Set) internal bytes32Sets;

17:         mapping(bytes32 => uint256) positions; 
```


```solidity
📁 File: Whitelist.sol

5:     mapping(address => bool) public exec; 
6:     mapping(address => bool) public whitelist;
```


</details>


---
### [NC&#x2011;18] Consider using `SafeTransferLib.safeTransferETH()` or `Address.sendValue()`
These Functions indicate their purpose with their name more clearly than using low-level calls.

<details>
<summary><i>There are 3 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

37:         (bool s,) = to.call{value: amount}(""); 
```


```solidity
📁 File: InvestorStrategyProxy.sol

59:         (bool success,) = strategy.call{value: value}(data); 
```


```solidity
📁 File: StrategyGMXGM.sol

134:         (bool success,) = address(msg.sender).call{value: address(this).balance}(""); 
```


</details>


---
### [NC&#x2011;19] Constants in comparisons should appear on the left side
Putting constants on the left side of comparison statements is a best practice known as [Yoda conditions](https://en.wikipedia.org/wiki/Yoda_conditions). Although solidity's static typing system prevents accidental assignments within conditionals, adopting this practice can improve code readability and consistency, especially when working across multiple languages.

<details>
<summary><i>There are 83 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit move exec to the left
27:         if (what == "exec") { 

/// @audit move 0 to the left
36:         if (amount == 0) return; 

/// @audit move 0 to the left
42:         if (amount == 0) return; 
```


```solidity
📁 File: Helper.sol

/// @audit move sushi to the left
63:         if (strategy == "sushi") { 
```


```solidity
📁 File: Investor.sol

/// @audit move exec to the left
163:         if (what == "exec") { 

/// @audit move whitelist to the left
165:         } else if (what == "whitelist") { 

/// @audit move helper to the left
167:         } else if (what == "helper") { 

/// @audit move 0 to the left
171:             if (helper.price(poolAsset) == 0) revert InvalidFile(); 
/// @audit move strategyProxy to the left
172:         } else if (what == "strategyProxy") {

/// @audit move bank to the left
175:         } else if (what == "bank") { 

/// @audit move pool to the left
178:         } else if (what == "pool") { 

/// @audit move slippage to the left
189:         if (what == "slippage") { 

/// @audit move performanceFee to the left
192:         } else if (what == "performanceFee") { 

/// @audit move killCollateralPadding to the left
195:         } else if (what == "killCollateralPadding") { 

/// @audit move closeCollateralPadding to the left
198:         } else if (what == "closeCollateralPadding") { 

/// @audit move status to the left
201:         } else if (what == "status") { 
/// @audit move 0 to the left
202:             if (data == 0 || data > 4) revert InvalidFile();

/// @audit move 0 to the left
265:         if (collateralCap == 0) revert UnknownCollateral(); 

/// @audit move 0 to the left
278:             if (si.totalShares() == 0) revert StrategyUninitialized(); 

/// @audit move msg.sender to the left
303:         if (p.owner != msg.sender) revert NotOwner(); 

/// @audit move 0 to the left
305:         if (borrow > 0 && p.shares == 0) revert InvalidParameters(); 

/// @audit move block.number to the left
307:         if (lastBlock[id] == block.number) revert NoEditingInSameBlock(); 

/// @audit move 0 to the left
338:             if (p.shares == 0) { 

/// @audit move 0 to the left
362:             if (si.totalShares() == 0) revert StrategyUninitialized(); 
/// @audit move 0 to the left
363:             if (p.shares == 0) revert StrategyClosed();

/// @audit move block.number to the left
404:         if (lastBlock[id] == block.number) revert NoEditingInSameBlock(); 

/// @audit move 0 to the left
452:         if (p.borrow == 0) return 1e18; 

/// @audit move 0 to the left
500:         if (amount == 0) return; 

/// @audit move 0 to the left
507:         if (amount == 0) return; 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit move exec to the left
35:         if (what == "exec") { 
```


```solidity
📁 File: PositionManager.sol

/// @audit move exec to the left
102:         if (what == "exec") { 

/// @audit move investor to the left
104:         } else if (what == "investor") { 

/// @audit move whitelist to the left
106:         } else if (what == "whitelist") { 

/// @audit move 0 to the left
190:         require( 
191:             to.code.length == 0
192:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "")
193:                     == ERC721TokenReceiver.onERC721Received.selector,
194:             "UNSAFE_RECIPIENT"
195:         );

/// @audit move 0 to the left
200:         require( 
201:             to.code.length == 0
202:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)
203:                     == ERC721TokenReceiver.onERC721Received.selector,
204:             "UNSAFE_RECIPIENT"
205:         );

/// @audit move 0 to the left
224:         require( 
225:             to.code.length == 0
226:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
227:                     == ERC721TokenReceiver.onERC721Received.selector,
228:             "UNSAFE_RECIPIENT"
229:         );

/// @audit move 0 to the left
246:         require(p.collateral == 0, "NOT_CLOSED"); 
```


```solidity
📁 File: Store.sol

/// @audit move exec to the left
36:         if (what == "exec") { 

/// @audit move 0 to the left
142:         if (s.positions[value] == 0) { 

/// @audit move 0 to the left
150:         if (position != 0) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit move exec to the left
91:         if (what == "exec") { 

/// @audit move keeper to the left
93:         } else if (what == "keeper") { 

/// @audit move rewardToken1 to the left
95:         } else if (what == "rewardToken1") { 

/// @audit move rewardToken2 to the left
97:         } else if (what == "rewardToken2") { 

/// @audit move rewardToken3 to the left
99:         } else if (what == "rewardToken3") { 

/// @audit move slippage to the left
108:         if (what == "slippage") { 

/// @audit move twapPeriod to the left
110:         } else if (what == "twapPeriod") { 

/// @audit move 0 to the left
124:         if (tokenId == 0) revert TokenIdNeededFirst(); 

/// @audit move 0 to the left
163:         uint256 shares = tma == 0 ? liq : liq * totalShares / tma; 

/// @audit move 0 to the left
208:         if (tokenId != 0 && totalManagedAssets() > 0) { 

/// @audit move 0 to the left
213:             if (tokenId != 0) tokenId = 0; 

/// @audit move 0 to the left
232:         if (tokenId == 0) return; 

/// @audit move 0 to the left
277:         if (tokenId == 0) return; 

/// @audit move 0 to the left
371:         if (tokenId == 0) return 0; 

/// @audit move 0 to the left
391:         if (msg.sender == address(nftPool) && tokenId == 0) { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit move exec to the left
95:         if (what == "exec") { 

/// @audit move keeper to the left
97:         } else if (what == "keeper") { 

/// @audit move reader to the left
99:         } else if (what == "reader") { 

/// @audit move exchangeRouter to the left
101:         } else if (what == "exchangeRouter") { 

/// @audit move depositHandler to the left
103:         } else if (what == "depositHandler") { 

/// @audit move withdrawalHandler to the left
106:         } else if (what == "withdrawalHandler") { 

/// @audit move slippage to the left
116:         if (what == "slippage") { 

/// @audit move indexTokenDecimals to the left
118:         } else if (what == "indexTokenDecimals") { 

/// @audit move reserveRatio to the left
120:         } else if (what == "reserveRatio") { 

/// @audit move callbackGasLimit to the left
123:         } else if (what == "callbackGasLimit") { 

/// @audit move earnActionValue to the left
125:         } else if (what == "earnActionValue") { 

/// @audit move 0 to the left
/// @audit move 0 to the left
152:         uint256 shares = (tma == 0 || tot == 0) ? val : val * tot / tma; 

/// @audit move 0 to the left
/// @audit move 0 to the left
188:         if (amountPendingDeposit != 0 || amountPendingWithdraw != 0) { 

/// @audit move 0 to the left
/// @audit move 0 to the left
284:         if (amountPendingDeposit != 0 || amountPendingWithdraw != 0) { 

/// @audit move 0 to the left
327:         if (decimals == 0) { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit move exec to the left
53:         if (what == "exec") { 

/// @audit move keeper to the left
55:         } else if (what == "keeper") { 

/// @audit move slippage to the left
64:         if (what == "slippage") { 

/// @audit move 0 to the left
/// @audit move 0 to the left
73:         if (sha == 0 || totalShares == 0) return 0; 

/// @audit move 0 to the left
110:         uint256 shares = tma == 0 ? liq : liq * totalShares / tma; 

/// @audit move 0 to the left
187:         require(totalShares == 0, "ts=0"); 

/// @audit move 0 to the left
202:         if (a == 0) return 0; 
```


```solidity
📁 File: Whitelist.sol

/// @audit move exec to the left
24:         if (what == "exec") { 

/// @audit move whitelist to the left
26:         } else if (what == "whitelist") { 
```


</details>


---
### [NC&#x2011;20] `constant`s should be defined rather than using magic numbers
Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals

<details>
<summary><i>There are 101 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

190:             if (data > 1e18) revert InvalidFile(); 

193:             if (data > 5000) revert InvalidFile(); 

196:             if (data > 1e18) revert InvalidFile(); 

199:             if (data > 1e18) revert InvalidFile(); 

202:             if (data == 0 || data > 4) revert InvalidFile(); 

215:         store.setUint(keccak256(abi.encode(index, STRATEGIES_STATUS)), 4); 
216:         emit StrategyUpdate(index, implementation, 4, 0);

288:         if (_life(p) < 1e18) revert Undercollateralized(); 

335:             uint256 repaying = amount * 1e18 / index; 

341:                 uint256 needed = p.borrow * index / 1e18; 

345:                     cAmount = cAmount * (10000 + closeCollateralPadding) / 10000; 

357:             push(poolAsset, msg.sender, (amount - used) * (10000 - performanceFee) / 10000); 

382:         if (_life(p) < 1e18) revert Undercollateralized(); 

391:         uint256 borrow = p.borrow * pool.getUpdatedIndex() / 1e18; 
392:         uint256 fee = borrow * killCollateralPadding / 10000 / 2;

402:         if (_life(p) >= 1e18) revert PositionNotLiquidatable(); 

408:         uint256 borrow = p.borrow * pool.getUpdatedIndex() / 1e18; 
409:         uint256 fee = borrow * killCollateralPadding / 10000 / 2;

423:                 collat = (target - amount) * 1e18 / helper.price(p.token); 

452:         if (p.borrow == 0) return 1e18; 

459:         uint256 value = (sharesValue + collateralValue) * factor / 1e18; 
460:         uint256 price = (uint256(oracle.latestAnswer()) * 1e18) / (10 ** oracle.decimals());
461:         uint256 scaled = (p.borrow * 1e18) / (10 ** IERC20(pool.asset()).decimals());
462:         uint256 borrow = (scaled * pool.getUpdatedIndex() / 1e18) * price / 1e18;
463:         return value * 1e18 / borrow;
```


```solidity
📁 File: PositionManager.sol

209:         return interfaceId == 0x01ffc9a7 // ERC165 
210:             || interfaceId == 0x80ac58cd // ERC721
211:             || interfaceId == 0x5b5e139f; // ERC721Metadata

326:         string memory str = formatNumber(IStrategy(s.implementation).rate(p.shares), 18, 2); 
327:         uint256 len = bytes(str).length + 7;

331:                 Strings.toString(7 * (len + 4)), 

344:             (p.borrow * IPool(pool).getUpdatedIndex() / 1e18) * 1e18 / (10 ** IERC20(IPool(pool).asset()).decimals()) 

346:         string memory str = formatNumber(amt, 18, 2); 
347:         uint256 len = bytes(str).length + 8;

351:                 Strings.toString(7 * (len + 4)), 

361:         string memory str = formatNumber(amt, 18, 2); 
362:         uint256 len = bytes(str).length + 6;

366:                 Strings.toString(7 * (len + 4)), 
```


```solidity
📁 File: StrategyCamelotV3.sol

162:         if (val < strategyHelper.value(address(asset), amount) * (10000 - slp) / 10000) revert PriceSlipped(); 

186:         if (strategyHelper.value(address(asset), bal) < val * (10000 - slp) / 10000) revert PriceSlipped(); 

242:             if (strategyHelper.value(rewardToken1, balance) > 1e18) { 

250:             if (strategyHelper.value(rewardToken2, balance) > 1e18) { 

258:             if (strategyHelper.value(rewardToken3, balance) > 1e18) { 

265:         if (strategyHelper.value(tgtAsset, amt) < 1e18) return; 

314:         uint256 toLp0 = amt * 1e18 / ((((start + end) / 2) * 1e18 / out1) + 1e18); 

339:         uint256 minOut = strategyHelper.convert(trgtAst, ast, toLp) * (10000 - slp) / 10000; 

433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares); 

442:     function withdraw(uint256 shares, address to, address from, uint256[4] memory minAmounts) external returns (uint256 amount0, uint256 amount1); 
```


```solidity
📁 File: StrategyGMXGM.sol

121:             if (data > 10000) revert WrongReserveRatio(); 

201:         uint256 need = rate(totalShares) * reserveRatio / 10000; 

208:             uint256 minOut = (have - need) * 1e18 / marketTokenPrice(true); 

210:             minOut = minOut * (10000 - slp) / 10000; 

228:             bytes[] memory data = new bytes[](4); 

239:             data[3] = abi.encodeWithSelector(IExchangeRouter.createDeposit.selector, params); 

242:             uint256 amt = (need - have) * 1e18 / marketTokenPrice(true); 

263:                 minLongTokenAmount: longOut * (10000 - slp) / 10000, 
264:                 minShortTokenAmount: shortOut * (10000 - slp) / 10000,

271:             bytes[] memory data = new bytes[](3); 

299:         val += bal * marketTokenPrice(true) / 1e18; 

319:         return price < 0 ? 0 : uint256(price) / 1e12; 

331:         price = price * (10 ** (30 - decimals)) / 1e18; 
```


```solidity
📁 File: StrategySushiswap.sol

81:             reserve0 = uint256(r0) * 1e18 / (10 ** IERC20(pair.token0()).decimals()); 
82:             reserve1 = uint256(r1) * 1e18 / (10 ** IERC20(pair.token1()).decimals());

87:         return sha * (val * amt / 1e18) / totalShares; 

162:         if (strategyHelper.value(address(rew), amt) < 0.5e18) return; 

219:             if (value >> 128 > 0) { 
220:                 value >>= 128;
221:                 result += 128;

223:             if (value >> 64 > 0) { 
224:                 value >>= 64;
225:                 result += 64;

227:             if (value >> 32 > 0) { 
228:                 value >>= 32;
229:                 result += 32;

231:             if (value >> 16 > 0) { 
232:                 value >>= 16;
233:                 result += 16;

235:             if (value >> 8 > 0) { 
236:                 value >>= 8;
237:                 result += 8;

239:             if (value >> 4 > 0) { 
240:                 value >>= 4;
241:                 result += 4;
```


```solidity
📁 File: UtilFarmingBalances.sol

15:         IInvestor i = IInvestor(0x8accf43Dd31DfCd4919cc7d65912A475BfA60369); 
16:         IPositionManager pm = IPositionManager(0x5e4d7F61cC608485A2E4F105713D26D58a9D0cF6);
```


</details>


---
### [NC&#x2011;21] `constant`s/`immutable`s redefined elsewhere
Consider defining each of these in only one contract so that values cannot become out of sync when only one location is updated (i.e. having `ContA.X`,`ContB.Y` is fine since they're different constant names in different files, but `ContA.X`, `ContB.X` is not since it's the same constant defined in multiple files with the same value). Even things like `decimals` and `VERSION` can employ file-level constants such as `PREFERRED_DECIMALS = 18` and `INITIAL_VERSION = "1.0.0"`

<details>
<summary><i>There are 34 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

78:     uint256 public constant STATUS_LIVE = 4; 
79:     uint256 public constant STATUS_WITHDRAW = 3;
80:     uint256 public constant STATUS_LIQUIDATE = 2;
81:     uint256 public constant STATUS_PAUSED = 1;
82:     bytes32 constant STATUS = keccak256(abi.encode("STATUS"));
83:     bytes32 constant BANK = keccak256(abi.encode("BANK"));
84:     bytes32 constant POOL = keccak256(abi.encode("POOL"));
85:     bytes32 constant STRATEGIES_ADDRESS = keccak256(abi.encode("STRATEGIES_ADDRESS"));
86:     bytes32 constant STRATEGIES_CAP = keccak256(abi.encode("STRATEGIES_CAP"));
87:     bytes32 constant STRATEGIES_STATUS = keccak256(abi.encode("STRATEGIES_STATUS"));
88:     bytes32 constant COLLATERAL_FACTOR = keccak256(abi.encode("COLLATERAL_FACTOR"));
89:     bytes32 constant COLLATERAL_CAP = keccak256(abi.encode("COLLATERAL_CAP"));
90:     bytes32 constant POSITIONS = keccak256(abi.encode("POSITIONS"));
91:     bytes32 constant POSITIONS_OWNER = keccak256(abi.encode("POSITIONS_OWNER"));
92:     bytes32 constant POSITIONS_START = keccak256(abi.encode("POSITIONS_START"));
93:     bytes32 constant POSITIONS_STRATEGY = keccak256(abi.encode("POSITIONS_STRATEGY"));
94:     bytes32 constant POSITIONS_TOKEN = keccak256(abi.encode("POSITIONS_TOKEN"));
95:     bytes32 constant POSITIONS_COLLATERAL = keccak256(abi.encode("POSITIONS_COLLATERAL"));
96:     bytes32 constant POSITIONS_BASIS = keccak256(abi.encode("POSITIONS_BASIS"));
97:     bytes32 constant POSITIONS_SHARES = keccak256(abi.encode("POSITIONS_SHARES"));
98:     bytes32 constant POSITIONS_BORROW = keccak256(abi.encode("POSITIONS_BORROW"));
```


```solidity
📁 File: PositionManager.sol

65:     string public constant name = "Rodeo V2 Position"; 
66:     string public constant symbol = "RP2";
```


```solidity
📁 File: StrategyCamelotV3.sol

17:     IXGrail public immutable xgrail; 
18:     IStrategyHelperUniswapV3 public immutable strategyHelperUniswapV3;
19:     IUniProxy public immutable uniProxy;
20:     IQuoter public immutable quoter;
21:     IHypervisor public immutable hypervisor;
```


```solidity
📁 File: StrategyGMXGM.sol

20:     address public immutable dataStore; 
21:     address public immutable market;
22:     address public immutable tokenLong; // Volatile
23:     address public immutable tokenShort; // Stable

322:     bytes32 constant MAX_PNL_FACTOR_FOR_DEPOSITS = keccak256(abi.encode("MAX_PNL_FACTOR_FOR_DEPOSITS")); 
323:     bytes32 constant MAX_PNL_FACTOR_FOR_WITHDRAWALS = keccak256(abi.encode("MAX_PNL_FACTOR_FOR_WITHDRAWALS"));
```


</details>


---
### [NC&#x2011;22] `constructor` should emit an event
Use events to signal significant changes to off-chain monitoring tools.

<details>
<summary><i>There are 10 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

17:     constructor() { 
```


```solidity
📁 File: Helper.sol

36:     constructor(address _investor, address _asset, address _lender, address _sh) { 
```


```solidity
📁 File: Investor.sol

144:     constructor(address _store, address _helper) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

24:     constructor(address _asset) { 
```


```solidity
📁 File: PositionManager.sol

91:     constructor(address _investor) { 
```


```solidity
📁 File: Store.sol

26:     constructor() { 
```


```solidity
📁 File: StrategyCamelotV3.sol

48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _xgrail,
52:         address _strategyHelperUniswapV3,
53:         address _uniProxy,
54:         address _quoter,
55:         address _hypervisor,
56:         address _nftPool,
57:         address _targetAsset,
58:         bytes memory _pathToLp
59:     ) {
```


```solidity
📁 File: StrategyGMXGM.sol

48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _exchangeRouter,
52:         address _reader,
53:         address _depositHandler,
54:         address _withdrawalHandler,
55:         address _dataStore,
56:         address _market
57:     ) {
```


```solidity
📁 File: StrategySushiswap.sol

29:     constructor(address _asset, address _strategyHelper, address _rewarder, uint256 _poolId) { 
```


```solidity
📁 File: Whitelist.sol

14:     constructor() { 
```


</details>


---
### [NC&#x2011;23] Contract uses both `require()`/`revert()` as well as custom errors
Consider using just one method in a single file

<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

64: contract PositionManager { 
```


```solidity
📁 File: StrategySushiswap.sol

4: contract StrategySushiswap { 
```


</details>


---
### [NC&#x2011;24] `contract`/`library`/`interface` definitions should be defined in separate files
This helps to make tracking changes across commits easier, among other reasons. They can be combined into a single file later by importing multiple contracts, and using that file as the common import.

<details>
<summary><i>There are 62 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit IERC20, Bank
4: interface IERC20 { 

/// @audit IERC20, Bank
8: contract Bank { 
```


```solidity
📁 File: Helper.sol

/// @audit IERC20, IInvestor, IAavePool, IStrategyHelper, ISushi, Helper
4: interface IERC20 { 

/// @audit IERC20, IInvestor, IAavePool, IStrategyHelper, ISushi, Helper
10: interface IInvestor { 

/// @audit IERC20, IInvestor, IAavePool, IStrategyHelper, ISushi, Helper
15: interface IAavePool { 

/// @audit IERC20, IInvestor, IAavePool, IStrategyHelper, ISushi, Helper
19: interface IStrategyHelper { 

/// @audit IERC20, IInvestor, IAavePool, IStrategyHelper, ISushi, Helper
23: interface ISushi { 

/// @audit IERC20, IInvestor, IAavePool, IStrategyHelper, ISushi, Helper
29: contract Helper { 
```


```solidity
📁 File: Investor.sol

/// @audit IERC20, IOracle, IStore, IBank, IPool, IHelper, IStrategy, IStrategyProxy, IWhitelist, Investor
4: interface IERC20 { 

/// @audit IERC20, IOracle, IStore, IBank, IPool, IHelper, IStrategy, IStrategyProxy, IWhitelist, Investor
12: interface IOracle { 

/// @audit IERC20, IOracle, IStore, IBank, IPool, IHelper, IStrategy, IStrategyProxy, IWhitelist, Investor
17: interface IStore { 

/// @audit IERC20, IOracle, IStore, IBank, IPool, IHelper, IStrategy, IStrategyProxy, IWhitelist, Investor
26: interface IBank { 

/// @audit IERC20, IOracle, IStore, IBank, IPool, IHelper, IStrategy, IStrategyProxy, IWhitelist, Investor
31: interface IPool { 

/// @audit IERC20, IOracle, IStore, IBank, IPool, IHelper, IStrategy, IStrategyProxy, IWhitelist, Investor
40: interface IHelper { 

/// @audit IERC20, IOracle, IStore, IBank, IPool, IHelper, IStrategy, IStrategyProxy, IWhitelist, Investor
47: interface IStrategy { 

/// @audit IERC20, IOracle, IStore, IBank, IPool, IHelper, IStrategy, IStrategyProxy, IWhitelist, Investor
54: interface IStrategyProxy { 

/// @audit IERC20, IOracle, IStore, IBank, IPool, IHelper, IStrategy, IStrategyProxy, IWhitelist, Investor
61: interface IWhitelist { 

/// @audit IERC20, IOracle, IStore, IBank, IPool, IHelper, IStrategy, IStrategyProxy, IWhitelist, Investor
65: contract Investor { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit IERC20, IStrategy, InvestorStrategyProxy
4: interface IERC20 { 

/// @audit IERC20, IStrategy, InvestorStrategyProxy
9: interface IStrategy { 

/// @audit IERC20, IStrategy, InvestorStrategyProxy
15: contract InvestorStrategyProxy { 
```


```solidity
📁 File: PositionManager.sol

/// @audit IERC20, IOracle, IPool, IStrategy, IInvestor, IWhitelist, ERC721TokenReceiver, PositionManager
7: interface IERC20 { 

/// @audit IERC20, IOracle, IPool, IStrategy, IInvestor, IWhitelist, ERC721TokenReceiver, PositionManager
15: interface IOracle { 

/// @audit IERC20, IOracle, IPool, IStrategy, IInvestor, IWhitelist, ERC721TokenReceiver, PositionManager
20: interface IPool { 

/// @audit IERC20, IOracle, IPool, IStrategy, IInvestor, IWhitelist, ERC721TokenReceiver, PositionManager
26: interface IStrategy { 

/// @audit IERC20, IOracle, IPool, IStrategy, IInvestor, IWhitelist, ERC721TokenReceiver, PositionManager
31: interface IInvestor { 

/// @audit IERC20, IOracle, IPool, IStrategy, IInvestor, IWhitelist, ERC721TokenReceiver, PositionManager
55: interface IWhitelist { 

/// @audit IERC20, IOracle, IPool, IStrategy, IInvestor, IWhitelist, ERC721TokenReceiver, PositionManager
59: interface ERC721TokenReceiver { 

/// @audit IERC20, IOracle, IPool, IStrategy, IInvestor, IWhitelist, ERC721TokenReceiver, PositionManager
64: contract PositionManager { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit StrategyCamelotV3, IERC20, IStrategyHelper, IStrategyHelperUniswapV3, IUniProxy, IQuoter, IHypervisor, INFTPool, INitroPool, IAlgebraPool, IXGrail
7: contract StrategyCamelotV3 { 

/// @audit StrategyCamelotV3, IERC20, IStrategyHelper, IStrategyHelperUniswapV3, IUniProxy, IQuoter, IHypervisor, INFTPool, INitroPool, IAlgebraPool, IXGrail
414: interface IERC20 { 

/// @audit StrategyCamelotV3, IERC20, IStrategyHelper, IStrategyHelperUniswapV3, IUniProxy, IQuoter, IHypervisor, INFTPool, INitroPool, IAlgebraPool, IXGrail
422: interface IStrategyHelper { 

/// @audit StrategyCamelotV3, IERC20, IStrategyHelper, IStrategyHelperUniswapV3, IUniProxy, IQuoter, IHypervisor, INFTPool, INitroPool, IAlgebraPool, IXGrail
428: interface IStrategyHelperUniswapV3 { 

/// @audit StrategyCamelotV3, IERC20, IStrategyHelper, IStrategyHelperUniswapV3, IUniProxy, IQuoter, IHypervisor, INFTPool, INitroPool, IAlgebraPool, IXGrail
432: interface IUniProxy { 

/// @audit StrategyCamelotV3, IERC20, IStrategyHelper, IStrategyHelperUniswapV3, IUniProxy, IQuoter, IHypervisor, INFTPool, INitroPool, IAlgebraPool, IXGrail
437: interface IQuoter { 

/// @audit StrategyCamelotV3, IERC20, IStrategyHelper, IStrategyHelperUniswapV3, IUniProxy, IQuoter, IHypervisor, INFTPool, INitroPool, IAlgebraPool, IXGrail
441: interface IHypervisor is IERC20 { 

/// @audit StrategyCamelotV3, IERC20, IStrategyHelper, IStrategyHelperUniswapV3, IUniProxy, IQuoter, IHypervisor, INFTPool, INitroPool, IAlgebraPool, IXGrail
453: interface INFTPool { 

/// @audit StrategyCamelotV3, IERC20, IStrategyHelper, IStrategyHelperUniswapV3, IUniProxy, IQuoter, IHypervisor, INFTPool, INitroPool, IAlgebraPool, IXGrail
466: interface INitroPool { 

/// @audit StrategyCamelotV3, IERC20, IStrategyHelper, IStrategyHelperUniswapV3, IUniProxy, IQuoter, IHypervisor, INFTPool, INitroPool, IAlgebraPool, IXGrail
471: interface IAlgebraPool { 

/// @audit StrategyCamelotV3, IERC20, IStrategyHelper, IStrategyHelperUniswapV3, IUniProxy, IQuoter, IHypervisor, INFTPool, INitroPool, IAlgebraPool, IXGrail
490: interface IXGrail { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit StrategyGMXGM, IERC20, IStrategyHelper, IHandler, IPriceFeed, IDataStore, IExchangeRouter, IMarket, IPrice, IMarketPoolValueInfo, IReader, IDeposit, IWithdrawal, IEventUtils
4: contract StrategyGMXGM { 

/// @audit StrategyGMXGM, IERC20, IStrategyHelper, IHandler, IPriceFeed, IDataStore, IExchangeRouter, IMarket, IPrice, IMarketPoolValueInfo, IReader, IDeposit, IWithdrawal, IEventUtils
363: interface IERC20 { 

/// @audit StrategyGMXGM, IERC20, IStrategyHelper, IHandler, IPriceFeed, IDataStore, IExchangeRouter, IMarket, IPrice, IMarketPoolValueInfo, IReader, IDeposit, IWithdrawal, IEventUtils
372: interface IStrategyHelper { 

/// @audit StrategyGMXGM, IERC20, IStrategyHelper, IHandler, IPriceFeed, IDataStore, IExchangeRouter, IMarket, IPrice, IMarketPoolValueInfo, IReader, IDeposit, IWithdrawal, IEventUtils
378: interface IHandler { 

/// @audit StrategyGMXGM, IERC20, IStrategyHelper, IHandler, IPriceFeed, IDataStore, IExchangeRouter, IMarket, IPrice, IMarketPoolValueInfo, IReader, IDeposit, IWithdrawal, IEventUtils
383: interface IPriceFeed { 

/// @audit StrategyGMXGM, IERC20, IStrategyHelper, IHandler, IPriceFeed, IDataStore, IExchangeRouter, IMarket, IPrice, IMarketPoolValueInfo, IReader, IDeposit, IWithdrawal, IEventUtils
393: interface IDataStore { 

/// @audit StrategyGMXGM, IERC20, IStrategyHelper, IHandler, IPriceFeed, IDataStore, IExchangeRouter, IMarket, IPrice, IMarketPoolValueInfo, IReader, IDeposit, IWithdrawal, IEventUtils
399: interface IExchangeRouter { 

/// @audit StrategyGMXGM, IERC20, IStrategyHelper, IHandler, IPriceFeed, IDataStore, IExchangeRouter, IMarket, IPrice, IMarketPoolValueInfo, IReader, IDeposit, IWithdrawal, IEventUtils
437: interface IMarket { 

/// @audit StrategyGMXGM, IERC20, IStrategyHelper, IHandler, IPriceFeed, IDataStore, IExchangeRouter, IMarket, IPrice, IMarketPoolValueInfo, IReader, IDeposit, IWithdrawal, IEventUtils
454: interface IPrice { 

/// @audit StrategyGMXGM, IERC20, IStrategyHelper, IHandler, IPriceFeed, IDataStore, IExchangeRouter, IMarket, IPrice, IMarketPoolValueInfo, IReader, IDeposit, IWithdrawal, IEventUtils
461: interface IMarketPoolValueInfo { 

/// @audit StrategyGMXGM, IERC20, IStrategyHelper, IHandler, IPriceFeed, IDataStore, IExchangeRouter, IMarket, IPrice, IMarketPoolValueInfo, IReader, IDeposit, IWithdrawal, IEventUtils
477: interface IReader { 

/// @audit StrategyGMXGM, IERC20, IStrategyHelper, IHandler, IPriceFeed, IDataStore, IExchangeRouter, IMarket, IPrice, IMarketPoolValueInfo, IReader, IDeposit, IWithdrawal, IEventUtils
497: interface IDeposit { 

/// @audit StrategyGMXGM, IERC20, IStrategyHelper, IHandler, IPriceFeed, IDataStore, IExchangeRouter, IMarket, IPrice, IMarketPoolValueInfo, IReader, IDeposit, IWithdrawal, IEventUtils
530: interface IWithdrawal { 

/// @audit StrategyGMXGM, IERC20, IStrategyHelper, IHandler, IPriceFeed, IDataStore, IExchangeRouter, IMarket, IPrice, IMarketPoolValueInfo, IReader, IDeposit, IWithdrawal, IEventUtils
561: interface IEventUtils { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit StrategySushiswap, IERC20, IStrategyHelper, IUniswapV2Pair, ISushiswapMiniChefV2
4: contract StrategySushiswap { 

/// @audit StrategySushiswap, IERC20, IStrategyHelper, IUniswapV2Pair, ISushiswapMiniChefV2
253: interface IERC20 { 

/// @audit StrategySushiswap, IERC20, IStrategyHelper, IUniswapV2Pair, ISushiswapMiniChefV2
262: interface IStrategyHelper { 

/// @audit StrategySushiswap, IERC20, IStrategyHelper, IUniswapV2Pair, ISushiswapMiniChefV2
268: interface IUniswapV2Pair { 

/// @audit StrategySushiswap, IERC20, IStrategyHelper, IUniswapV2Pair, ISushiswapMiniChefV2
281: interface ISushiswapMiniChefV2 { 
```


```solidity
📁 File: UtilFarmingBalances.sol

/// @audit IInvestor, IPositionManager, UtilFarmingBalances
4: interface IInvestor { 

/// @audit IInvestor, IPositionManager, UtilFarmingBalances
9: interface IPositionManager { 

/// @audit IInvestor, IPositionManager, UtilFarmingBalances
13: contract UtilFarmingBalances { 
```


</details>


---
### [NC&#x2011;25] Contracts containing only utility functions should be made into libraries

<i>There is one instance of this issue:</i>

```solidity
📁 File: UtilFarmingBalances.sol

13: contract UtilFarmingBalances { 
14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) {
15:         IInvestor i = IInvestor(0x8accf43Dd31DfCd4919cc7d65912A475BfA60369);
16:         IPositionManager pm = IPositionManager(0x5e4d7F61cC608485A2E4F105713D26D58a9D0cF6);
17:         uint256 max = i.nextPosition();
```



---
### [NC&#x2011;26] Contracts should have all `public`/`external` functions exposed by `interface`s
The `contract`s should expose an `interface` so that other projects can more easily integrate with it, without having to develop their own non-standard variants.

<details>
<summary><i>There are 11 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit file, transferNative, transfer
8: contract Bank { 
9:     mapping(address => bool) public exec;
```


```solidity
📁 File: Helper.sol

/// @audit kill, executeOperation
29: contract Helper { 
30:     IInvestor public investor;
```


```solidity
📁 File: Investor.sol

/// @audit file, file, strategyNew, strategyUgrade, strategySetStatus, strategySetCap, collateralSetFactor, collateralSetCap, collect, open, edit, killRepayment, kill, life, getPosition, getStrategy, getPool
65: contract Investor { 
66:     IStore public store;
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit file, mint, burn, kill, call
15: contract InvestorStrategyProxy { 
16:     IERC20 public asset;
```


```solidity
📁 File: PositionManager.sol

/// @audit file, ownerOf, balanceOf, tokenOfOwnerByIndex, tokensOfOwner, approve, setApprovalForAll, transferFrom, safeTransferFrom, safeTransferFrom, supportsInterface, open, edit, burn, forceBurn, tokenURI
64: contract PositionManager { 
65:     string public constant name = "Rodeo V2 Position";
```


```solidity
📁 File: Store.sol

/// @audit file, getUint, setUint, setUintDelta, removeUint, getInt, setInt, setIntDelta, removeInt, getAddress, setAddress, removeAddress, getBool, setBool, removeBool, getString, setString, removeString, getBytes32, setBytes32, removeBytes32, getBytes32Array, setBytes32Array, removeBytes32Array, containsBytes32, getBytes32Count, getBytes32ValuesAt, addBytes32, removeBytes32
4: contract Store { 
5:     mapping(address => bool) public exec;
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit file, file, setPathToLp, setNitroPool, xgrailRedeem, xgrailFinalizeRedeem, mint, burn, kill, earn, exit, move, rate, onERC721Received, onNFTHarvest, onNFTAddToPosition, onNFTWithdraw
7: contract StrategyCamelotV3 { 
8:     string public name;
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit file, file, withdrawEth, withdrawAirdrop, mint, burn, kill, earn, exit, move, rate, marketTokenPrice, afterDepositExecution, afterDepositCancellation, afterWithdrawalExecution, afterWithdrawalCancellation
4: contract StrategyGMXGM { 
5:     string public name;
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit file, file, rate, mint, burn, kill, earn, totalManagedAssets, exit, move
4: contract StrategySushiswap { 
5:     string public name;
```


```solidity
📁 File: UtilFarmingBalances.sol

/// @audit get
13: contract UtilFarmingBalances { 
14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) {
```


```solidity
📁 File: Whitelist.sol

/// @audit file, batchWhitelist, check
4: contract Whitelist { 
5:     mapping(address => bool) public exec;
```


</details>


---
### [NC&#x2011;27] Contracts should have full test coverage
A 100% test coverage is not foolproof, but it helps immensely in reducing the amount of bugs that may occur.


---
### [NC&#x2011;28] Control structures do not follow the Solidity Style Guide
See the [control structures](https://docs.soliditylang.org/en/latest/style-guide.html#control-structures) section of the Solidity Style Guide


<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategySushiswap.sol

/// @audit opening brace should be preceded by a single space
90:     function mint(uint256 amount) public auth loop returns (uint256) {  
```



---
### [NC&#x2011;29] Custom `error` without details
Consider adding some parameters to the error to indicate which user or values caused the failure.

<details>
<summary><i>There are 53 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

13:     error InvalidFile(); 
14:     error Unauthorized();
15:     error TransferFailed();
```


```solidity
📁 File: Investor.sol

108:     error NotOwner(); 
109:     error InvalidFile();
110:     error WrongStatus();
111:     error NoReentering();
112:     error Unauthorized();
113:     error NotWhitelisted();
114:     error TransferFailed();
115:     error StrategyClosed();
116:     error StrategyExists();
117:     error StrategyOverCap();
118:     error UnknownStrategy();
119:     error UnknownCollateral();
120:     error CollateralOverCap();
121:     error InvalidParameters();
122:     error Undercollateralized();
123:     error NoEditingInSameBlock();
124:     error StrategyUninitialized();
125:     error PositionNotLiquidatable();
```


```solidity
📁 File: InvestorStrategyProxy.sol

21:     error InvalidFile(); 
22:     error Unauthorized();
```


```solidity
📁 File: PositionManager.sol

81:     error InvalidFile(); 
82:     error Unauthorized();
83:     error TransferFailed();
84:     error NotWhitelisted();
```


```solidity
📁 File: Store.sol

22:     error InvalidFile(); 
23:     error Unauthorized();
24:     error OverOrUnderflow();
```


```solidity
📁 File: StrategyCamelotV3.sol

39:     error NotKeeper(); 
40:     error InvalidFile();
41:     error NoReentering();
42:     error Unauthorized();
43:     error PriceSlipped();
44:     error WrongTargetAsset();
45:     error TwapPeriodTooLong();
46:     error TokenIdNeededFirst();
```


```solidity
📁 File: StrategyGMXGM.sol

38:     error NotKeeper(); 
39:     error InvalidFile();
40:     error NoReentering();
41:     error Unauthorized();
42:     error NotGMX();
43:     error BadToken();
44:     error ActionPending();
45:     error ErrorSendingETH();
46:     error WrongReserveRatio();
```


```solidity
📁 File: StrategySushiswap.sol

24:     error NotKeeper(); 
25:     error InvalidFile();
26:     error NoReentering();
27:     error Unauthorized();
```


```solidity
📁 File: Whitelist.sol

11:     error InvalidFile(); 
12:     error Unauthorized();
```


</details>


---
### [NC&#x2011;30] Custom errors should be used rather than `revert()`/`require()`
Custom errors are available from solidity version 0.8.4. Custom errors are more easily processed in try-catch blocks, and are easier to re-use and maintain.

<details>
<summary><i>There are 17 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

55:         require(msg.sender == address(lender), "!lender"); 
56:         require(initiator == address(this), "!me");
```


```solidity
📁 File: PositionManager.sol

115:         require((owner = _ownerOf[id]) != address(0), "NOT_MINTED"); 

119:         require(owner != address(0), "ZERO_ADDRESS"); 

136:         require( 
137:             msg.sender == owner || isApprovedForAll[owner][msg.sender] || msg.sender == getApproved[id],
138:             "NOT_AUTHORIZED"
139:         );

145:         require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED"); 

183:         require(from == _ownerOf[id], "WRONG_FROM"); 
184:         require(to != address(0), "INVALID_RECIPIENT");

190:         require( 
191:             to.code.length == 0
192:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "")
193:                     == ERC721TokenReceiver.onERC721Received.selector,
194:             "UNSAFE_RECIPIENT"
195:         );

200:         require( 
201:             to.code.length == 0
202:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)
203:                     == ERC721TokenReceiver.onERC721Received.selector,
204:             "UNSAFE_RECIPIENT"
205:         );

221:         require(to != address(0), "INVALID_RECIPIENT"); 
222:         require(_ownerOf[id] == address(0), "ALREADY_MINTED");

224:         require( 
225:             to.code.length == 0
226:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
227:                     == ERC721TokenReceiver.onERC721Received.selector,
228:             "UNSAFE_RECIPIENT"
229:         );

246:         require(p.collateral == 0, "NOT_CLOSED"); 

248:         require(owner != address(0), "NOT_MINTED"); 

254:         require(owner != address(0), "NOT_MINTED"); 
```


```solidity
📁 File: StrategySushiswap.sol

187:         require(totalShares == 0, "ts=0"); 
```


</details>


---
### [NC&#x2011;31] Dependence on external protocols
External protocols should be monitored as such dependencies may introduce vulnerabilities if a vulnerability is found /introduced in the external protocol

<details>
<summary><i>There are 12 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

455:         IOracle oracle = IOracle(pool.oracle()); 

460:         uint256 price = (uint256(oracle.latestAnswer()) * 1e18) / (10 ** oracle.decimals()); 
```


```solidity
📁 File: PositionManager.sol

342:         IOracle oracle = IOracle(IPool(pool).oracle()); 

345:         ) * uint256(oracle.latestAnswer()) / (10 ** oracle.decimals()); 
```


```solidity
📁 File: StrategyCamelotV3.sol

64:         strategyHelperUniswapV3 = IStrategyHelperUniswapV3(_strategyHelperUniswapV3); 

340:         IERC20(trgtAst).transfer(address(strategyHelperUniswapV3), toLp); 
341:         strategyHelperUniswapV3.swap(trgtAst, path, toLp, minOut, address(this));
```


```solidity
📁 File: StrategySushiswap.sol

35:         pool = IUniswapV2Pair(rewarder.lpToken(poolId)); 
```


</details>


---
### [NC&#x2011;32] Do not cache constants

<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

306:         address store = dataStore; 
```



---
### [NC&#x2011;33] Empty bytes check is missing
Passing empty bytes to a function can cause unexpected behavior, such as certain operations failing, producing incorrect results, or wasting gas. It is recommended to check that all byte parameters are not empty.

<details>
<summary><i>There are 46 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit what
26:     function file(bytes32 what, address data) external auth { 
```


```solidity
📁 File: Helper.sol

/// @audit params
48:     function executeOperation( 
49:       address,
50:       uint256 amount,
51:       uint256 premium,
52:       address initiator,
53:       bytes calldata params
54:     ) external returns (bool) {
```


```solidity
📁 File: Investor.sol

/// @audit what
162:     function file(bytes32 what, address data) external auth { 

/// @audit what
188:     function file(bytes32 what, uint256 data) external auth { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit what
34:     function file(bytes32 what, address data) public auth { 

/// @audit data
58:     function call(address strategy, uint256 value, bytes calldata data) public auth { 
```


```solidity
📁 File: PositionManager.sol

/// @audit what
101:     function file(bytes32 what, address data) external admin { 

/// @audit data
198:     function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public { 
```


```solidity
📁 File: Store.sol

/// @audit what
35:     function file(bytes32 what, address data) external auth { 

/// @audit key
47:     function setUint(bytes32 key, uint256 value) external auth returns (uint256) { 

/// @audit key
51:     function setUintDelta(bytes32 key, int256 value) external auth returns (uint256) { 

/// @audit key
59:     function removeUint(bytes32 key) external auth { 

/// @audit key
65:     function setInt(bytes32 key, int256 value) external auth returns (int256) { 

/// @audit key
69:     function setIntDelta(bytes32 key, int256 value) external auth returns (int256) { 

/// @audit key
74:     function removeInt(bytes32 key) external auth { 

/// @audit key
80:     function setAddress(bytes32 key, address value) external auth returns (address) { 

/// @audit key
84:     function removeAddress(bytes32 key) external auth { 

/// @audit key
90:     function setBool(bytes32 key, bool value) external auth returns (bool) { 

/// @audit key
94:     function removeBool(bytes32 key) external auth { 

/// @audit key
100:     function setString(bytes32 key, string memory value) external auth returns (string memory) { 

/// @audit key
104:     function removeString(bytes32 key) external auth { 

/// @audit key
/// @audit value
110:     function setBytes32(bytes32 key, bytes32 value) external auth returns (bytes32) { 

/// @audit key
114:     function removeBytes32(bytes32 key) external auth { 

/// @audit key
121:     function setBytes32Array(bytes32 key, bytes32[] memory value) external auth { 

/// @audit key
124:     function removeBytes32Array(bytes32 key) external auth { 

/// @audit key
/// @audit value
140:     function addBytes32(bytes32 key, bytes32 value) external auth { 

/// @audit key
/// @audit value
147:     function removeBytes32(bytes32 key, bytes32 value) external auth { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit _pathToLp
48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _xgrail,
52:         address _strategyHelperUniswapV3,
53:         address _uniProxy,
54:         address _quoter,
55:         address _hypervisor,
56:         address _nftPool,
57:         address _targetAsset,
58:         bytes memory _pathToLp
59:     ) {

/// @audit what
90:     function file(bytes32 what, address data) external auth { 

/// @audit what
107:     function file(bytes32 what, uint256 data) external auth { 

/// @audit newPathToLp
119:     function setPathToLp(bytes calldata newPathToLp) external auth { 

/// @audit path
297:     function quoteAddLiquidity(uint256 amt, address trgtAst, bytes memory path) private returns (uint256, uint256) { 

/// @audit path
338:     function swap(address trgtAst, address ast, bytes memory path, uint256 toLp, uint256 slp) private { 

390:     function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external returns (bytes4) { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit what
94:     function file(bytes32 what, address data) external auth { 

/// @audit what
115:     function file(bytes32 what, uint256 data) external auth { 

335:     function afterDepositExecution(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 

340:     function afterDepositCancellation(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 

345:     function afterWithdrawalExecution(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 

353:     function afterWithdrawalCancellation(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit what
52:     function file(bytes32 what, address data) external auth { 

/// @audit what
63:     function file(bytes32 what, uint256 data) external auth { 
```


```solidity
📁 File: Whitelist.sol

/// @audit what
23:     function file(bytes32 what, address data) external auth { 
```


</details>


---
### [NC&#x2011;34] Empty function body
Empty function body in solidity is not recommended, consider adding some comments to the body.


<i>There are 2 instaces of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

80:     receive() external payable {} 

292:     function move(address old) external auth {} 
```



---
### [NC&#x2011;35] Enum values should be used instead of constant array indexes
Create a commented enum value to use instead of constant array indexes, this makes the code far easier to understand.

<details>
<summary><i>There are 15 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @audit 0
64:             address a = assets[0]; 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit 0
202:         assets[0] = address(hypervisor); 

/// @audit 0
348:         secondsAgos[0] = period; 
/// @audit 1
349:         secondsAgos[1] = 0;

/// @audit 1
/// @audit 0
352:         uint160 midX96 = TickMath.getSqrtRatioAtTick(int24((tickCumulatives[1] - tickCumulatives[0]) / int32(period))); 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit 0
180:         assets[0] = tokenShort; 

/// @audit 0
235:             data[0] = abi.encodeWithSelector(IExchangeRouter.sendWnt.selector, vault, params.executionFee); 
/// @audit 1
236:             data[1] = abi.encodeWithSelector(IExchangeRouter.sendTokens.selector, marketInfo.longToken, vault, out);
/// @audit 2
237:             data[2] =

/// @audit 3
239:             data[3] = abi.encodeWithSelector(IExchangeRouter.createDeposit.selector, params); 

/// @audit 0
273:             data[0] = abi.encodeWithSelector(IExchangeRouter.sendWnt.selector, withdrawalVault, params.executionFee); 
/// @audit 1
274:             data[1] = abi.encodeWithSelector(IExchangeRouter.sendTokens.selector, market, withdrawalVault, amt);
/// @audit 2
275:             data[2] = abi.encodeWithSelector(IExchangeRouter.createWithdrawal.selector, params);
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit 0
149:         assets[0] = address(pool); 
```


</details>


---
### [NC&#x2011;36] Error messages should be descriptive rather than cryptic
<details>
<summary><i>There are 12 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @note Confidence: 81.82%
55:         require(msg.sender == address(lender), "!lender"); 
/// @note Confidence: 100.00%
56:         require(initiator == address(this), "!me");
```


```solidity
📁 File: PositionManager.sol

/// @note Confidence: 54.55%
115:         require((owner = _ownerOf[id]) != address(0), "NOT_MINTED"); 

/// @note Confidence: 36.36%
119:         require(owner != address(0), "ZERO_ADDRESS"); 

/// @note Confidence: 18.18%
136:         require( 
137:             msg.sender == owner || isApprovedForAll[owner][msg.sender] || msg.sender == getApproved[id],
138:             "NOT_AUTHORIZED"
139:         );

/// @note Confidence: 18.18%
145:         require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED"); 

/// @note Confidence: 54.55%
183:         require(from == _ownerOf[id], "WRONG_FROM"); 

/// @note Confidence: 18.18%
222:         require(_ownerOf[id] == address(0), "ALREADY_MINTED"); 

/// @note Confidence: 54.55%
246:         require(p.collateral == 0, "NOT_CLOSED"); 

/// @note Confidence: 54.55%
248:         require(owner != address(0), "NOT_MINTED"); 

/// @note Confidence: 54.55%
254:         require(owner != address(0), "NOT_MINTED"); 
```


```solidity
📁 File: StrategySushiswap.sol

/// @note Confidence: 100.00%
187:         require(totalShares == 0, "ts=0"); 
```


</details>


---
### [NC&#x2011;37] Event is missing `indexed` fields
Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.

<details>
<summary><i>There are 32 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

11:     event File(bytes32 indexed what, address data); 
```


```solidity
📁 File: Investor.sol

100:     event File(bytes32 indexed what, uint256 data); 
101:     event File(bytes32 indexed what, address data);
102:     event Open(uint256 indexed id, uint256 borrow, uint256 collateral, uint256 strategy, address token);
103:     event Edit(uint256 indexed id, int256 borrow, int256 collateral);
104:     event Kill(uint256 indexed id, uint256 borrow, uint256 value, uint256 collateral, uint256 shares, uint256 fee);
105:     event StrategyUpdate(uint256 indexed index, address implementation, uint256 status, uint256 cap);
106:     event CollateralUpdate(address indexed token, uint256 factor, uint256 cap);
```


```solidity
📁 File: InvestorStrategyProxy.sol

19:     event File(bytes32 indexed what, address data); 
```


```solidity
📁 File: PositionManager.sol

78:     event ApprovalForAll(address indexed owner, address indexed operator, bool approved); 
79:     event File(bytes32 indexed what, address data);
```


```solidity
📁 File: Store.sol

20:     event File(bytes32 indexed what, address data); 
```


```solidity
📁 File: StrategyCamelotV3.sol

32:     event File(bytes32 indexed what, uint256 data); 
33:     event File(bytes32 indexed what, address data);
34:     event Mint(uint256 amount, uint256 shares);
35:     event Burn(uint256 amount, uint256 shares);
36:     event Kill(uint256 amount, uint256 shares);
37:     event Earn(uint256 tvl, uint256 profit);
```


```solidity
📁 File: StrategyGMXGM.sol

31:     event File(bytes32 indexed what, uint256 data); 
32:     event File(bytes32 indexed what, address data);
33:     event Mint(uint256 amount, uint256 shares);
34:     event Burn(uint256 amount, uint256 shares);
35:     event Kill(uint256 amount, uint256 shares);
36:     event Earn(uint256 tvl, uint256 profit);
```


```solidity
📁 File: StrategySushiswap.sol

17:     event File(bytes32 indexed what, uint256 data); 
18:     event File(bytes32 indexed what, address data);
19:     event Mint(uint256 amount, uint256 shares);
20:     event Burn(uint256 amount, uint256 shares);
21:     event Kill(uint256 amount, uint256 shares);
22:     event Earn(uint256 tvl, uint256 profit);
```


```solidity
📁 File: Whitelist.sol

8:     event File(bytes32 indexed what, address data); 
9:     event BatchWhitelist(address[] addresses, bool status);
```


</details>


---
### [NC&#x2011;38] Events are missing sender information
When an action is triggered based on a user's action, not being able to filter based on who triggered the action makes event processing a lot more cumbersome. Including the msg.sender the events of these types of action will make events much more useful to end users, especially when `msg.sender` is not `tx.origin`.

<details>
<summary><i>There are 13 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

216:         emit StrategyUpdate(index, implementation, 4, 0); 

224:         emit StrategyUpdate(index, implementation, s.status, s.cap); 

230:         emit StrategyUpdate(index, s.implementation, status, s.cap); 

236:         emit StrategyUpdate(index, s.implementation, s.status, cap); 

242:         emit CollateralUpdate(token, factor, cap); 

248:         emit CollateralUpdate(token, factor, cap); 
```


```solidity
📁 File: PositionManager.sol

179:         emit Transfer(from, to, id); 
```


```solidity
📁 File: StrategyCamelotV3.sol

166:         emit Mint(amount, shares); 

189:         emit Burn(bal, shares); 
```


```solidity
📁 File: StrategyGMXGM.sol

155:         emit Mint(amount, shares); 

167:         emit Burn(bal, shares); 
```


```solidity
📁 File: StrategySushiswap.sol

113:         emit Mint(amount, shares); 

137:         emit Burn(amount, shares); 
```


</details>


---
### [NC&#x2011;39] Events should be emitted before external calls
Ensure that events follow the best practice of check-effects-interaction, and are emitted before external calls.

<details>
<summary><i>There are 21 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

/// @audit asset() on line 181
185:         emit File(what, data); 

/// @audit setUint() on line 203
207:         emit File(what, data); 

/// @audit setUint() on line 215
216:         emit StrategyUpdate(index, implementation, 4, 0); 

/// @audit setAddress() on line 223
224:         emit StrategyUpdate(index, implementation, s.status, s.cap); 

/// @audit setUint() on line 229
230:         emit StrategyUpdate(index, s.implementation, status, s.cap); 

/// @audit setUint() on line 235
236:         emit StrategyUpdate(index, s.implementation, s.status, cap); 

/// @audit setUint() on line 241
242:         emit CollateralUpdate(token, factor, cap); 

/// @audit setUint() on line 247
248:         emit CollateralUpdate(token, factor, cap); 

/// @audit rate() on line 289
291:         emit Open(id, borrow, collateral, strategy, token); 

/// @audit rate() on line 383
385:         emit Edit(id, borrow, collateralAdjusted); 

/// @audit kill() on line 434
442:         emit Kill(id, borrow, amount, collat, shares, fee); 
```


```solidity
📁 File: PositionManager.sol

/// @audit push() on line 173
179:         emit Transfer(from, to, id); 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit withdrawalVault() on line 108
112:         emit File(what, data); 

/// @audit value() on line 151
155:         emit Mint(amount, shares); 

/// @audit swap() on line 164
167:         emit Burn(bal, shares); 

/// @audit transfer() on line 174
177:         emit Kill(amount, shares); 

/// @audit multicall() on line 276
280:         emit Earn(current, current - min(current, before)); 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit deposit() on line 109
113:         emit Mint(amount, shares); 

/// @audit swap() on line 133
137:         emit Burn(amount, shares); 

/// @audit withdraw() on line 143
146:         emit Kill(amount, shares); 

/// @audit deposit() on line 172
174:         emit Earn(current, current - min(current, before)); 
```


</details>


---
### [NC&#x2011;40] Expressions for `constant` values should use `immutable` rather than constant
While it does not save gas for some simple binary expressions because the compiler knows that developers often make this mistake, it's still best to use the right tool for the task at hand. There is a difference between `constant` variables and `immutable` variables, and they should each be used in their appropriate contexts. `constants` should be used for literal values written into the code, and `immutable` variables should be used for expressions, or values calculated in, or passed into the constructor.

<details>
<summary><i>There are 19 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

82:     bytes32 constant STATUS = keccak256(abi.encode("STATUS")); 
83:     bytes32 constant BANK = keccak256(abi.encode("BANK"));
84:     bytes32 constant POOL = keccak256(abi.encode("POOL"));
85:     bytes32 constant STRATEGIES_ADDRESS = keccak256(abi.encode("STRATEGIES_ADDRESS"));
86:     bytes32 constant STRATEGIES_CAP = keccak256(abi.encode("STRATEGIES_CAP"));
87:     bytes32 constant STRATEGIES_STATUS = keccak256(abi.encode("STRATEGIES_STATUS"));
88:     bytes32 constant COLLATERAL_FACTOR = keccak256(abi.encode("COLLATERAL_FACTOR"));
89:     bytes32 constant COLLATERAL_CAP = keccak256(abi.encode("COLLATERAL_CAP"));
90:     bytes32 constant POSITIONS = keccak256(abi.encode("POSITIONS"));
91:     bytes32 constant POSITIONS_OWNER = keccak256(abi.encode("POSITIONS_OWNER"));
92:     bytes32 constant POSITIONS_START = keccak256(abi.encode("POSITIONS_START"));
93:     bytes32 constant POSITIONS_STRATEGY = keccak256(abi.encode("POSITIONS_STRATEGY"));
94:     bytes32 constant POSITIONS_TOKEN = keccak256(abi.encode("POSITIONS_TOKEN"));
95:     bytes32 constant POSITIONS_COLLATERAL = keccak256(abi.encode("POSITIONS_COLLATERAL"));
96:     bytes32 constant POSITIONS_BASIS = keccak256(abi.encode("POSITIONS_BASIS"));
97:     bytes32 constant POSITIONS_SHARES = keccak256(abi.encode("POSITIONS_SHARES"));
98:     bytes32 constant POSITIONS_BORROW = keccak256(abi.encode("POSITIONS_BORROW"));
```


```solidity
📁 File: StrategyGMXGM.sol

322:     bytes32 constant MAX_PNL_FACTOR_FOR_DEPOSITS = keccak256(abi.encode("MAX_PNL_FACTOR_FOR_DEPOSITS")); 
323:     bytes32 constant MAX_PNL_FACTOR_FOR_WITHDRAWALS = keccak256(abi.encode("MAX_PNL_FACTOR_FOR_WITHDRAWALS"));
```


</details>


---
### [NC&#x2011;41] For loops in `public` or `external` functions should be avoided due to high gas costs and possible DOS
In Solidity, for loops can potentially cause Denial of Service (DoS) attacks if not handled carefully. DoS attacks can occur when an attacker intentionally exploits the gas cost of a function, causing it to run out of gas or making it too expensive for other users to call. Below are some scenarios where for loops can lead to DoS attacks: Nested for loops can become exceptionally gas expensive and should be used sparingly.

<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

/// @audit line 129
127:     function tokensOfOwner(address owner, uint256 start, uint256 end) external view returns (uint256[] memory v) { 
128:         v = new uint256[](end-start);
129:         for (uint256 i = start; i < end; i++) {
130:             v[i - start] = _ownerIds[owner].values[i];
131:         }
132:     }
```


```solidity
📁 File: Store.sol

/// @audit line 136
134:     function getBytes32ValuesAt(bytes32 key, uint256 start, uint256 end) external view returns (bytes32[] memory v) { 
135:         v = new bytes32[](end-start);
136:         for (uint256 i = start; i < end; i++) {
137:             v[i - start] = bytes32Sets[key].values[i];
138:         }
139:     }
```


```solidity
📁 File: UtilFarmingBalances.sol

/// @audit line 20
14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) { 
15:         IInvestor i = IInvestor(0x8accf43Dd31DfCd4919cc7d65912A475BfA60369);
16:         IPositionManager pm = IPositionManager(0x5e4d7F61cC608485A2E4F105713D26D58a9D0cF6);
17:         uint256 max = i.nextPosition();
18:         address[] memory users = new address[](max-start);
19:         uint256[] memory balances = new uint256[](max-start);
20:         for (uint256 y = start; y < max; y++) {
21:             (,,,,,uint256 value,) = i.positions(y);
22:             (bool ok, bytes memory data) = address(pm).staticcall(abi.encodeWithSelector(IPositionManager.ownerOf.selector, y));
23:             if (ok) {
24:               users[y-start] = abi.decode(data, (address));
25:               balances[y-start] = value;
26:             }
27:         }
28:         return (users, balances);
29:     }
```


```solidity
📁 File: Whitelist.sol

/// @audit line 36
34:     function batchWhitelist(address[] memory addresses, bool status) external auth { 
35:         uint256 l = addresses.length;
36:         for (uint256 i = 0; i < l; i++) {
37:             whitelist[addresses[i]] = status;
38:         }
39:         emit BatchWhitelist(addresses, status);
40:     }
```


</details>


---
### [NC&#x2011;42] Function can be declared as `pure`
Functions below do not interact with the state of the contract and can be declared as `pure`. It will save gas and make the code more readable.


<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

292:     function move(address old) external auth {} 
```



---
### [NC&#x2011;43] Function can be declared as `view`
Functions below do not change the state of the contract and can be declared as `view`. It will save gas and make the code more readable.

<details>
<summary><i>There are 8 instances of this issue:</i></summary>

```solidity
📁 File: Store.sol

59:     function removeUint(bytes32 key) external auth { 

74:     function removeInt(bytes32 key) external auth { 

84:     function removeAddress(bytes32 key) external auth { 

94:     function removeBool(bytes32 key) external auth { 

104:     function removeString(bytes32 key) external auth { 

114:     function removeBytes32(bytes32 key) external auth { 

124:     function removeBytes32Array(bytes32 key) external auth { 
```


```solidity
📁 File: StrategySushiswap.sol

182:     function exit(address strategy) public auth { 
```


</details>


---
### [NC&#x2011;44] Function ordering in the contract does not follow the Solidity style guide
Source: [https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-layout](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-layout)

<details>
<summary><i>There are 155 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

26:     function file(bytes32 what, address data) external auth { 

35:     function transferNative(address to, uint256 amount) external auth { 

41:     function transfer(address token, address to, uint256 amount) external auth { 
```


```solidity
📁 File: Helper.sol

6:     function approve(address, uint256) external; 
7:     function transfer(address, uint256) external;

26:     function burn(address) external; 

43:     function kill(uint256 id) external { 

48:     function executeOperation( 
```


```solidity
📁 File: Investor.sol

7:     function approve(address, uint256) external; 
8:     function transfer(address, uint256) external returns (bool);
9:     function transferFrom(address, address, uint256) external returns (bool);

21:     function setUint(bytes32, uint256) external; 
22:     function setUintDelta(bytes32, int256) external returns (uint256);
23:     function setAddress(bytes32, address) external returns (address);

28:     function transfer(address, address, uint256) external; 

36:     function borrow(uint256) external returns (uint256); 
37:     function repay(uint256) external returns (uint256);

44:     function swap(address, address, uint256, uint256, address) external returns (uint256); 

50:     function exit(address) external; 
51:     function move(address) external;

56:     function mint(address, uint256) external returns (uint256); 
57:     function burn(address, uint256) external returns (uint256);
58:     function kill(address, uint256, address) external returns (bytes memory);

162:     function file(bytes32 what, address data) external auth { 

188:     function file(bytes32 what, uint256 data) external auth { 

210:     function strategyNew(uint256 index, address implementation) external auth { 

219:     function strategyUgrade(uint256 index, address implementation) external auth { 

227:     function strategySetStatus(uint256 index, uint256 status) external auth { 

233:     function strategySetCap(uint256 index, uint256 cap) external auth { 

239:     function collateralSetFactor(address token, uint256 factor) external auth { 

245:     function collateralSetCap(address token, uint256 cap) external auth { 

251:     function collect(address token) external auth { 

255:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external loop returns (uint256) { 

295:     function edit(uint256 id, int256 borrow, int256 collateral) external loop { 

388:     function killRepayment(uint256 id) external view returns (uint256) { 

396:     function kill(uint256 id) external loop returns (address, bytes memory) { 

446:     function life(uint256 id) external view returns (uint256) { 

466:     function getPosition(uint256 id) public view returns (Position memory p) { 

477:     function setPosition(uint256 id, Position memory p) internal { 

488:     function getStrategy(uint256 id) public view returns (Strategy memory s) { 

495:     function getPool() public view returns (address) { 

499:     function push(address asset, address user, uint256 amount) internal { 

506:     function pullToBank(address asset, address user, uint256 amount) internal { 
```


```solidity
📁 File: PositionManager.sol

10:     function approve(address, uint256) external returns (bool); 
11:     function transfer(address, uint256) external returns (bool);
12:     function transferFrom(address, address, uint256) external returns (bool);

51:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external returns (uint256); 
52:     function edit(uint256 id, int256 borrow, int256 collateral) external;

101:     function file(bytes32 what, address data) external admin { 

123:     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) { 

127:     function tokensOfOwner(address owner, uint256 start, uint256 end) external view returns (uint256[] memory v) { 

143:     function approve(address spender, uint256 id) public { 

150:     function setApprovalForAll(address operator, bool approved) public { 

182:     function transferFrom(address from, address to, uint256 id) public auth(id) { 

188:     function safeTransferFrom(address from, address to, uint256 id) public { 

198:     function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public { 

208:     function supportsInterface(bytes4 interfaceId) public pure returns (bool) { 

214:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow, address to) public returns (uint256) { 

233:     function edit(uint256 id, int256 borrow, int256 collateral) public auth(id) { 

244:     function burn(uint256 id) public auth(id) { 

252:     function forceBurn(uint256 id) public auth(id) { 

272:     function tokenURI(uint256 id) public view returns (string memory) { 

374:     function formatNumber(uint256 n, uint256 d, uint256 f) internal pure returns (string memory) { 
```


```solidity
📁 File: Store.sol

35:     function file(bytes32 what, address data) external auth { 

44:     function getUint(bytes32 key) external view returns (uint256) { 

47:     function setUint(bytes32 key, uint256 value) external auth returns (uint256) { 

51:     function setUintDelta(bytes32 key, int256 value) external auth returns (uint256) { 

59:     function removeUint(bytes32 key) external auth { 

62:     function getInt(bytes32 key) external view returns (int256) { 

65:     function setInt(bytes32 key, int256 value) external auth returns (int256) { 

69:     function setIntDelta(bytes32 key, int256 value) external auth returns (int256) { 

74:     function removeInt(bytes32 key) external auth { 

77:     function getAddress(bytes32 key) external view returns (address) { 

80:     function setAddress(bytes32 key, address value) external auth returns (address) { 

84:     function removeAddress(bytes32 key) external auth { 

87:     function getBool(bytes32 key) external view returns (bool) { 

90:     function setBool(bytes32 key, bool value) external auth returns (bool) { 

94:     function removeBool(bytes32 key) external auth { 

97:     function getString(bytes32 key) external view returns (string memory) { 

100:     function setString(bytes32 key, string memory value) external auth returns (string memory) { 

104:     function removeString(bytes32 key) external auth { 

107:     function getBytes32(bytes32 key) external view returns (bytes32) { 

110:     function setBytes32(bytes32 key, bytes32 value) external auth returns (bytes32) { 

114:     function removeBytes32(bytes32 key) external auth { 

118:     function getBytes32Array(bytes32 key) external view returns (bytes32[] memory) { 

121:     function setBytes32Array(bytes32 key, bytes32[] memory value) external auth { 

124:     function removeBytes32Array(bytes32 key) external auth { 

128:     function containsBytes32(bytes32 key, bytes32 value) external view returns (bool) { 

131:     function getBytes32Count(bytes32 key) external view returns (uint256) { 

134:     function getBytes32ValuesAt(bytes32 key, uint256 start, uint256 end) external view returns (bytes32[] memory v) { 

140:     function addBytes32(bytes32 key, bytes32 value) external auth { 

147:     function removeBytes32(bytes32 key, bytes32 value) external auth { 
```


```solidity
📁 File: StrategyCamelotV3.sol

90:     function file(bytes32 what, address data) external auth { 

107:     function file(bytes32 what, uint256 data) external auth { 

119:     function setPathToLp(bytes calldata newPathToLp) external auth { 

123:     function setNitroPool(address _nitroPool) external auth { 

133:     function xgrailRedeem(uint256 amount, uint256 duration) external auth { 

137:     function xgrailFinalizeRedeem(uint256 index) external auth { 

141:     function mint(uint256 amount) external auth loop returns (uint256) { 

170:     function burn(uint256 shares) external auth loop returns (uint256) { 

193:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

228:     function earn() external payable loop { 

276:     function exit(address strategy) external auth { 

284:     function move(address old) external auth { 

293:     function rate(uint256 shares) public view returns (uint256) { 

390:     function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external returns (bytes4) { 

397:     function onNFTHarvest(address, address, uint256, uint256, uint256) public pure returns (bool) { 

401:     function onNFTAddToPosition(address, uint256, uint256) public pure returns (bool) { 

405:     function onNFTWithdraw(address, uint256, uint256) public pure returns (bool) { 

409:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

417:     function approve(address, uint256) external; 
418:     function transfer(address, uint256) external;
419:     function transferFrom(address, address, uint256) external;

425:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256); 
```


```solidity
📁 File: StrategyGMXGM.sol

80:     receive() external payable {} 

94:     function file(bytes32 what, address data) external auth { 

115:     function file(bytes32 what, uint256 data) external auth { 

133:     function withdrawEth() external auth { 

138:     function withdrawAirdrop(address token) external auth { 

143:     function mint(uint256 amount) external auth loop returns (uint256) { 

159:     function burn(uint256 shares) external auth loop returns (uint256) { 

171:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

184:     function earn() external payable loop { 

283:     function exit(address strategy) external auth { 

292:     function move(address old) external auth {} 

335:     function afterDepositExecution(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 

340:     function afterDepositCancellation(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 

345:     function afterWithdrawalExecution(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 

353:     function afterWithdrawalCancellation(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 

367:     function approve(address, uint256) external; 
368:     function transfer(address, uint256) external;
369:     function transferFrom(address, address, uint256) external;

375:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256); 
```


```solidity
📁 File: StrategySushiswap.sol

52:     function file(bytes32 what, address data) external auth { 

63:     function file(bytes32 what, uint256 data) external auth { 

90:     function mint(uint256 amount) public auth loop returns (uint256) {  

117:     function burn(uint256 shares) public auth loop returns (uint256) { 

141:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

153:     function earn() public payable loop { 

182:     function exit(address strategy) public auth { 

186:     function move(address old) public auth { 

257:     function approve(address, uint256) external returns (bool); 
258:     function transfer(address, uint256) external returns (bool);
259:     function transferFrom(address, address, uint256) external returns (bool);

265:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256); 

275:     function mint(address) external returns (uint256 liquidity); 
276:     function burn(address) external returns (uint256 amount0, uint256 amount1);
277:     function swap(uint256, uint256, address, bytes calldata) external;
278:     function skim(address to) external;

286:     function deposit(uint256, uint256, address) external; 
287:     function withdraw(uint256, uint256, address) external;
288:     function harvest(uint256, address) external;
```


```solidity
📁 File: Whitelist.sol

23:     function file(bytes32 what, address data) external auth { 

34:     function batchWhitelist(address[] memory addresses, bool status) external auth { 

42:     function check(address user) external view returns (bool) { 
```


</details>


---
### [NC&#x2011;45] Functions contain the same code
The functions below have the same implementation as is seen in other files. The functions should be refactored into functions of a common base contract.

<details>
<summary><i>There are 5 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

26:     function file(bytes32 what, address data) external auth { 
27:         if (what == "exec") {
28:             exec[data] = !exec[data];
29:         } else {
30:             revert InvalidFile();
31:         }
32:         emit File(what, data);
33:     }
```


```solidity
📁 File: InvestorStrategyProxy.sol

34:     function file(bytes32 what, address data) public auth { 
35:         if (what == "exec") {
36:           exec[data] = !exec[data];
37:         } else {
38:             revert InvalidFile();
39:         }
40:         emit File(what, data);
41:     }
```


```solidity
📁 File: Store.sol

35:     function file(bytes32 what, address data) external auth { 
36:         if (what == "exec") {
37:             exec[data] = !exec[data];
38:         } else {
39:             revert InvalidFile();
40:         }
41:         emit File(what, data);
42:     }
```


```solidity
📁 File: StrategyGMXGM.sol

335:     function afterDepositExecution(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 
336:         if (msg.sender != depositHandler) revert NotGMX();
337:         amountPendingDeposit = 0;
338:     }

340:     function afterDepositCancellation(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 
341:         if (msg.sender != depositHandler) revert NotGMX();
342:         amountPendingDeposit = 0;
343:     }
```


</details>


---
### [NC&#x2011;46] Functions not used internally could be marked external
Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.

<details>
<summary><i>There are 26 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

495:     function getPool() public view returns (address) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

34:     function file(bytes32 what, address data) public auth { 

43:     function mint(address strategy, uint256 amount) public auth returns (uint256) { 

48:     function burn(address strategy, uint256 shares) public auth returns (uint256) { 

54:     function kill(address strategy, uint256 shares, address target) public auth returns (bytes memory) { 

58:     function call(address strategy, uint256 value, bytes calldata data) public auth { 
```


```solidity
📁 File: PositionManager.sol

114:     function ownerOf(uint256 id) public view returns (address owner) { 

118:     function balanceOf(address owner) public view returns (uint256) { 

143:     function approve(address spender, uint256 id) public { 

150:     function setApprovalForAll(address operator, bool approved) public { 

188:     function safeTransferFrom(address from, address to, uint256 id) public { 

198:     function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public { 

208:     function supportsInterface(bytes4 interfaceId) public pure returns (bool) { 

214:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow, address to) public returns (uint256) { 

233:     function edit(uint256 id, int256 borrow, int256 collateral) public auth(id) { 

244:     function burn(uint256 id) public auth(id) { 

252:     function forceBurn(uint256 id) public auth(id) { 

272:     function tokenURI(uint256 id) public view returns (string memory) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

397:     function onNFTHarvest(address, address, uint256, uint256, uint256) public pure returns (bool) { 

401:     function onNFTAddToPosition(address, uint256, uint256) public pure returns (bool) { 

405:     function onNFTWithdraw(address, uint256, uint256) public pure returns (bool) { 
```


```solidity
📁 File: StrategySushiswap.sol

90:     function mint(uint256 amount) public auth loop returns (uint256) {  

117:     function burn(uint256 shares) public auth loop returns (uint256) { 

153:     function earn() public payable loop { 

182:     function exit(address strategy) public auth { 

186:     function move(address old) public auth { 
```


</details>


---
### [NC&#x2011;47] Functions should be named in mixedCase style
According to the Solidity [style guide](https://docs.soliditylang.org/en/latest/style-guide.html#function-names) function names should be in `mixedCase` (lowerCamelCase)Rule exceptions
- Allow `_` at the beginning of the mixedCase match for `private`/`internal` functions.


<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategySushiswap.sol

/// @audit SUSHI
282:     function SUSHI() external view returns (address); 
```



---
### [NC&#x2011;48] High cyclomatic complexity
Functions with high cyclomatic complexity are harder to understand, test, and maintain. Consider breaking down these blocks into more manageable units, by splitting things into utility functions, by reducing nesting, and by using early returns.

[Learn More About Cyclomatic Complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity)

<details>
<summary><i>There are 10 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

162:     function file(bytes32 what, address data) external auth { 

188:     function file(bytes32 what, uint256 data) external auth { 

295:     function edit(uint256 id, int256 borrow, int256 collateral) external loop { 
```


```solidity
📁 File: StrategyCamelotV3.sol

90:     function file(bytes32 what, address data) external auth { 

228:     function earn() external payable loop { 

297:     function quoteAddLiquidity(uint256 amt, address trgtAst, bytes memory path) private returns (uint256, uint256) { 
```


```solidity
📁 File: StrategyGMXGM.sol

94:     function file(bytes32 what, address data) external auth { 

115:     function file(bytes32 what, uint256 data) external auth { 

184:     function earn() external payable loop { 
```


```solidity
📁 File: StrategySushiswap.sol

216:     function log2(uint256 value) internal pure returns (uint256) { 
```


</details>


---
### [NC&#x2011;49] `if`-statement can be converted to a ternary
The code can be made more compact while also increasing readability by converting the following `if`-statements to ternaries (e.g. `foo += (x > y) ? a : b`)


<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyCamelotV3.sol

125:         if (_nitroPool == address(0)) { 
126:             nitroPool.withdraw(tokenId);
127:         } else {
128:             nftPool.safeTransferFrom(address(this), _nitroPool, tokenId, "");
129:         }
```



---
### [NC&#x2011;50] Imports could be organized more systematically
The contract's interface should be imported first, followed by each of the interfaces it uses, followed by all other files. The examples below do not follow this layout.


<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyCamelotV3.sol

2: pragma solidity 0.8.17; 
3: 
4: import {TickMath} from "./vendor/TickMath.sol";
5: import {LiquidityAmounts} from "./vendor/LiquidityAmounts.sol";
```



---
### [NC&#x2011;51] Incorrect withdraw declaration
Consider adding a return value to the `withdraw` function to indicate success or failure.
> ❗ Issue is removed from: (sme6en)


<i>There are 4 instaces of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

133:     function withdrawEth() external auth { 

138:     function withdrawAirdrop(address token) external auth { 

345:     function afterWithdrawalExecution(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 

353:     function afterWithdrawalCancellation(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 
```



---
### [NC&#x2011;52] Initialisms should be capitalized
According to the Solidity [style guide](https://docs.soliditylang.org/en/latest/style-guide.html#naming-styles) initialisms such as "NFT", "ERC", etc should be capitalized.

<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @audit-info sushi
63:         if (strategy == "sushi") { 
```


```solidity
📁 File: Investor.sol

/// @audit-info erc
122:     error Undercollateralized(); 
```


```solidity
📁 File: PositionManager.sol

/// @audit-info json
276:                 "data:application/json;base64,", 

/// @audit-info url
299:                 '<g clip-path="url(#corners)"><rect fill="url(#0)" x="0px" y="0px" width="290px" height="290px" /><rect fill="url(#1)" x="0px" y="0px" width="290px" height="290px" /><ellipse cx="50%" cy="32px" rx="220px" ry="120px" fill="rgba(255,255,255,0.2)" opacity="0.85" /><rect x="16" y="16" width="258" height="258" rx="26" ry="26" fill="rgba(0,0,0,0)" stroke="rgba(255,255,255,0.4)" />', 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit-info nft
24:     INFTPool public nftPool; 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit-info sushi
150:         return abi.encode(bytes32("sushi"), assets); 
```


</details>


---
### [NC&#x2011;53] Interfaces should be indicated with an I prefix in the contract name

<i>There is one instance of this issue:</i>

```solidity
📁 File: PositionManager.sol

59: interface ERC721TokenReceiver { 
```



---
### [NC&#x2011;54] Large multiples of ten should use scientific notation
Use a scientific notation rather than decimal literals (e.g. `1e6` instead of `1000000`), for better code readability.

<details>
<summary><i>There are 26 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @audit Use 2e2
34:     uint256 public slippage = 2500; 
```


```solidity
📁 File: Investor.sol

/// @audit Use 2e3
71:     uint256 public performanceFee = 2000; 

/// @audit Use 5e3
193:             if (data > 5000) revert InvalidFile(); 

/// @audit Use 1e4
/// @audit Use 1e4
345:                     cAmount = cAmount * (10000 + closeCollateralPadding) / 10000; 

/// @audit Use 1e4
/// @audit Use 1e4
357:             push(poolAsset, msg.sender, (amount - used) * (10000 - performanceFee) / 10000); 

/// @audit Use 1e4
392:         uint256 fee = borrow * killCollateralPadding / 10000 / 2; 

/// @audit Use 1e4
409:         uint256 fee = borrow * killCollateralPadding / 10000 / 2; 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit Use 4e2
27:     uint32 public twapPeriod = 43200; 

/// @audit Use 1e4
/// @audit Use 1e4
162:         if (val < strategyHelper.value(address(asset), amount) * (10000 - slp) / 10000) revert PriceSlipped(); 

/// @audit Use 1e4
/// @audit Use 1e4
186:         if (strategyHelper.value(address(asset), bal) < val * (10000 - slp) / 10000) revert PriceSlipped(); 

/// @audit Use 1e4
/// @audit Use 1e4
339:         uint256 minOut = strategyHelper.convert(trgtAst, ast, toLp) * (10000 - slp) / 10000; 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit Use 1e3
27:     uint256 public reserveRatio = 1000; // 10% 

/// @audit Use 5e5
29:     uint256 public callbackGasLimit = 500_000; 

/// @audit Use 1e4
121:             if (data > 10000) revert WrongReserveRatio(); 

/// @audit Use 1e4
201:         uint256 need = rate(totalShares) * reserveRatio / 10000; 

/// @audit Use 1e4
/// @audit Use 1e4
210:             minOut = minOut * (10000 - slp) / 10000; 

/// @audit Use 1e4
/// @audit Use 1e4
263:                 minLongTokenAmount: longOut * (10000 - slp) / 10000, 
/// @audit Use 1e4
/// @audit Use 1e4
264:                 minShortTokenAmount: shortOut * (10000 - slp) / 10000,
```


</details>


---
### [NC&#x2011;55] Large numeric literals should use underscores for readability
<details>
<summary><i>There are 25 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

34:     uint256 public slippage = 2500; 
```


```solidity
📁 File: Investor.sol

71:     uint256 public performanceFee = 2000; 

193:             if (data > 5000) revert InvalidFile(); 

345:                     cAmount = cAmount * (10000 + closeCollateralPadding) / 10000; 

357:             push(poolAsset, msg.sender, (amount - used) * (10000 - performanceFee) / 10000); 

392:         uint256 fee = borrow * killCollateralPadding / 10000 / 2; 

409:         uint256 fee = borrow * killCollateralPadding / 10000 / 2; 
```


```solidity
📁 File: StrategyCamelotV3.sol

27:     uint32 public twapPeriod = 43200; 

162:         if (val < strategyHelper.value(address(asset), amount) * (10000 - slp) / 10000) revert PriceSlipped(); 

186:         if (strategyHelper.value(address(asset), bal) < val * (10000 - slp) / 10000) revert PriceSlipped(); 

339:         uint256 minOut = strategyHelper.convert(trgtAst, ast, toLp) * (10000 - slp) / 10000; 
```


```solidity
📁 File: StrategyGMXGM.sol

27:     uint256 public reserveRatio = 1000; // 10% 

121:             if (data > 10000) revert WrongReserveRatio(); 

201:         uint256 need = rate(totalShares) * reserveRatio / 10000; 

210:             minOut = minOut * (10000 - slp) / 10000; 

263:                 minLongTokenAmount: longOut * (10000 - slp) / 10000, 
264:                 minShortTokenAmount: shortOut * (10000 - slp) / 10000,
```


</details>


---
### [NC&#x2011;56] Large or complicated code bases should implement invariant tests
Large code bases, or code with lots of inline-assembly, complicated math, or complicated interactions between multiple contracts, should implement [invariant fuzzing tests](https://medium.com/coinmonks/smart-contract-fuzzing-d9b88e0b0a05). Invariant fuzzers such as Echidna require the test writer to come up with invariants which should not be violated under any circumstances, and the fuzzer tests various inputs and function calls to ensure that the invariants always hold. Even code with 100% code coverage can still have bugs due to the order of the operations a user performs, and invariant fuzzers, with properly and extensively-written invariants, can close this testing gap significantly.


---
### [NC&#x2011;57] Layout order does not comply with best practices
This is a [best practice](https://docs.soliditylang.org/en/latest/style-guide.html#order-of-layout) that should be followed.

Inside each contract, library or interface, use the following order:

1. Type declarations
2. State variables
3. Events
4. Errors
5. Modifiers
6. Functions

<details>
<summary><i>There are 60 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit modifier definition `auth` after function definition
8: contract Bank { 
```


```solidity
📁 File: Investor.sol

/// @audit struct declaration `Strategy` after error definition
/// @audit variable declaration `implementation` after error definition
/// @audit variable declaration `cap` after error definition
/// @audit variable declaration `status` after error definition
/// @audit struct declaration `Position` after error definition
/// @audit variable declaration `owner` after error definition
/// @audit variable declaration `start` after error definition
/// @audit variable declaration `strategy` after error definition
/// @audit variable declaration `token` after error definition
/// @audit variable declaration `collateral` after error definition
/// @audit variable declaration `borrow` after error definition
/// @audit variable declaration `shares` after error definition
/// @audit variable declaration `basis` after error definition
/// @audit modifier definition `auth` after function definition
/// @audit modifier definition `loop` after function definition
65: contract Investor { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit modifier definition `auth` after function definition
15: contract InvestorStrategyProxy { 
```


```solidity
📁 File: PositionManager.sol

/// @audit struct declaration `Position` after variable declaration
31: interface IInvestor { 

/// @audit struct declaration `Ids` after error definition
/// @audit variable declaration `values` after error definition
/// @audit variable declaration `positions` after error definition
/// @audit modifier definition `admin` after function definition
/// @audit modifier definition `auth` after function definition
64: contract PositionManager { 
```


```solidity
📁 File: Store.sol

/// @audit modifier definition `auth` after function definition
4: contract Store { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit modifier definition `loop` after function definition
/// @audit modifier definition `auth` after function definition
7: contract StrategyCamelotV3 { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit modifier definition `loop` after function definition
/// @audit modifier definition `auth` after function definition
4: contract StrategyGMXGM { 

/// @audit struct declaration `CreateWithdrawalParams` after variable declaration
399: interface IExchangeRouter { 

/// @audit struct declaration `Props` after variable declaration
437: interface IMarket { 

/// @audit struct declaration `Addresses` after variable declaration
/// @audit struct declaration `Numbers` after variable declaration
/// @audit struct declaration `Flags` after variable declaration
497: interface IDeposit { 

/// @audit struct declaration `Addresses` after variable declaration
/// @audit struct declaration `Numbers` after variable declaration
/// @audit struct declaration `Flags` after variable declaration
530: interface IWithdrawal { 

/// @audit struct declaration `AddressItems` after variable declaration
/// @audit struct declaration `UintItems` after variable declaration
/// @audit struct declaration `IntItems` after variable declaration
/// @audit struct declaration `BoolItems` after variable declaration
/// @audit struct declaration `Bytes32Items` after variable declaration
/// @audit struct declaration `BytesItems` after variable declaration
/// @audit struct declaration `StringItems` after variable declaration
/// @audit struct declaration `AddressKeyValue` after variable declaration
/// @audit struct declaration `AddressArrayKeyValue` after variable declaration
/// @audit struct declaration `UintKeyValue` after variable declaration
/// @audit struct declaration `UintArrayKeyValue` after variable declaration
/// @audit struct declaration `IntKeyValue` after variable declaration
/// @audit struct declaration `IntArrayKeyValue` after variable declaration
/// @audit struct declaration `BoolKeyValue` after variable declaration
/// @audit struct declaration `BoolArrayKeyValue` after variable declaration
/// @audit struct declaration `Bytes32KeyValue` after variable declaration
/// @audit struct declaration `Bytes32ArrayKeyValue` after variable declaration
/// @audit struct declaration `BytesKeyValue` after variable declaration
/// @audit struct declaration `BytesArrayKeyValue` after variable declaration
/// @audit struct declaration `StringKeyValue` after variable declaration
/// @audit struct declaration `StringArrayKeyValue` after variable declaration
561: interface IEventUtils { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit modifier definition `loop` after function definition
/// @audit modifier definition `auth` after function definition
4: contract StrategySushiswap { 
```


```solidity
📁 File: Whitelist.sol

/// @audit modifier definition `auth` after function definition
4: contract Whitelist { 
```


</details>


---
### [NC&#x2011;58] Lines are too long
Usually lines in source code are limited to 80 characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over 164 characters, the lines below should be split when they reach that length Reference: https://docs.soliditylang.org/en/v0.8.10/style-guide.html#maximum-line-length

<details>
<summary><i>There are 20 instances of this issue:</i></summary>

```solidity
📁 File: Deploy.s.sol

/// @audit 195 chars long
48:         address(0x08aa7480824f5B953A997d62a545382fE6071981).call(abi.encodeWithSignature("setMerkleRoot(uint256,bytes32)", 8, 0xa90ea1e0dd2c1ee7ad5cebb6866902002c8e69b6342e20607fc051e091a8f59e)); 

/// @audit 192 chars long
62:         multisig.add(0x49D6628C87F2f0E6A17edfD7E9DA95ED95a7d1B2, 0, abi.encodeWithSignature("setReserveRatio(uint256)", 8, 0xa90ea1e0dd2c1ee7ad5cebb6866902002c8e69b6342e20607fc051e091a8f59e)); 

/// @audit 142 chars long
185:             StrategySushiswap sSushiSwapEthUsdc = new StrategySushiswap(usdce, strategyHelper, 0xF4d73326C13a4Fc5FD7A064217e12780e9Bd62c3, 0); 

/// @audit 151 chars long
219:             if (salariesUsdc[i] > 0) multisig.add(usdce, 0, abi.encodeWithSignature("transfer(address,uint256)", salariesAddress[i], salariesUsdc[i])); 
/// @audit 157 chars long
220:             if (salariesRdo[i] > 0) multisig.add(rdo, 0, abi.encodeWithSignature("transfer(address,uint256)", salariesAddress[i], salariesRdo[i]*1e18/rdop));
/// @audit 156 chars long
221:             if (salariesXrdo[i] > 0) multisig.add(xrdo, 0, abi.encodeWithSignature("mint(uint256,address)", salariesXrdo[i]*1e18/rdop, salariesAddress[i]));
```


```solidity
📁 File: Helper.sol

/// @audit 127 chars long
16:     function flashLoanSimple(address receiver, address asset, uint256 amount, bytes calldata params, uint16 referrer) external; 
```


```solidity
📁 File: PositionManager.sol

/// @audit 125 chars long
214:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow, address to) public returns (uint256) { 

/// @audit 182 chars long
282:                             '","description":"This NFT represents a leveraged farming position on Rodeo Finance. The owner of this NFT can modify or redeem the position.","image":"', 

/// @audit 443 chars long
298:                 '<defs><clipPath id="corners"><rect width="290" height="290" rx="42" ry="42" /></clipPath><linearGradient id="0" x1="0.5" y1="0" x2="0.5" y2="1"><stop offset="0%" stop-color="#f3a526"/><stop offset="100%" stop-color="#e7940b"/></linearGradient><radialGradient id="1" gradientTransform="translate(-1 -0.5) scale(2, 2)"><stop offset="10%" stop-color="#f3a526"/><stop offset="100%" stop-color="#ffca74"/></radialGradient></defs>', 
/// @audit 395 chars long
299:                 '<g clip-path="url(#corners)"><rect fill="url(#0)" x="0px" y="0px" width="290px" height="290px" /><rect fill="url(#1)" x="0px" y="0px" width="290px" height="290px" /><ellipse cx="50%" cy="32px" rx="220px" ry="120px" fill="rgba(255,255,255,0.2)" opacity="0.85" /><rect x="16" y="16" width="258" height="258" rx="26" ry="26" fill="rgba(0,0,0,0)" stroke="rgba(255,255,255,0.4)" />',

/// @audit 133 chars long
314:                 '<text y="64px" x="32px" fill="white" font-family="\'Courier New\', monospace" font-weight="600" font-size="32px">#', 

/// @audit 140 chars long
316:                 '</text><text y="111px" x="32px" fill="white" font-family="\'Courier New\', monospace" font-weight="200" font-size="24px">', 

/// @audit 226 chars long
332:                 'px" height="26px" rx="8px" ry="8px" fill="rgba(0,0,0,0.4)" /><text x="12px" y="17px" font-family="\'Courier New\', monospace" font-size="12px" fill="white"><tspan fill="rgba(255,255,255,0.6)">Value: </tspan>', 

/// @audit 227 chars long
352:                 'px" height="26px" rx="8px" ry="8px" fill="rgba(0,0,0,0.4)" /><text x="12px" y="17px" font-family="\'Courier New\', monospace" font-size="12px" fill="white"><tspan fill="rgba(255,255,255,0.6)">Borrow: </tspan>', 

/// @audit 225 chars long
367:                 'px" height="26px" rx="8px" ry="8px" fill="rgba(0,0,0,0.4)" /><text x="12px" y="17px" font-family="\'Courier New\', monospace" font-size="12px" fill="white"><tspan fill="rgba(255,255,255,0.6)">Life: </tspan>', 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit 141 chars long
433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares); 
/// @audit 138 chars long
434:     function getDepositAmount(address pos, address token, uint256 deposit) external view returns (uint256 amountStart, uint256 amountEnd);

/// @audit 146 chars long
442:     function withdraw(uint256 shares, address to, address from, uint256[4] memory minAmounts) external returns (uint256 amount0, uint256 amount1); 
```


```solidity
📁 File: UtilFarmingBalances.sol

/// @audit 128 chars long
22:             (bool ok, bytes memory data) = address(pm).staticcall(abi.encodeWithSelector(IPositionManager.ownerOf.selector, y)); 
```


</details>


---
### [NC&#x2011;59] Long functions should be refactored into multiple, smaller, functions
Functions with too many lines are difficult to understand. It is recommended to refactor complex functions into multiple shorter and easier to understand functions.

<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

/// @audit 91 lines long
295:     function edit(uint256 id, int256 borrow, int256 collateral) external loop { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit 97 lines long
184:     function earn() external payable loop { 
```


</details>


---
### [NC&#x2011;60] Make use of Solidity's `using` keyword
The `using`-`for` [syntax](https://docs.soliditylang.org/en/latest/contracts.html#using-for) is the more common way of calling library functions.

<details>
<summary><i>There are 13 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

/// @audit Base64
277:                 Base64.encode( 
278:                     bytes(
279:                         abi.encodePacked(
280:                             '{"name":"#',
/// @audit Strings
281:                             Strings.toString(id),
282:                             '","description":"This NFT represents a leveraged farming position on Rodeo Finance. The owner of this NFT can modify or redeem the position.","image":"',
283:                             "data:image/svg+xml;base64,",
284:                             image,
285:                             '"}'
286:                         )
287:                     )
288:                 )

/// @audit Base64
294:         return Base64.encode( 
295:             abi.encodePacked(
296:                 '<svg width="290" height="290" viewBox="0 0 290 290" xmlns="http://www.w3.org/2000/svg"',
297:                 " xmlns:xlink='http://www.w3.org/1999/xlink'>",
298:                 '<defs><clipPath id="corners"><rect width="290" height="290" rx="42" ry="42" /></clipPath><linearGradient id="0" x1="0.5" y1="0" x2="0.5" y2="1"><stop offset="0%" stop-color="#f3a526"/><stop offset="100%" stop-color="#e7940b"/></linearGradient><radialGradient id="1" gradientTransform="translate(-1 -0.5) scale(2, 2)"><stop offset="10%" stop-color="#f3a526"/><stop offset="100%" stop-color="#ffca74"/></radialGradient></defs>',
299:                 '<g clip-path="url(#corners)"><rect fill="url(#0)" x="0px" y="0px" width="290px" height="290px" /><rect fill="url(#1)" x="0px" y="0px" width="290px" height="290px" /><ellipse cx="50%" cy="32px" rx="220px" ry="120px" fill="rgba(255,255,255,0.2)" opacity="0.85" /><rect x="16" y="16" width="258" height="258" rx="26" ry="26" fill="rgba(0,0,0,0)" stroke="rgba(255,255,255,0.4)" />',
300:                 generateHeader(id),
301:                 generateLabelVal(id),
302:                 generateLabelBor(id),
303:                 generateLabelLif(id),
304:                 "</g></svg>"
305:             )
306:         );

/// @audit Strings
315:                 Strings.toString(id), 

/// @audit Strings
331:                 Strings.toString(7 * (len + 4)), 

/// @audit Strings
351:                 Strings.toString(7 * (len + 4)), 

/// @audit Strings
366:                 Strings.toString(7 * (len + 4)), 

/// @audit Strings
377:         bytes memory sr = bytes(Strings.toString(r)); 

/// @audit Strings
381:         return string(abi.encodePacked(Strings.toString(n / x), ".", sr)); 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit TickMath
352:         uint160 midX96 = TickMath.getSqrtRatioAtTick(int24((tickCumulatives[1] - tickCumulatives[0]) / int32(period))); 

/// @audit LiquidityAmounts
383:         (uint256 amt0, uint256 amt1) = LiquidityAmounts.getAmountsForLiquidity( 
/// @audit TickMath
/// @audit TickMath
384:             midX96, TickMath.getSqrtRatioAtTick(minTick), TickMath.getSqrtRatioAtTick(maxTick), liq
385:         );
```


</details>


---
### [NC&#x2011;61] Minting to the zero address should be avoided
Minting tokens to the zero address in Solidity is a potential pitfall. The zero address (0x0) is commonly used as a default value and sending tokens there effectively burns them, leading to unintended token loss. To prevent this, include a check in the minting function to ensure the target address is not zero. Using OpenZeppelin's Address library with the requireNonZero function simplifies this check and enhances security.


<i>There is one instance of this issue:</i>

```solidity
📁 File: InvestorStrategyProxy.sol

43:     function mint(address strategy, uint256 amount) public auth returns (uint256) { 
44:         asset.approve(strategy, amount);
45:         return IStrategy(strategy).mint(amount);
46:     }
```



---
### [NC&#x2011;62] Missing checks for `address(0)`
Lack of zero-address validation on address parameters `that will assign to the storage variables` may lead to transaction reverts, waste gas, require resubmission of transactions and may even force contract redeployments in certain cases within the protocol.

<details>
<summary><i>There are 184 instances of this issue:</i></summary>

```solidity
📁 File: StrategyCamelotV3.sol

/// @audit targetAsset on line 69
/// @audit rewardToken1 on line 96
/// @audit rewardToken2 on line 98
/// @audit rewardToken3 on line 100
48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _xgrail,
52:         address _strategyHelperUniswapV3,
53:         address _uniProxy,
54:         address _quoter,
55:         address _hypervisor,
56:         address _nftPool,
57:         address _targetAsset,
58:         bytes memory _pathToLp
59:     ) {
60:         exec[msg.sender] = true;
61:         asset = IERC20(_asset);
62:         strategyHelper = IStrategyHelper(_strategyHelper);
63:         xgrail = IXGrail(_xgrail);
64:         strategyHelperUniswapV3 = IStrategyHelperUniswapV3(_strategyHelperUniswapV3);
65:         uniProxy = IUniProxy(_uniProxy);
66:         quoter = IQuoter(_quoter);
67:         hypervisor = IHypervisor(_hypervisor);
68:         nftPool = INFTPool(_nftPool);
69:         targetAsset = _targetAsset;
70:         pathToLp = _pathToLp;
71:         name = string(abi.encodePacked("Camelot V3 ", hypervisor.token0().symbol(), "/", hypervisor.token1().symbol()));
72: 
73:         if (_targetAsset != address(hypervisor.token0()) && _targetAsset != address(hypervisor.token1())) {
74:             revert WrongTargetAsset();
75:         }
76:     }

/// @audit targetAsset on line 69
/// @audit rewardToken1 on line 96
/// @audit rewardToken2 on line 98
/// @audit rewardToken3 on line 100
90:     function file(bytes32 what, address data) external auth { 
91:         if (what == "exec") {
92:             exec[data] = !exec[data];
93:         } else if (what == "keeper") {
94:             keepers[data] = !keepers[data];
95:         } else if (what == "rewardToken1") {
96:             rewardToken1 = data;
97:         } else if (what == "rewardToken2") {
98:             rewardToken2 = data;
99:         } else if (what == "rewardToken3") {
100:             rewardToken3 = data;
101:         } else {
102:             revert InvalidFile();
103:         }
104:         emit File(what, data);
105:     }

/// @audit targetAsset on line 69
/// @audit rewardToken1 on line 96
/// @audit rewardToken2 on line 98
/// @audit rewardToken3 on line 100
107:     function file(bytes32 what, uint256 data) external auth { 
108:         if (what == "slippage") {
109:             slippage = data;
110:         } else if (what == "twapPeriod") {
111:             if (data > uint256(int256(type(int32).max))) revert TwapPeriodTooLong();
112:             twapPeriod = uint32(twapPeriod);
113:         } else {
114:             revert InvalidFile();
115:         }
116:         emit File(what, data);
117:     }

/// @audit targetAsset on line 69
/// @audit rewardToken1 on line 96
/// @audit rewardToken2 on line 98
/// @audit rewardToken3 on line 100
119:     function setPathToLp(bytes calldata newPathToLp) external auth { 
120:         pathToLp = newPathToLp;
121:     }

/// @audit targetAsset on line 69
/// @audit rewardToken1 on line 96
/// @audit rewardToken2 on line 98
/// @audit rewardToken3 on line 100
123:     function setNitroPool(address _nitroPool) external auth { 
124:         if (tokenId == 0) revert TokenIdNeededFirst();
125:         if (_nitroPool == address(0)) {
126:             nitroPool.withdraw(tokenId);
127:         } else {
128:             nftPool.safeTransferFrom(address(this), _nitroPool, tokenId, "");
129:         }
130:         nitroPool = INitroPool(_nitroPool);
131:     }

/// @audit targetAsset on line 69
/// @audit rewardToken1 on line 96
/// @audit rewardToken2 on line 98
/// @audit rewardToken3 on line 100
133:     function xgrailRedeem(uint256 amount, uint256 duration) external auth { 
134:         xgrail.redeem(amount, duration);
135:     }

/// @audit targetAsset on line 69
/// @audit rewardToken1 on line 96
/// @audit rewardToken2 on line 98
/// @audit rewardToken3 on line 100
137:     function xgrailFinalizeRedeem(uint256 index) external auth { 
138:         xgrail.finalizeRedeem(index);
139:     }

/// @audit targetAsset on line 69
/// @audit rewardToken1 on line 96
/// @audit rewardToken2 on line 98
/// @audit rewardToken3 on line 100
141:     function mint(uint256 amount) external auth loop returns (uint256) { 
142:         asset.transferFrom(msg.sender, address(this), amount);
143:         address tgtAst = targetAsset;
144:         uint256 slp = slippage;
145:         uint256 tma = totalManagedAssets();
146: 
147:         asset.approve(address(strategyHelper), amount);
148:         strategyHelper.swap(address(asset), tgtAst, amount, slp, address(this));
149: 
150:         uint256 liq;
151:         {
152:             uint256 tgtAmt = IERC20(tgtAst).balanceOf(address(this));
153:             (uint256 amt0, uint256 amt1) = quoteAndSwap(tgtAst, tgtAmt, slp);
154:             address hyp = address(hypervisor);
155:             hypervisor.token0().approve(hyp, amt0);
156:             hypervisor.token1().approve(hyp, amt1);
157:             liq = uniProxy.deposit(amt0, amt1, address(this), hyp, [uint256(0), 0, 0, 0]);
158:             stake(liq);
159:         }
160: 
161:         uint256 val = valueLiquidity() * liq / totalManagedAssets();
162:         if (val < strategyHelper.value(address(asset), amount) * (10000 - slp) / 10000) revert PriceSlipped();
163:         uint256 shares = tma == 0 ? liq : liq * totalShares / tma;
164: 
165:         totalShares += shares;
166:         emit Mint(amount, shares);
167:         return shares;
168:     }

/// @audit targetAsset on line 69
/// @audit rewardToken1 on line 96
/// @audit rewardToken2 on line 98
/// @audit rewardToken3 on line 100
170:     function burn(uint256 shares) external auth loop returns (uint256) { 
171:         uint256 tma = totalManagedAssets();
172:         uint256 amt = (shares * tma) / totalShares;
173:         uint256 val = valueLiquidity() * amt / tma;
174:         unstake(amt);
175:         (uint256 amt0, uint256 amt1) = hypervisor.withdraw(amt, address(this), address(this), [uint256(0), 0, 0, 0]);
176: 
177:         address strategyHelperAddress = address(strategyHelper);
178:         hypervisor.token0().approve(strategyHelperAddress, amt0);
179:         hypervisor.token1().approve(strategyHelperAddress, amt1);
180: 
181:         uint256 bal;
182:         uint256 slp = slippage;
183:         bal += strategyHelper.swap(address(hypervisor.token0()), address(asset), amt0, slp, msg.sender);
184:         bal += strategyHelper.swap(address(hypervisor.token1()), address(asset), amt1, slp, msg.sender);
185: 
186:         if (strategyHelper.value(address(asset), bal) < val * (10000 - slp) / 10000) revert PriceSlipped();
187: 
188:         totalShares -= shares;
189:         emit Burn(bal, shares);
190:         return bal;
191:     }

/// @audit targetAsset on line 69
/// @audit rewardToken1 on line 96
/// @audit rewardToken2 on line 98
/// @audit rewardToken3 on line 100
193:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 
194:         uint256 amount = shares * totalManagedAssets() / totalShares;
195:         unstake(amount);
196:         hypervisor.transfer(to, amount);
197: 
198:         totalShares -= shares;
199:         emit Kill(amount, shares);
200: 
201:         address[] memory assets = new address[](1);
202:         assets[0] = address(hypervisor);
203:         return abi.encode(bytes32("camelotv3"), assets);
204:     }

/// @audit targetAsset on line 69
/// @audit rewardToken1 on line 96
/// @audit rewardToken2 on line 98
/// @audit rewardToken3 on line 100
228:     function earn() external payable loop { 
229:         if (!keepers[msg.sender]) revert NotKeeper();
230:         uint256 before = rate(totalShares);
231: 
232:         if (tokenId == 0) return;
233:         uint256 slp = slippage;
234:         address tgtAsset = targetAsset;
235:         nftPool.harvestPosition(tokenId);
236:         if (address(nitroPool) != address(0)) {
237:             nitroPool.harvest();
238:         }
239: 
240:         if (rewardToken1 != address(0)) {
241:             uint256 balance = IERC20(rewardToken1).balanceOf(address(this));
242:             if (strategyHelper.value(rewardToken1, balance) > 1e18) {
243:                 IERC20(rewardToken1).approve(address(strategyHelper), balance);
244:                 strategyHelper.swap(rewardToken1, tgtAsset, balance, slp, address(this));
245:             }
246:         }
247: 
248:         if (rewardToken2 != address(0)) {
249:             uint256 balance = IERC20(rewardToken2).balanceOf(address(this));
250:             if (strategyHelper.value(rewardToken2, balance) > 1e18) {
251:                 IERC20(rewardToken2).approve(address(strategyHelper), balance);
252:                 strategyHelper.swap(rewardToken2, tgtAsset, balance, slp, address(this));
253:             }
254:         }
255: 
256:         if (rewardToken3 != address(0)) {
257:             uint256 balance = IERC20(rewardToken3).balanceOf(address(this));
258:             if (strategyHelper.value(rewardToken3, balance) > 1e18) {
259:                 IERC20(rewardToken3).approve(address(strategyHelper), balance);
260:                 strategyHelper.swap(rewardToken3, tgtAsset, balance, slp, address(this));
261:             }
262:         }
263: 
264:         uint256 amt = IERC20(tgtAsset).balanceOf(address(this));
265:         if (strategyHelper.value(tgtAsset, amt) < 1e18) return;
266:         (uint256 amt0, uint256 amt1) = quoteAndSwap(tgtAsset, amt, slp);
267:         address h = address(hypervisor);
268:         IHypervisor(h).token0().approve(h, amt0);
269:         IHypervisor(h).token1().approve(h, amt1);
270:         stake(uniProxy.deposit(amt0, amt1, address(this), h, [uint256(0), 0, 0, 0]));
271: 
272:         uint256 current = rate(totalShares);
273:         emit Earn(current, current - min(current, before));
274:     }

/// @audit targetAsset on line 69
/// @audit rewardToken1 on line 96
/// @audit rewardToken2 on line 98
/// @audit rewardToken3 on line 100
276:     function exit(address strategy) external auth { 
277:         if (tokenId == 0) return;
278:         if (address(nitroPool) != address(0)) {
279:             nitroPool.withdraw(tokenId);
280:         }
281:         nftPool.safeTransferFrom(address(this), strategy, tokenId, "");
282:     }

/// @audit targetAsset on line 69
/// @audit rewardToken1 on line 96
/// @audit rewardToken2 on line 98
/// @audit rewardToken3 on line 100
284:     function move(address old) external auth { 
285:         nftPool = StrategyCamelotV3(old).nftPool();
286:         nitroPool = StrategyCamelotV3(old).nitroPool();
287:         tokenId = StrategyCamelotV3(old).tokenId();
288:         if (address(nitroPool) != address(0)) {
289:             nftPool.safeTransferFrom(address(this), address(nitroPool), tokenId, "");
290:         }
291:     }

/// @audit targetAsset on line 69
/// @audit rewardToken1 on line 96
/// @audit rewardToken2 on line 98
/// @audit rewardToken3 on line 100
390:     function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external returns (bytes4) { 
391:         if (msg.sender == address(nftPool) && tokenId == 0) {
392:             tokenId = _tokenId;
393:         }
394:         return StrategyCamelotV3.onERC721Received.selector;
395:     }
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _exchangeRouter,
52:         address _reader,
53:         address _depositHandler,
54:         address _withdrawalHandler,
55:         address _dataStore,
56:         address _market
57:     ) {
58:         exec[msg.sender] = true;
59:         asset = IERC20(_asset);
60:         strategyHelper = IStrategyHelper(_strategyHelper);
61:         exchangeRouter = IExchangeRouter(_exchangeRouter);
62:         reader = IReader(_reader);
63:         depositHandler = _depositHandler;
64:         withdrawalHandler = _withdrawalHandler;
65:         depositVault = IHandler(_depositHandler).depositVault();
66:         withdrawalVault = IHandler(_withdrawalHandler).withdrawalVault();
67:         dataStore = _dataStore;
68:         market = _market;
69: 
70:         IMarket.Props memory marketInfo = reader.getMarket(_dataStore, market);
71:         tokenLong = marketInfo.longToken;
72:         tokenShort = marketInfo.shortToken;
73:         name = string(
74:             abi.encodePacked(
75:                 "GMX GM ", IERC20(marketInfo.longToken).symbol(), "/", IERC20(marketInfo.shortToken).symbol()
76:             )
77:         );
78:     }

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
80:     receive() external payable {} 

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
94:     function file(bytes32 what, address data) external auth { 
95:         if (what == "exec") {
96:             exec[data] = !exec[data];
97:         } else if (what == "keeper") {
98:             keepers[data] = !keepers[data];
99:         } else if (what == "reader") {
100:             reader = IReader(data);
101:         } else if (what == "exchangeRouter") {
102:             exchangeRouter = IExchangeRouter(data);
103:         } else if (what == "depositHandler") {
104:             depositHandler = data;
105:             depositVault = IHandler(data).depositVault();
106:         } else if (what == "withdrawalHandler") {
107:             withdrawalHandler = data;
108:             withdrawalVault = IHandler(data).withdrawalVault();
109:         } else {
110:             revert InvalidFile();
111:         }
112:         emit File(what, data);
113:     }

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
115:     function file(bytes32 what, uint256 data) external auth { 
116:         if (what == "slippage") {
117:             slippage = data;
118:         } else if (what == "indexTokenDecimals") {
119:             indexTokenDecimals = data;
120:         } else if (what == "reserveRatio") {
121:             if (data > 10000) revert WrongReserveRatio();
122:             reserveRatio = data;
123:         } else if (what == "callbackGasLimit") {
124:             callbackGasLimit = data;
125:         } else if (what == "earnActionValue") {
126:             earnActionValue = data;
127:         } else {
128:             revert InvalidFile();
129:         }
130:         emit File(what, data);
131:     }

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
133:     function withdrawEth() external auth { 
134:         (bool success,) = address(msg.sender).call{value: address(this).balance}("");
135:         if (!success) revert ErrorSendingETH();
136:     }

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
138:     function withdrawAirdrop(address token) external auth { 
139:       if (token == address(market) || token == tokenShort || token == tokenLong) revert BadToken();
140:       IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));
141:     }

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
143:     function mint(uint256 amount) external auth loop returns (uint256) { 
144:         uint256 slp = slippage;
145:         uint256 tot = totalShares;
146:         uint256 tma = rate(tot);
147: 
148:         asset.transferFrom(msg.sender, address(this), amount);
149:         asset.approve(address(strategyHelper), amount);
150:         uint256 bal = strategyHelper.swap(address(asset), tokenShort, amount, slp, address(this));
151:         uint256 val = strategyHelper.value(tokenShort, bal);
152:         uint256 shares = (tma == 0 || tot == 0) ? val : val * tot / tma;
153: 
154:         totalShares += shares;
155:         emit Mint(amount, shares);
156:         return shares;
157:     }

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
159:     function burn(uint256 shares) external auth loop returns (uint256) { 
160:         uint256 slp = slippage;
161:         uint256 val = rate(shares);
162:         uint256 amt = (val * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort);
163:         IERC20(tokenShort).approve(address(strategyHelper), amt);
164:         uint256 bal = strategyHelper.swap(tokenShort, address(asset), amt, slp, msg.sender);
165: 
166:         totalShares -= shares;
167:         emit Burn(bal, shares);
168:         return bal;
169:     }

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
171:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 
172:         uint256 value = rate(shares);
173:         uint256 amount = (value * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort);
174:         IERC20(tokenShort).transfer(to, amount);
175: 
176:         totalShares -= shares;
177:         emit Kill(amount, shares);
178: 
179:         address[] memory assets = new address[](1);
180:         assets[0] = tokenShort;
181:         return abi.encode(bytes32("gmxgm"), assets);
182:     }

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
184:     function earn() external payable loop { 
185:         if (!keepers[msg.sender]) revert NotKeeper();
186:         uint256 before = rate(totalShares);
187: 
188:         if (amountPendingDeposit != 0 || amountPendingWithdraw != 0) {
189:             revert ActionPending();
190:         }
191: 
192:         uint256 slp = slippage;
193:         uint256 bal = IERC20(tokenLong).balanceOf(address(this));
194:         if (bal > 0) {
195:             IERC20(tokenLong).approve(address(strategyHelper), bal);
196:             strategyHelper.swap(tokenLong, tokenShort, bal, slp, address(this));
197:         }
198: 
199:         bal = IERC20(tokenShort).balanceOf(address(this));
200:         uint256 have = strategyHelper.value(tokenShort, bal);
201:         uint256 need = rate(totalShares) * reserveRatio / 10000;
202: 
203:         if (have > need) {
204:             uint256 amt = (have - need) * bal / have;
205:             uint256 haf = amt / 2;
206:             IERC20(tokenShort).approve(address(strategyHelper), haf);
207:             uint256 out = strategyHelper.swap(tokenShort, tokenLong, haf, slp, address(this));
208:             uint256 minOut = (have - need) * 1e18 / marketTokenPrice(true);
209:             amountPendingDeposit = minOut;
210:             minOut = minOut * (10000 - slp) / 10000;
211: 
212:             IExchangeRouter.CreateDepositParams memory params = IExchangeRouter.CreateDepositParams({
213:                 receiver: address(this),
214:                 callbackContract: address(this),
215:                 uiFeeReceiver: address(0),
216:                 market: market,
217:                 initialLongToken: tokenLong,
218:                 initialShortToken: tokenShort,
219:                 longTokenSwapPath: new address[](0),
220:                 shortTokenSwapPath: new address[](0),
221:                 minMarketTokens: minOut,
222:                 shouldUnwrapNativeToken: false,
223:                 executionFee: earnActionValue,
224:                 callbackGasLimit: callbackGasLimit
225:             });
226: 
227:             IMarket.Props memory marketInfo = reader.getMarket(dataStore, market);
228:             bytes[] memory data = new bytes[](4);
229:             address router = exchangeRouter.router();
230:             address vault = depositVault;
231: 
232:             IERC20(marketInfo.longToken).approve(router, out);
233:             IERC20(marketInfo.shortToken).approve(router, amt - haf);
234: 
235:             data[0] = abi.encodeWithSelector(IExchangeRouter.sendWnt.selector, vault, params.executionFee);
236:             data[1] = abi.encodeWithSelector(IExchangeRouter.sendTokens.selector, marketInfo.longToken, vault, out);
237:             data[2] =
238:                 abi.encodeWithSelector(IExchangeRouter.sendTokens.selector, marketInfo.shortToken, vault, amt - haf);
239:             data[3] = abi.encodeWithSelector(IExchangeRouter.createDeposit.selector, params);
240:             exchangeRouter.multicall{value: params.executionFee}(data);
241:         } else if (have < need) {
242:             uint256 amt = (need - have) * 1e18 / marketTokenPrice(true);
243: 
244:             IMarket.Props memory marketInfo = reader.getMarket(dataStore, market);
245:             (uint256 longOut, uint256 shortOut) = reader.getWithdrawalAmountOut(
246:                 dataStore,
247:                 marketInfo,
248:                 IMarket.Prices({
249:                     indexTokenPrice: gmxPrice(marketInfo.indexToken, true),
250:                     longTokenPrice: gmxPrice(marketInfo.longToken, false),
251:                     shortTokenPrice: gmxPrice(marketInfo.shortToken, false)
252:                 }),
253:                 amt,
254:                 address(0)
255:             );
256:             IExchangeRouter.CreateWithdrawalParams memory params = IExchangeRouter.CreateWithdrawalParams({
257:                 receiver: address(this),
258:                 callbackContract: address(this),
259:                 uiFeeReceiver: address(0),
260:                 market: market,
261:                 longTokenSwapPath: new address[](0),
262:                 shortTokenSwapPath: new address[](0),
263:                 minLongTokenAmount: longOut * (10000 - slp) / 10000,
264:                 minShortTokenAmount: shortOut * (10000 - slp) / 10000,
265:                 shouldUnwrapNativeToken: false,
266:                 executionFee: earnActionValue,
267:                 callbackGasLimit: callbackGasLimit
268:             });
269: 
270:             amountPendingWithdraw = amt;
271:             bytes[] memory data = new bytes[](3);
272:             IERC20(market).approve(exchangeRouter.router(), amt);
273:             data[0] = abi.encodeWithSelector(IExchangeRouter.sendWnt.selector, withdrawalVault, params.executionFee);
274:             data[1] = abi.encodeWithSelector(IExchangeRouter.sendTokens.selector, market, withdrawalVault, amt);
275:             data[2] = abi.encodeWithSelector(IExchangeRouter.createWithdrawal.selector, params);
276:             exchangeRouter.multicall{value: params.executionFee}(data);
277:         }
278: 
279:         uint256 current = rate(totalShares);
280:         emit Earn(current, current - min(current, before));
281:     }

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
283:     function exit(address strategy) external auth { 
284:         if (amountPendingDeposit != 0 || amountPendingWithdraw != 0) {
285:             revert ActionPending();
286:         }
287:         IERC20(market).transfer(strategy, IERC20(market).balanceOf(address(this)));
288:         IERC20(tokenLong).transfer(strategy, IERC20(tokenLong).balanceOf(address(this)));
289:         IERC20(tokenShort).transfer(strategy, IERC20(tokenShort).balanceOf(address(this)));
290:     }

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
292:     function move(address old) external auth {} 

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
335:     function afterDepositExecution(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 
336:         if (msg.sender != depositHandler) revert NotGMX();
337:         amountPendingDeposit = 0;
338:     }

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
340:     function afterDepositCancellation(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 
341:         if (msg.sender != depositHandler) revert NotGMX();
342:         amountPendingDeposit = 0;
343:     }

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
345:     function afterWithdrawalExecution(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 
346:         if (msg.sender != withdrawalHandler) revert NotGMX();
347:         amountPendingWithdraw = 0;
348:         uint256 bal = IERC20(tokenLong).balanceOf(address(this));
349:         IERC20(tokenLong).approve(address(strategyHelper), bal);
350:         try strategyHelper.swap(tokenLong, tokenShort, bal, slippage, address(this)) {} catch {}
351:     }

/// @audit depositHandler on line 63
/// @audit withdrawalHandler on line 64
/// @audit depositVault on line 65
/// @audit withdrawalVault on line 66
/// @audit depositHandler on line 104
/// @audit depositVault on line 105
/// @audit withdrawalHandler on line 107
/// @audit withdrawalVault on line 108
353:     function afterWithdrawalCancellation(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 
354:         if (msg.sender != withdrawalHandler) revert NotGMX();
355:         amountPendingWithdraw = 0;
356:     }
```


</details>


---
### [NC&#x2011;63] Missing checks for `address(0x0)` in the constructor
<details>
<summary><i>There are 27 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @audit _investor missing zero address validation
/// @audit _asset missing zero address validation
/// @audit _lender missing zero address validation
/// @audit _sh missing zero address validation
36:     constructor(address _investor, address _asset, address _lender, address _sh) { 
```


```solidity
📁 File: Investor.sol

/// @audit _store missing zero address validation
/// @audit _helper missing zero address validation
144:     constructor(address _store, address _helper) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit _asset missing zero address validation
24:     constructor(address _asset) { 
```


```solidity
📁 File: PositionManager.sol

/// @audit _investor missing zero address validation
91:     constructor(address _investor) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit _asset missing zero address validation
/// @audit _strategyHelper missing zero address validation
/// @audit _xgrail missing zero address validation
/// @audit _strategyHelperUniswapV3 missing zero address validation
/// @audit _uniProxy missing zero address validation
/// @audit _quoter missing zero address validation
/// @audit _hypervisor missing zero address validation
/// @audit _nftPool missing zero address validation
48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _xgrail,
52:         address _strategyHelperUniswapV3,
53:         address _uniProxy,
54:         address _quoter,
55:         address _hypervisor,
56:         address _nftPool,
57:         address _targetAsset,
58:         bytes memory _pathToLp
59:     ) {
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit _asset missing zero address validation
/// @audit _strategyHelper missing zero address validation
/// @audit _exchangeRouter missing zero address validation
/// @audit _reader missing zero address validation
/// @audit _depositHandler missing zero address validation
/// @audit _withdrawalHandler missing zero address validation
/// @audit _dataStore missing zero address validation
/// @audit _market missing zero address validation
48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _exchangeRouter,
52:         address _reader,
53:         address _depositHandler,
54:         address _withdrawalHandler,
55:         address _dataStore,
56:         address _market
57:     ) {
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit _asset missing zero address validation
/// @audit _strategyHelper missing zero address validation
/// @audit _rewarder missing zero address validation
29:     constructor(address _asset, address _strategyHelper, address _rewarder, uint256 _poolId) { 
```


</details>


---
### [NC&#x2011;64] Missing checks for uint state variable assignments
<details>
<summary><i>There are 19 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

273:         p.strategy = strategy; 

275:         p.collateral = collateral; 
```


```solidity
📁 File: Store.sol

48:         uintValues[key] = value; 

66:         intValues[key] = value; 
```


```solidity
📁 File: StrategyCamelotV3.sol

109:             slippage = data; 

188:         totalShares -= shares; 

198:         totalShares -= shares; 

392:             tokenId = _tokenId; 
```


```solidity
📁 File: StrategyGMXGM.sol

117:             slippage = data; 

119:             indexTokenDecimals = data; 

122:             reserveRatio = data; 

124:             callbackGasLimit = data; 

126:             earnActionValue = data; 

166:         totalShares -= shares; 

176:         totalShares -= shares; 
```


```solidity
📁 File: StrategySushiswap.sol

34:         poolId = _poolId; 

65:             slippage = data; 

136:         totalShares -= shares; 

145:         totalShares -= shares; 
```


</details>


---
### [NC&#x2011;65] Multiple mappings with same keys can be combined into a single struct mapping for readability
Well-organized data structures make code reviews easier, which may lead to fewer bugs. Consider combining related mappings into mappings to structs, so it's clear what data is related


<i>There are 4 instaces of this issue:</i>

```solidity
📁 File: PositionManager.sol

70:     mapping(uint256 => address) internal _ownerOf; 
71:     mapping(address => uint256) internal _balanceOf;

73:     mapping(uint256 => address) public getApproved; 

88:         mapping(uint256 => uint256) positions; 
```



---
### [NC&#x2011;66] Multiple type casts create complexity within the code
To ensure reliable and precise data handling in Solidity contracts, developers should avoid double type casting. Multiple type casts can lead to unintended consequences, such as truncation, rounding errors, or loss of precision. This compromises the contract's functionality and readability, making debugging more challenging. Instead, its crucial to use appropriate data types and minimize unnecessary type casting for a more dependable and robust contract execution.

<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @audit uint256(bytes32)
57:         uint256 id = uint256(bytes32(params)); 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit uint256(int256)
111:             if (data > uint256(int256(type(int32).max))) revert TwapPeriodTooLong(); 
```


</details>


---
### [NC&#x2011;67] Named imports of parent contracts are missing

<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyCamelotV3.sol

/// @audit IERC20 
441: interface IHypervisor is IERC20 { 
```



---
### [NC&#x2011;68] Names of private/internal state variables should be prefixed with an underscore
According to the Solidity Style Guide, Names of private/internal state variables should be prefixed with an <a href="https://docs.soliditylang.org/en/latest/style-guide.html#underscore-prefix-for-non-external-functions-and-variables">underscore</a>.

<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

/// @audit _entered
74:     bool internal entered; 
/// @audit _lastBlock
75:     mapping(uint256 => uint256) private lastBlock;
```


```solidity
📁 File: Store.sol

/// @audit _bytes32Sets
13:     mapping(bytes32 => Bytes32Set) internal bytes32Sets; 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit _entered
11:     bool internal entered; 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit _entered
8:     bool internal entered; 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit _entered
8:     bool internal entered; 
```


</details>


---
### [NC&#x2011;69] NatSpec documentation for `constructor` is missing
<details>
<summary><i>There are 10 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

17:     constructor() { 
```


```solidity
📁 File: Helper.sol

36:     constructor(address _investor, address _asset, address _lender, address _sh) { 
```


```solidity
📁 File: Investor.sol

144:     constructor(address _store, address _helper) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

24:     constructor(address _asset) { 
```


```solidity
📁 File: PositionManager.sol

91:     constructor(address _investor) { 
```


```solidity
📁 File: Store.sol

26:     constructor() { 
```


```solidity
📁 File: StrategyCamelotV3.sol

48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _xgrail,
52:         address _strategyHelperUniswapV3,
53:         address _uniProxy,
54:         address _quoter,
55:         address _hypervisor,
56:         address _nftPool,
57:         address _targetAsset,
58:         bytes memory _pathToLp
59:     ) {
```


```solidity
📁 File: StrategyGMXGM.sol

48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _exchangeRouter,
52:         address _reader,
53:         address _depositHandler,
54:         address _withdrawalHandler,
55:         address _dataStore,
56:         address _market
57:     ) {
```


```solidity
📁 File: StrategySushiswap.sol

29:     constructor(address _asset, address _strategyHelper, address _rewarder, uint256 _poolId) { 
```


```solidity
📁 File: Whitelist.sol

14:     constructor() { 
```


</details>


---
### [NC&#x2011;70] NatSpec: Constructor declarations should have `@notice` tags
<details>
<summary><i>There are 10 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

17:     constructor() { 
```


```solidity
📁 File: Helper.sol

36:     constructor(address _investor, address _asset, address _lender, address _sh) { 
```


```solidity
📁 File: Investor.sol

144:     constructor(address _store, address _helper) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

24:     constructor(address _asset) { 
```


```solidity
📁 File: PositionManager.sol

91:     constructor(address _investor) { 
```


```solidity
📁 File: Store.sol

26:     constructor() { 
```


```solidity
📁 File: StrategyCamelotV3.sol

48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _xgrail,
52:         address _strategyHelperUniswapV3,
53:         address _uniProxy,
54:         address _quoter,
55:         address _hypervisor,
56:         address _nftPool,
57:         address _targetAsset,
58:         bytes memory _pathToLp
59:     ) {
```


```solidity
📁 File: StrategyGMXGM.sol

48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _exchangeRouter,
52:         address _reader,
53:         address _depositHandler,
54:         address _withdrawalHandler,
55:         address _dataStore,
56:         address _market
57:     ) {
```


```solidity
📁 File: StrategySushiswap.sol

29:     constructor(address _asset, address _strategyHelper, address _rewarder, uint256 _poolId) { 
```


```solidity
📁 File: Whitelist.sol

14:     constructor() { 
```


</details>


---
### [NC&#x2011;71] NatSpec: Contract declarations should have `@author` tags
<details>
<summary><i>There are 63 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

3:  
4: interface IERC20 {
5:     function transfer(address, uint256) external returns (bool);

7:  
8: contract Bank {
9:     mapping(address => bool) public exec;
```


```solidity
📁 File: Helper.sol

3:  
4: interface IERC20 {
5:     function balanceOf(address) external view returns (uint256);

9:  
10: interface IInvestor {
11:     function killRepayment(uint256) external returns (uint256);

14:  
15: interface IAavePool {
16:     function flashLoanSimple(address receiver, address asset, uint256 amount, bytes calldata params, uint16 referrer) external;

18:  
19: interface IStrategyHelper {
20:     function swap(address, address, uint256, uint256, address) external returns (uint256);

22:  
23: interface ISushi {
24:     function token0() external view returns (address);

28:  
29: contract Helper {
30:     IInvestor public investor;
```


```solidity
📁 File: Investor.sol

3:  
4: interface IERC20 {
5:     function decimals() external view returns (uint8);

11:  
12: interface IOracle {
13:     function decimals() external view returns (uint8);

16:  
17: interface IStore {
18:     function exec(address) external view returns (bool);

25:  
26: interface IBank {
27:     function exec(address) external view returns (bool);

30:  
31: interface IPool {
32:     function exec(address) external view returns (bool);

39:  
40: interface IHelper {
41:     function price(address) external view returns (uint256);

46:  
47: interface IStrategy {
48:     function totalShares() external view returns (uint256);

53:  
54: interface IStrategyProxy {
55:     function exec(address) external view returns (bool);

60:  
61: interface IWhitelist {
62:     function check(address) external view returns (bool);

64:  
65: contract Investor {
66:     IStore public store;
```


```solidity
📁 File: InvestorStrategyProxy.sol

3:  
4: interface IERC20 {
5:     function approve(address, uint256) external returns (bool);

8:  
9: interface IStrategy {
10:     function mint(uint256 amount) external returns (uint256 shares);

14:  
15: contract InvestorStrategyProxy {
16:     IERC20 public asset;
```


```solidity
📁 File: PositionManager.sol

6:  
7: interface IERC20 {
8:     function decimals() external view returns (uint8);

14:  
15: interface IOracle {
16:     function latestAnswer() external view returns (int256);

19:  
20: interface IPool {
21:     function asset() external view returns (address);

25:  
26: interface IStrategy {
27:     function name() external view returns (string memory);

30:  
31: interface IInvestor {
32:     struct Strategy {

54:  
55: interface IWhitelist {
56:     function check(address) external view returns (bool);

58:  
59: interface ERC721TokenReceiver {
60:     function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4);
```


```solidity
📁 File: Store.sol

3:  
4: contract Store {
5:     mapping(address => bool) public exec;
```


```solidity
📁 File: StrategyCamelotV3.sol

6:  
7: contract StrategyCamelotV3 {
8:     string public name;

413:  
414: interface IERC20 {
415:     function symbol() external view returns (string memory);

421:  
422: interface IStrategyHelper {
423:     function value(address, uint256) external view returns (uint256);

427:  
428: interface IStrategyHelperUniswapV3 {
429:     function swap(address ast, bytes calldata path, uint256 amt, uint256 min, address to) external;

431:  
432: interface IUniProxy {
433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares);

436:  
437: interface IQuoter {
438:     function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);

440:  
441: interface IHypervisor is IERC20 {
442:     function withdraw(uint256 shares, address to, address from, uint256[4] memory minAmounts) external returns (uint256 amount0, uint256 amount1);

452:  
453: interface INFTPool {
454:     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;

465:  
466: interface INitroPool {
467:     function harvest() external;

470:  
471: interface IAlgebraPool {
472:     function token0() external view returns (address);

489:  
490: interface IXGrail {
491:   function redeem(uint256 xGrailAmount, uint256 duration) external;
```


```solidity
📁 File: StrategyGMXGM.sol

3:  
4: contract StrategyGMXGM {
5:     string public name;

362:  
363: interface IERC20 {
364:     function symbol() external view returns (string memory);

371:  
372: interface IStrategyHelper {
373:     function price(address) external view returns (uint256);

377:  
378: interface IHandler {
379:     function depositVault() external view returns (address);

382:  
383: interface IPriceFeed {
384:     function latestRoundData() external view returns (

392:  
393: interface IDataStore {
394:     function getUint(bytes32 key) external view returns (uint256);

398:  
399: interface IExchangeRouter {
400:     struct CreateDepositParams {

436:  
437: interface IMarket {
438:     struct Prices {

453:  
454: interface IPrice {
455:     struct Props {

460:  
461: interface IMarketPoolValueInfo {
462:     struct Props {

476:  
477: interface IReader {
478:     function getMarket(address dataStore, address key) external view returns (IMarket.Props memory);

496:  
497: interface IDeposit {
498:     struct Props {

529:  
530: interface IWithdrawal {
531:     struct Props {

560:  
561: interface IEventUtils {
562:     struct EventLogData {
```


```solidity
📁 File: StrategySushiswap.sol

3:  
4: contract StrategySushiswap {
5:     string public name;

252:  
253: interface IERC20 {
254:     function symbol() external view returns (string memory);

261:  
262: interface IStrategyHelper {
263:     function price(address) external view returns (uint256);

267:  
268: interface IUniswapV2Pair {
269:     function token0() external view returns (address);

280:  
281: interface ISushiswapMiniChefV2 {
282:     function SUSHI() external view returns (address);
```


```solidity
📁 File: UtilFarmingBalances.sol

3:  
4: interface IInvestor {
5:     function nextPosition() external view returns (uint256);

8:  
9: interface IPositionManager {
10:     function ownerOf(uint256) external view returns (address);

12:  
13: contract UtilFarmingBalances {
14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) {
```


```solidity
📁 File: Whitelist.sol

3:  
4: contract Whitelist {
5:     mapping(address => bool) public exec;
```


</details>


---
### [NC&#x2011;72] NatSpec: Contract declarations should have `@dev` tags
<details>
<summary><i>There are 64 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

3:  
4: interface IERC20 {
5:     function transfer(address, uint256) external returns (bool);

7:  
8: contract Bank {
9:     mapping(address => bool) public exec;
```


```solidity
📁 File: Helper.sol

3:  
4: interface IERC20 {
5:     function balanceOf(address) external view returns (uint256);

9:  
10: interface IInvestor {
11:     function killRepayment(uint256) external returns (uint256);

14:  
15: interface IAavePool {
16:     function flashLoanSimple(address receiver, address asset, uint256 amount, bytes calldata params, uint16 referrer) external;

18:  
19: interface IStrategyHelper {
20:     function swap(address, address, uint256, uint256, address) external returns (uint256);

22:  
23: interface ISushi {
24:     function token0() external view returns (address);

28:  
29: contract Helper {
30:     IInvestor public investor;
```


```solidity
📁 File: Investor.sol

3:  
4: interface IERC20 {
5:     function decimals() external view returns (uint8);

11:  
12: interface IOracle {
13:     function decimals() external view returns (uint8);

16:  
17: interface IStore {
18:     function exec(address) external view returns (bool);

25:  
26: interface IBank {
27:     function exec(address) external view returns (bool);

30:  
31: interface IPool {
32:     function exec(address) external view returns (bool);

39:  
40: interface IHelper {
41:     function price(address) external view returns (uint256);

46:  
47: interface IStrategy {
48:     function totalShares() external view returns (uint256);

53:  
54: interface IStrategyProxy {
55:     function exec(address) external view returns (bool);

60:  
61: interface IWhitelist {
62:     function check(address) external view returns (bool);

64:  
65: contract Investor {
66:     IStore public store;
```


```solidity
📁 File: InvestorStrategyProxy.sol

3:  
4: interface IERC20 {
5:     function approve(address, uint256) external returns (bool);

8:  
9: interface IStrategy {
10:     function mint(uint256 amount) external returns (uint256 shares);

14:  
15: contract InvestorStrategyProxy {
16:     IERC20 public asset;
```


```solidity
📁 File: PositionManager.sol

6:  
7: interface IERC20 {
8:     function decimals() external view returns (uint8);

14:  
15: interface IOracle {
16:     function latestAnswer() external view returns (int256);

19:  
20: interface IPool {
21:     function asset() external view returns (address);

25:  
26: interface IStrategy {
27:     function name() external view returns (string memory);

30:  
31: interface IInvestor {
32:     struct Strategy {

54:  
55: interface IWhitelist {
56:     function check(address) external view returns (bool);

58:  
59: interface ERC721TokenReceiver {
60:     function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4);

63: /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol) 
64: contract PositionManager {
65:     string public constant name = "Rodeo V2 Position";
```


```solidity
📁 File: Store.sol

3:  
4: contract Store {
5:     mapping(address => bool) public exec;
```


```solidity
📁 File: StrategyCamelotV3.sol

6:  
7: contract StrategyCamelotV3 {
8:     string public name;

413:  
414: interface IERC20 {
415:     function symbol() external view returns (string memory);

421:  
422: interface IStrategyHelper {
423:     function value(address, uint256) external view returns (uint256);

427:  
428: interface IStrategyHelperUniswapV3 {
429:     function swap(address ast, bytes calldata path, uint256 amt, uint256 min, address to) external;

431:  
432: interface IUniProxy {
433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares);

436:  
437: interface IQuoter {
438:     function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);

440:  
441: interface IHypervisor is IERC20 {
442:     function withdraw(uint256 shares, address to, address from, uint256[4] memory minAmounts) external returns (uint256 amount0, uint256 amount1);

452:  
453: interface INFTPool {
454:     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;

465:  
466: interface INitroPool {
467:     function harvest() external;

470:  
471: interface IAlgebraPool {
472:     function token0() external view returns (address);

489:  
490: interface IXGrail {
491:   function redeem(uint256 xGrailAmount, uint256 duration) external;
```


```solidity
📁 File: StrategyGMXGM.sol

3:  
4: contract StrategyGMXGM {
5:     string public name;

362:  
363: interface IERC20 {
364:     function symbol() external view returns (string memory);

371:  
372: interface IStrategyHelper {
373:     function price(address) external view returns (uint256);

377:  
378: interface IHandler {
379:     function depositVault() external view returns (address);

382:  
383: interface IPriceFeed {
384:     function latestRoundData() external view returns (

392:  
393: interface IDataStore {
394:     function getUint(bytes32 key) external view returns (uint256);

398:  
399: interface IExchangeRouter {
400:     struct CreateDepositParams {

436:  
437: interface IMarket {
438:     struct Prices {

453:  
454: interface IPrice {
455:     struct Props {

460:  
461: interface IMarketPoolValueInfo {
462:     struct Props {

476:  
477: interface IReader {
478:     function getMarket(address dataStore, address key) external view returns (IMarket.Props memory);

496:  
497: interface IDeposit {
498:     struct Props {

529:  
530: interface IWithdrawal {
531:     struct Props {

560:  
561: interface IEventUtils {
562:     struct EventLogData {
```


```solidity
📁 File: StrategySushiswap.sol

3:  
4: contract StrategySushiswap {
5:     string public name;

252:  
253: interface IERC20 {
254:     function symbol() external view returns (string memory);

261:  
262: interface IStrategyHelper {
263:     function price(address) external view returns (uint256);

267:  
268: interface IUniswapV2Pair {
269:     function token0() external view returns (address);

280:  
281: interface ISushiswapMiniChefV2 {
282:     function SUSHI() external view returns (address);
```


```solidity
📁 File: UtilFarmingBalances.sol

3:  
4: interface IInvestor {
5:     function nextPosition() external view returns (uint256);

8:  
9: interface IPositionManager {
10:     function ownerOf(uint256) external view returns (address);

12:  
13: contract UtilFarmingBalances {
14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) {
```


```solidity
📁 File: Whitelist.sol

3:  
4: contract Whitelist {
5:     mapping(address => bool) public exec;
```


</details>


---
### [NC&#x2011;73] NatSpec: Contract declarations should have `@notice` tags
`@notice` is used to explain to end users what the contract does, and the compiler interprets `///` or `/**` comments as this tag if one was't explicitly provided

<details>
<summary><i>There are 64 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

4: interface IERC20 { 
5:     function transfer(address, uint256) external returns (bool);
6: }
7: 
8: contract Bank {
9:     mapping(address => bool) public exec;
10: 
11:     event File(bytes32 indexed what, address data);
12: 
13:     error InvalidFile();
14:     error Unauthorized();
```


```solidity
📁 File: Helper.sol

4: interface IERC20 { 
5:     function balanceOf(address) external view returns (uint256);
6:     function approve(address, uint256) external;
7:     function transfer(address, uint256) external;
8: }
9: 
10: interface IInvestor {
11:     function killRepayment(uint256) external returns (uint256);
12:     function kill(uint256 id) external returns (address, bytes memory);
13: }
14: 
15: interface IAavePool {
16:     function flashLoanSimple(address receiver, address asset, uint256 amount, bytes calldata params, uint16 referrer) external;
17: }
18: 
19: interface IStrategyHelper {
20:     function swap(address, address, uint256, uint256, address) external returns (uint256);
21: }
22: 
23: interface ISushi {
24:     function token0() external view returns (address);
25:     function token1() external view returns (address);
26:     function burn(address) external;
27: }
28: 
29: contract Helper {
30:     IInvestor public investor;
31:     IERC20 public asset;
32:     IAavePool public lender; // 0x794a61358D6845594F94dc1DB02A252b5b4814aD
33:     IStrategyHelper public sh;
34:     uint256 public slippage = 2500;
35: 
```


```solidity
📁 File: Investor.sol

4: interface IERC20 { 
5:     function decimals() external view returns (uint8);
6:     function balanceOf(address) external view returns (uint256);
7:     function approve(address, uint256) external;
8:     function transfer(address, uint256) external returns (bool);
9:     function transferFrom(address, address, uint256) external returns (bool);
10: }

12: interface IOracle { 
13:     function decimals() external view returns (uint8);
14:     function latestAnswer() external view returns (int256);
15: }
16: 
17: interface IStore {
18:     function exec(address) external view returns (bool);
19:     function getUint(bytes32) external view returns (uint256);
20:     function getAddress(bytes32) external view returns (address);
21:     function setUint(bytes32, uint256) external;
22:     function setUintDelta(bytes32, int256) external returns (uint256);
23:     function setAddress(bytes32, address) external returns (address);

26: interface IBank { 
27:     function exec(address) external view returns (bool);
28:     function transfer(address, address, uint256) external;
29: }
30: 
31: interface IPool {
32:     function exec(address) external view returns (bool);
33:     function asset() external view returns (address);
34:     function oracle() external view returns (address);
35:     function getUpdatedIndex() external view returns (uint256);
36:     function borrow(uint256) external returns (uint256);
37:     function repay(uint256) external returns (uint256);

40: interface IHelper { 
41:     function price(address) external view returns (uint256);
42:     function value(address, uint256) external view returns (uint256);
43:     function convert(address, address, uint256) external view returns (uint256);
44:     function swap(address, address, uint256, uint256, address) external returns (uint256);
45: }
46: 
47: interface IStrategy {
48:     function totalShares() external view returns (uint256);
49:     function rate(uint256) external view returns (uint256);
50:     function exit(address) external;
51:     function move(address) external;
52: }
53: 
54: interface IStrategyProxy {
55:     function exec(address) external view returns (bool);
56:     function mint(address, uint256) external returns (uint256);
57:     function burn(address, uint256) external returns (uint256);
58:     function kill(address, uint256, address) external returns (bytes memory);
59: }
60: 
61: interface IWhitelist {
62:     function check(address) external view returns (bool);
63: }
64: 
65: contract Investor {
66:     IStore public store;
67:     IHelper public helper;
68:     IWhitelist public whitelist;
69:     IStrategyProxy public strategyProxy;
70:     uint256 public slippage = 200;
71:     uint256 public performanceFee = 2000;
```


```solidity
📁 File: InvestorStrategyProxy.sol

4: interface IERC20 { 
5:     function approve(address, uint256) external returns (bool);
6:     function transfer(address, uint256) external returns (bool);
7: }
8: 
9: interface IStrategy {
10:     function mint(uint256 amount) external returns (uint256 shares);
11:     function burn(uint256 shares) external returns (uint256 amount);
12:     function kill(uint256 shares, address to) external returns (bytes memory);
13: }
14: 
15: contract InvestorStrategyProxy {
16:     IERC20 public asset;
17:     mapping(address => bool) public exec;
18: 
19:     event File(bytes32 indexed what, address data);
20: 
21:     error InvalidFile();
```


```solidity
📁 File: PositionManager.sol

7: interface IERC20 { 
8:     function decimals() external view returns (uint8);
9:     function balanceOf(address) external view returns (uint256);
10:     function approve(address, uint256) external returns (bool);
11:     function transfer(address, uint256) external returns (bool);
12:     function transferFrom(address, address, uint256) external returns (bool);
13: }

15: interface IOracle { 
16:     function latestAnswer() external view returns (int256);
17:     function decimals() external view returns (uint8);
18: }
19: 
20: interface IPool {
21:     function asset() external view returns (address);
22:     function oracle() external view returns (address);
23:     function getUpdatedIndex() external view returns (uint256);
24: }
25: 
26: interface IStrategy {
27:     function name() external view returns (string memory);
28:     function rate(uint256 shares) external view returns (uint256);
29: }
30: 
31: interface IInvestor {
32:     struct Strategy {
33:       address implementation;
34:       uint256 cap;
35:       uint256 status;
36:     }
37:     struct Position {

55: interface IWhitelist { 
56:     function check(address) external view returns (bool);
57: }
58: 
59: interface ERC721TokenReceiver {
60:     function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4);
61: }
62: 
63: /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)
64: contract PositionManager {
65:     string public constant name = "Rodeo V2 Position";
66:     string public constant symbol = "RP2";
67:     IInvestor public investor;
68:     IWhitelist public whitelist;
69:     mapping(address => bool) public exec;
70:     mapping(uint256 => address) internal _ownerOf;
```


```solidity
📁 File: Store.sol

4: contract Store { 
5:     mapping(address => bool) public exec;
6:     mapping(bytes32 => uint256) public uintValues;
7:     mapping(bytes32 => int256) public intValues;
8:     mapping(bytes32 => address) public addressValues;
9:     mapping(bytes32 => bool) public boolValues;
10:     mapping(bytes32 => string) public stringValues;
```


```solidity
📁 File: StrategyCamelotV3.sol

7: contract StrategyCamelotV3 { 
8:     string public name;
9:     uint256 public totalShares = 1_000_000;
10:     uint256 public slippage = 500;
11:     bool internal entered;
12:     IERC20 public asset;
13:     IStrategyHelper public strategyHelper;

414: interface IERC20 { 
415:     function symbol() external view returns (string memory);
416:     function balanceOf(address) external view returns (uint256);
417:     function approve(address, uint256) external;
418:     function transfer(address, uint256) external;
419:     function transferFrom(address, address, uint256) external;
420: }

422: interface IStrategyHelper { 
423:     function value(address, uint256) external view returns (uint256);
424:     function convert(address, address, uint256) external view returns (uint256);
425:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);
426: }
427: 
428: interface IStrategyHelperUniswapV3 {
429:     function swap(address ast, bytes calldata path, uint256 amt, uint256 min, address to) external;
430: }
431: 
432: interface IUniProxy {
433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares);
434:     function getDepositAmount(address pos, address token, uint256 deposit) external view returns (uint256 amountStart, uint256 amountEnd);
435: }
436: 
437: interface IQuoter {
438:     function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);
439: }
440: 
441: interface IHypervisor is IERC20 {
442:     function withdraw(uint256 shares, address to, address from, uint256[4] memory minAmounts) external returns (uint256 amount0, uint256 amount1);
443:     function pool() external view returns (IAlgebraPool);
444:     function token0() external view returns (IERC20);
445:     function token1() external view returns (IERC20);
446:     function totalSupply() external view returns (uint256);
447:     function baseLower() external view returns (int24);

453: interface INFTPool { 
454:     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;
455:     function createPosition(uint256 amount, uint256 lockDuration) external;
456:     function addToPosition(uint256 tokenId, uint256 amountToAdd) external;
457:     function withdrawFromPosition(uint256 tokenId, uint256 amountToWithdraw) external;
458:     function harvestPosition(uint256 tokenId) external;
459:     function getStakingPosition(uint256 tokenId) external view returns (

466: interface INitroPool { 
467:     function harvest() external;
468:     function withdraw(uint256 tokenId) external;
469: }
470: 
471: interface IAlgebraPool {
472:     function token0() external view returns (address);
473:     function token1() external view returns (address);
474:     function getTimepoints(uint32[] calldata secondsAgos) external view returns (
475:         int56[] memory tickCumulatives,
476:         uint160[] memory secondsPerLiquidityCumulatives,
477:         uint112[] memory volatilityCumulatives,

490: interface IXGrail { 
491:   function redeem(uint256 xGrailAmount, uint256 duration) external;
492:   function finalizeRedeem(uint256 redeemIndex) external;
493: }
494: 
```


```solidity
📁 File: StrategyGMXGM.sol

4: contract StrategyGMXGM { 
5:     string public name;
6:     uint256 public totalShares = 1_000_000;
7:     uint256 public slippage = 500;
8:     bool internal entered;
9:     IERC20 public asset;
10:     IStrategyHelper public strategyHelper;

363: interface IERC20 { 
364:     function symbol() external view returns (string memory);
365:     function decimals() external view returns (uint8);
366:     function balanceOf(address) external view returns (uint256);
367:     function approve(address, uint256) external;
368:     function transfer(address, uint256) external;
369:     function transferFrom(address, address, uint256) external;

372: interface IStrategyHelper { 
373:     function price(address) external view returns (uint256);
374:     function value(address, uint256) external view returns (uint256);
375:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);
376: }
377: 
378: interface IHandler {
379:     function depositVault() external view returns (address);
380:     function withdrawalVault() external view returns (address);
381: }
382: 
383: interface IPriceFeed {
384:     function latestRoundData() external view returns (
385:         uint80 roundId,
386:         int256 answer,
387:         uint256 startedAt,
388:         uint256 updatedAt,
389:         uint80 answeredInRound

393: interface IDataStore { 
394:     function getUint(bytes32 key) external view returns (uint256);
395:     function getAddress(bytes32 key) external view returns (address);
396:     function getBytes32(bytes32 key) external view returns (bytes32);
397: }
398: 
399: interface IExchangeRouter {
400:     struct CreateDepositParams {
401:         address receiver;
402:         address callbackContract;
403:         address uiFeeReceiver;
404:         address market;
405:         address initialLongToken;

437: interface IMarket { 
438:     struct Prices {
439:         IPrice.Props indexTokenPrice;
440:         IPrice.Props longTokenPrice;
441:         IPrice.Props shortTokenPrice;
442:     }
443: 

454: interface IPrice { 
455:     struct Props {
456:         uint256 min;
457:         uint256 max;
458:     }
459: }
460: 
461: interface IMarketPoolValueInfo {
462:     struct Props {
463:         int256 poolValue;
464:         int256 longPnl;
465:         int256 shortPnl;
466:         int256 netPnl;
467:         uint256 longTokenAmount;

477: interface IReader { 
478:     function getMarket(address dataStore, address key) external view returns (IMarket.Props memory);
479:     function getMarketTokenPrice(
480:         address dataStore,
481:         IMarket.Props memory market,
482:         IPrice.Props memory indexTokenPrice,
483:         IPrice.Props memory longTokenPrice,

497: interface IDeposit { 
498:     struct Props {
499:         Addresses addresses;
500:         Numbers numbers;
501:         Flags flags;
502:     }
503: 

530: interface IWithdrawal { 
531:     struct Props {
532:         Addresses addresses;
533:         Numbers numbers;
534:         Flags flags;
535:     }
536: 

561: interface IEventUtils { 
562:     struct EventLogData {
563:         AddressItems addressItems;
564:         UintItems uintItems;
565:         IntItems intItems;
566:         BoolItems boolItems;
567:         Bytes32Items bytes32Items;
```


```solidity
📁 File: StrategySushiswap.sol

4: contract StrategySushiswap { 
5:     string public name;
6:     uint256 public totalShares = 1_000_000;
7:     uint256 public slippage = 500;
8:     bool internal entered;
9:     IERC20 public asset;
10:     IStrategyHelper public strategyHelper;

253: interface IERC20 { 
254:     function symbol() external view returns (string memory);
255:     function decimals() external view returns (uint8);
256:     function balanceOf(address) external view returns (uint256);
257:     function approve(address, uint256) external returns (bool);
258:     function transfer(address, uint256) external returns (bool);
259:     function transferFrom(address, address, uint256) external returns (bool);

262: interface IStrategyHelper { 
263:     function price(address) external view returns (uint256);
264:     function value(address, uint256) external view returns (uint256);
265:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);
266: }
267: 
268: interface IUniswapV2Pair {
269:     function token0() external view returns (address);
270:     function token1() external view returns (address);
271:     function totalSupply() external view returns (uint256);
272:     function getReserves() external view returns (uint112, uint112, uint32);
273:     function price0CumulativeLast() external view returns (uint256);
274:     function price1CumulativeLast() external view returns (uint256);

281: interface ISushiswapMiniChefV2 { 
282:     function SUSHI() external view returns (address);
283:     function lpToken(uint256) external view returns (address);
284:     function pendingSushi(uint256, address) external view returns (uint256);
285:     function userInfo(uint256, address) external view returns (uint256, int256);
286:     function deposit(uint256, uint256, address) external;
287:     function withdraw(uint256, uint256, address) external;
```


```solidity
📁 File: UtilFarmingBalances.sol

4: interface IInvestor { 
5:     function nextPosition() external view returns (uint256);
6:     function positions(uint256) external view returns (address, address, uint256, uint256, uint256, uint256, uint256);
7: }
8: 
9: interface IPositionManager {
10:     function ownerOf(uint256) external view returns (address);
11: }
12: 
13: contract UtilFarmingBalances {
14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) {
15:         IInvestor i = IInvestor(0x8accf43Dd31DfCd4919cc7d65912A475BfA60369);
16:         IPositionManager pm = IPositionManager(0x5e4d7F61cC608485A2E4F105713D26D58a9D0cF6);
17:         uint256 max = i.nextPosition();
18:         address[] memory users = new address[](max-start);
19:         uint256[] memory balances = new uint256[](max-start);
```


```solidity
📁 File: Whitelist.sol

4: contract Whitelist { 
5:     mapping(address => bool) public exec;
6:     mapping(address => bool) public whitelist;
7: 
8:     event File(bytes32 indexed what, address data);
9:     event BatchWhitelist(address[] addresses, bool status);
10: 
```


</details>


---
### [NC&#x2011;74] NatSpec: Contract declarations should have `@title` tags
<details>
<summary><i>There are 64 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

3:  
4: interface IERC20 {
5:     function transfer(address, uint256) external returns (bool);

7:  
8: contract Bank {
9:     mapping(address => bool) public exec;
```


```solidity
📁 File: Helper.sol

3:  
4: interface IERC20 {
5:     function balanceOf(address) external view returns (uint256);

9:  
10: interface IInvestor {
11:     function killRepayment(uint256) external returns (uint256);

14:  
15: interface IAavePool {
16:     function flashLoanSimple(address receiver, address asset, uint256 amount, bytes calldata params, uint16 referrer) external;

18:  
19: interface IStrategyHelper {
20:     function swap(address, address, uint256, uint256, address) external returns (uint256);

22:  
23: interface ISushi {
24:     function token0() external view returns (address);

28:  
29: contract Helper {
30:     IInvestor public investor;
```


```solidity
📁 File: Investor.sol

3:  
4: interface IERC20 {
5:     function decimals() external view returns (uint8);

11:  
12: interface IOracle {
13:     function decimals() external view returns (uint8);

16:  
17: interface IStore {
18:     function exec(address) external view returns (bool);

25:  
26: interface IBank {
27:     function exec(address) external view returns (bool);

30:  
31: interface IPool {
32:     function exec(address) external view returns (bool);

39:  
40: interface IHelper {
41:     function price(address) external view returns (uint256);

46:  
47: interface IStrategy {
48:     function totalShares() external view returns (uint256);

53:  
54: interface IStrategyProxy {
55:     function exec(address) external view returns (bool);

60:  
61: interface IWhitelist {
62:     function check(address) external view returns (bool);

64:  
65: contract Investor {
66:     IStore public store;
```


```solidity
📁 File: InvestorStrategyProxy.sol

3:  
4: interface IERC20 {
5:     function approve(address, uint256) external returns (bool);

8:  
9: interface IStrategy {
10:     function mint(uint256 amount) external returns (uint256 shares);

14:  
15: contract InvestorStrategyProxy {
16:     IERC20 public asset;
```


```solidity
📁 File: PositionManager.sol

6:  
7: interface IERC20 {
8:     function decimals() external view returns (uint8);

14:  
15: interface IOracle {
16:     function latestAnswer() external view returns (int256);

19:  
20: interface IPool {
21:     function asset() external view returns (address);

25:  
26: interface IStrategy {
27:     function name() external view returns (string memory);

30:  
31: interface IInvestor {
32:     struct Strategy {

54:  
55: interface IWhitelist {
56:     function check(address) external view returns (bool);

58:  
59: interface ERC721TokenReceiver {
60:     function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4);

63: /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol) 
64: contract PositionManager {
65:     string public constant name = "Rodeo V2 Position";
```


```solidity
📁 File: Store.sol

3:  
4: contract Store {
5:     mapping(address => bool) public exec;
```


```solidity
📁 File: StrategyCamelotV3.sol

6:  
7: contract StrategyCamelotV3 {
8:     string public name;

413:  
414: interface IERC20 {
415:     function symbol() external view returns (string memory);

421:  
422: interface IStrategyHelper {
423:     function value(address, uint256) external view returns (uint256);

427:  
428: interface IStrategyHelperUniswapV3 {
429:     function swap(address ast, bytes calldata path, uint256 amt, uint256 min, address to) external;

431:  
432: interface IUniProxy {
433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares);

436:  
437: interface IQuoter {
438:     function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);

440:  
441: interface IHypervisor is IERC20 {
442:     function withdraw(uint256 shares, address to, address from, uint256[4] memory minAmounts) external returns (uint256 amount0, uint256 amount1);

452:  
453: interface INFTPool {
454:     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;

465:  
466: interface INitroPool {
467:     function harvest() external;

470:  
471: interface IAlgebraPool {
472:     function token0() external view returns (address);

489:  
490: interface IXGrail {
491:   function redeem(uint256 xGrailAmount, uint256 duration) external;
```


```solidity
📁 File: StrategyGMXGM.sol

3:  
4: contract StrategyGMXGM {
5:     string public name;

362:  
363: interface IERC20 {
364:     function symbol() external view returns (string memory);

371:  
372: interface IStrategyHelper {
373:     function price(address) external view returns (uint256);

377:  
378: interface IHandler {
379:     function depositVault() external view returns (address);

382:  
383: interface IPriceFeed {
384:     function latestRoundData() external view returns (

392:  
393: interface IDataStore {
394:     function getUint(bytes32 key) external view returns (uint256);

398:  
399: interface IExchangeRouter {
400:     struct CreateDepositParams {

436:  
437: interface IMarket {
438:     struct Prices {

453:  
454: interface IPrice {
455:     struct Props {

460:  
461: interface IMarketPoolValueInfo {
462:     struct Props {

476:  
477: interface IReader {
478:     function getMarket(address dataStore, address key) external view returns (IMarket.Props memory);

496:  
497: interface IDeposit {
498:     struct Props {

529:  
530: interface IWithdrawal {
531:     struct Props {

560:  
561: interface IEventUtils {
562:     struct EventLogData {
```


```solidity
📁 File: StrategySushiswap.sol

3:  
4: contract StrategySushiswap {
5:     string public name;

252:  
253: interface IERC20 {
254:     function symbol() external view returns (string memory);

261:  
262: interface IStrategyHelper {
263:     function price(address) external view returns (uint256);

267:  
268: interface IUniswapV2Pair {
269:     function token0() external view returns (address);

280:  
281: interface ISushiswapMiniChefV2 {
282:     function SUSHI() external view returns (address);
```


```solidity
📁 File: UtilFarmingBalances.sol

3:  
4: interface IInvestor {
5:     function nextPosition() external view returns (uint256);

8:  
9: interface IPositionManager {
10:     function ownerOf(uint256) external view returns (address);

12:  
13: contract UtilFarmingBalances {
14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) {
```


```solidity
📁 File: Whitelist.sol

3:  
4: contract Whitelist {
5:     mapping(address => bool) public exec;
```


</details>


---
### [NC&#x2011;75] NatSpec: Contract declarations should have NatSpec descriptions
It is recommended that Solidity libraries and contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.

<details>
<summary><i>There are 63 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

4: interface IERC20 { 
5:     function transfer(address, uint256) external returns (bool);
6: }
7: 
8: contract Bank {
9:     mapping(address => bool) public exec;
10: 
11:     event File(bytes32 indexed what, address data);
12: 
13:     error InvalidFile();
14:     error Unauthorized();
```


```solidity
📁 File: Helper.sol

4: interface IERC20 { 
5:     function balanceOf(address) external view returns (uint256);
6:     function approve(address, uint256) external;
7:     function transfer(address, uint256) external;
8: }
9: 
10: interface IInvestor {
11:     function killRepayment(uint256) external returns (uint256);
12:     function kill(uint256 id) external returns (address, bytes memory);
13: }
14: 
15: interface IAavePool {
16:     function flashLoanSimple(address receiver, address asset, uint256 amount, bytes calldata params, uint16 referrer) external;
17: }
18: 
19: interface IStrategyHelper {
20:     function swap(address, address, uint256, uint256, address) external returns (uint256);
21: }
22: 
23: interface ISushi {
24:     function token0() external view returns (address);
25:     function token1() external view returns (address);
26:     function burn(address) external;
27: }
28: 
29: contract Helper {
30:     IInvestor public investor;
31:     IERC20 public asset;
32:     IAavePool public lender; // 0x794a61358D6845594F94dc1DB02A252b5b4814aD
33:     IStrategyHelper public sh;
34:     uint256 public slippage = 2500;
35: 
```


```solidity
📁 File: Investor.sol

4: interface IERC20 { 
5:     function decimals() external view returns (uint8);
6:     function balanceOf(address) external view returns (uint256);
7:     function approve(address, uint256) external;
8:     function transfer(address, uint256) external returns (bool);
9:     function transferFrom(address, address, uint256) external returns (bool);
10: }

12: interface IOracle { 
13:     function decimals() external view returns (uint8);
14:     function latestAnswer() external view returns (int256);
15: }
16: 
17: interface IStore {
18:     function exec(address) external view returns (bool);
19:     function getUint(bytes32) external view returns (uint256);
20:     function getAddress(bytes32) external view returns (address);
21:     function setUint(bytes32, uint256) external;
22:     function setUintDelta(bytes32, int256) external returns (uint256);
23:     function setAddress(bytes32, address) external returns (address);

26: interface IBank { 
27:     function exec(address) external view returns (bool);
28:     function transfer(address, address, uint256) external;
29: }
30: 
31: interface IPool {
32:     function exec(address) external view returns (bool);
33:     function asset() external view returns (address);
34:     function oracle() external view returns (address);
35:     function getUpdatedIndex() external view returns (uint256);
36:     function borrow(uint256) external returns (uint256);
37:     function repay(uint256) external returns (uint256);

40: interface IHelper { 
41:     function price(address) external view returns (uint256);
42:     function value(address, uint256) external view returns (uint256);
43:     function convert(address, address, uint256) external view returns (uint256);
44:     function swap(address, address, uint256, uint256, address) external returns (uint256);
45: }
46: 
47: interface IStrategy {
48:     function totalShares() external view returns (uint256);
49:     function rate(uint256) external view returns (uint256);
50:     function exit(address) external;
51:     function move(address) external;
52: }
53: 
54: interface IStrategyProxy {
55:     function exec(address) external view returns (bool);
56:     function mint(address, uint256) external returns (uint256);
57:     function burn(address, uint256) external returns (uint256);
58:     function kill(address, uint256, address) external returns (bytes memory);
59: }
60: 
61: interface IWhitelist {
62:     function check(address) external view returns (bool);
63: }
64: 
65: contract Investor {
66:     IStore public store;
67:     IHelper public helper;
68:     IWhitelist public whitelist;
69:     IStrategyProxy public strategyProxy;
70:     uint256 public slippage = 200;
71:     uint256 public performanceFee = 2000;
```


```solidity
📁 File: InvestorStrategyProxy.sol

4: interface IERC20 { 
5:     function approve(address, uint256) external returns (bool);
6:     function transfer(address, uint256) external returns (bool);
7: }
8: 
9: interface IStrategy {
10:     function mint(uint256 amount) external returns (uint256 shares);
11:     function burn(uint256 shares) external returns (uint256 amount);
12:     function kill(uint256 shares, address to) external returns (bytes memory);
13: }
14: 
15: contract InvestorStrategyProxy {
16:     IERC20 public asset;
17:     mapping(address => bool) public exec;
18: 
19:     event File(bytes32 indexed what, address data);
20: 
21:     error InvalidFile();
```


```solidity
📁 File: PositionManager.sol

7: interface IERC20 { 
8:     function decimals() external view returns (uint8);
9:     function balanceOf(address) external view returns (uint256);
10:     function approve(address, uint256) external returns (bool);
11:     function transfer(address, uint256) external returns (bool);
12:     function transferFrom(address, address, uint256) external returns (bool);
13: }

15: interface IOracle { 
16:     function latestAnswer() external view returns (int256);
17:     function decimals() external view returns (uint8);
18: }
19: 
20: interface IPool {
21:     function asset() external view returns (address);
22:     function oracle() external view returns (address);
23:     function getUpdatedIndex() external view returns (uint256);
24: }
25: 
26: interface IStrategy {
27:     function name() external view returns (string memory);
28:     function rate(uint256 shares) external view returns (uint256);
29: }
30: 
31: interface IInvestor {
32:     struct Strategy {
33:       address implementation;
34:       uint256 cap;
35:       uint256 status;
36:     }
37:     struct Position {

55: interface IWhitelist { 
56:     function check(address) external view returns (bool);
57: }
58: 
59: interface ERC721TokenReceiver {
60:     function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4);
61: }
62: 
63: /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)
64: contract PositionManager {
65:     string public constant name = "Rodeo V2 Position";
```


```solidity
📁 File: Store.sol

4: contract Store { 
5:     mapping(address => bool) public exec;
6:     mapping(bytes32 => uint256) public uintValues;
7:     mapping(bytes32 => int256) public intValues;
8:     mapping(bytes32 => address) public addressValues;
9:     mapping(bytes32 => bool) public boolValues;
10:     mapping(bytes32 => string) public stringValues;
```


```solidity
📁 File: StrategyCamelotV3.sol

7: contract StrategyCamelotV3 { 
8:     string public name;
9:     uint256 public totalShares = 1_000_000;
10:     uint256 public slippage = 500;
11:     bool internal entered;
12:     IERC20 public asset;
13:     IStrategyHelper public strategyHelper;

414: interface IERC20 { 
415:     function symbol() external view returns (string memory);
416:     function balanceOf(address) external view returns (uint256);
417:     function approve(address, uint256) external;
418:     function transfer(address, uint256) external;
419:     function transferFrom(address, address, uint256) external;
420: }

422: interface IStrategyHelper { 
423:     function value(address, uint256) external view returns (uint256);
424:     function convert(address, address, uint256) external view returns (uint256);
425:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);
426: }
427: 
428: interface IStrategyHelperUniswapV3 {
429:     function swap(address ast, bytes calldata path, uint256 amt, uint256 min, address to) external;
430: }
431: 
432: interface IUniProxy {
433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares);
434:     function getDepositAmount(address pos, address token, uint256 deposit) external view returns (uint256 amountStart, uint256 amountEnd);
435: }
436: 
437: interface IQuoter {
438:     function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);
439: }
440: 
441: interface IHypervisor is IERC20 {
442:     function withdraw(uint256 shares, address to, address from, uint256[4] memory minAmounts) external returns (uint256 amount0, uint256 amount1);
443:     function pool() external view returns (IAlgebraPool);
444:     function token0() external view returns (IERC20);
445:     function token1() external view returns (IERC20);
446:     function totalSupply() external view returns (uint256);
447:     function baseLower() external view returns (int24);

453: interface INFTPool { 
454:     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;
455:     function createPosition(uint256 amount, uint256 lockDuration) external;
456:     function addToPosition(uint256 tokenId, uint256 amountToAdd) external;
457:     function withdrawFromPosition(uint256 tokenId, uint256 amountToWithdraw) external;
458:     function harvestPosition(uint256 tokenId) external;
459:     function getStakingPosition(uint256 tokenId) external view returns (

466: interface INitroPool { 
467:     function harvest() external;
468:     function withdraw(uint256 tokenId) external;
469: }
470: 
471: interface IAlgebraPool {
472:     function token0() external view returns (address);
473:     function token1() external view returns (address);
474:     function getTimepoints(uint32[] calldata secondsAgos) external view returns (
475:         int56[] memory tickCumulatives,
476:         uint160[] memory secondsPerLiquidityCumulatives,
477:         uint112[] memory volatilityCumulatives,

490: interface IXGrail { 
491:   function redeem(uint256 xGrailAmount, uint256 duration) external;
492:   function finalizeRedeem(uint256 redeemIndex) external;
493: }
494: 
```


```solidity
📁 File: StrategyGMXGM.sol

4: contract StrategyGMXGM { 
5:     string public name;
6:     uint256 public totalShares = 1_000_000;
7:     uint256 public slippage = 500;
8:     bool internal entered;
9:     IERC20 public asset;
10:     IStrategyHelper public strategyHelper;

363: interface IERC20 { 
364:     function symbol() external view returns (string memory);
365:     function decimals() external view returns (uint8);
366:     function balanceOf(address) external view returns (uint256);
367:     function approve(address, uint256) external;
368:     function transfer(address, uint256) external;
369:     function transferFrom(address, address, uint256) external;

372: interface IStrategyHelper { 
373:     function price(address) external view returns (uint256);
374:     function value(address, uint256) external view returns (uint256);
375:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);
376: }
377: 
378: interface IHandler {
379:     function depositVault() external view returns (address);
380:     function withdrawalVault() external view returns (address);
381: }
382: 
383: interface IPriceFeed {
384:     function latestRoundData() external view returns (
385:         uint80 roundId,
386:         int256 answer,
387:         uint256 startedAt,
388:         uint256 updatedAt,
389:         uint80 answeredInRound

393: interface IDataStore { 
394:     function getUint(bytes32 key) external view returns (uint256);
395:     function getAddress(bytes32 key) external view returns (address);
396:     function getBytes32(bytes32 key) external view returns (bytes32);
397: }
398: 
399: interface IExchangeRouter {
400:     struct CreateDepositParams {
401:         address receiver;
402:         address callbackContract;
403:         address uiFeeReceiver;
404:         address market;
405:         address initialLongToken;

437: interface IMarket { 
438:     struct Prices {
439:         IPrice.Props indexTokenPrice;
440:         IPrice.Props longTokenPrice;
441:         IPrice.Props shortTokenPrice;
442:     }
443: 

454: interface IPrice { 
455:     struct Props {
456:         uint256 min;
457:         uint256 max;
458:     }
459: }
460: 
461: interface IMarketPoolValueInfo {
462:     struct Props {
463:         int256 poolValue;
464:         int256 longPnl;
465:         int256 shortPnl;
466:         int256 netPnl;
467:         uint256 longTokenAmount;

477: interface IReader { 
478:     function getMarket(address dataStore, address key) external view returns (IMarket.Props memory);
479:     function getMarketTokenPrice(
480:         address dataStore,
481:         IMarket.Props memory market,
482:         IPrice.Props memory indexTokenPrice,
483:         IPrice.Props memory longTokenPrice,

497: interface IDeposit { 
498:     struct Props {
499:         Addresses addresses;
500:         Numbers numbers;
501:         Flags flags;
502:     }
503: 

530: interface IWithdrawal { 
531:     struct Props {
532:         Addresses addresses;
533:         Numbers numbers;
534:         Flags flags;
535:     }
536: 

561: interface IEventUtils { 
562:     struct EventLogData {
563:         AddressItems addressItems;
564:         UintItems uintItems;
565:         IntItems intItems;
566:         BoolItems boolItems;
567:         Bytes32Items bytes32Items;
```


```solidity
📁 File: StrategySushiswap.sol

4: contract StrategySushiswap { 
5:     string public name;
6:     uint256 public totalShares = 1_000_000;
7:     uint256 public slippage = 500;
8:     bool internal entered;
9:     IERC20 public asset;
10:     IStrategyHelper public strategyHelper;

253: interface IERC20 { 
254:     function symbol() external view returns (string memory);
255:     function decimals() external view returns (uint8);
256:     function balanceOf(address) external view returns (uint256);
257:     function approve(address, uint256) external returns (bool);
258:     function transfer(address, uint256) external returns (bool);
259:     function transferFrom(address, address, uint256) external returns (bool);

262: interface IStrategyHelper { 
263:     function price(address) external view returns (uint256);
264:     function value(address, uint256) external view returns (uint256);
265:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);
266: }
267: 
268: interface IUniswapV2Pair {
269:     function token0() external view returns (address);
270:     function token1() external view returns (address);
271:     function totalSupply() external view returns (uint256);
272:     function getReserves() external view returns (uint112, uint112, uint32);
273:     function price0CumulativeLast() external view returns (uint256);
274:     function price1CumulativeLast() external view returns (uint256);

281: interface ISushiswapMiniChefV2 { 
282:     function SUSHI() external view returns (address);
283:     function lpToken(uint256) external view returns (address);
284:     function pendingSushi(uint256, address) external view returns (uint256);
285:     function userInfo(uint256, address) external view returns (uint256, int256);
286:     function deposit(uint256, uint256, address) external;
287:     function withdraw(uint256, uint256, address) external;
```


```solidity
📁 File: UtilFarmingBalances.sol

4: interface IInvestor { 
5:     function nextPosition() external view returns (uint256);
6:     function positions(uint256) external view returns (address, address, uint256, uint256, uint256, uint256, uint256);
7: }
8: 
9: interface IPositionManager {
10:     function ownerOf(uint256) external view returns (address);
11: }
12: 
13: contract UtilFarmingBalances {
14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) {
15:         IInvestor i = IInvestor(0x8accf43Dd31DfCd4919cc7d65912A475BfA60369);
16:         IPositionManager pm = IPositionManager(0x5e4d7F61cC608485A2E4F105713D26D58a9D0cF6);
17:         uint256 max = i.nextPosition();
18:         address[] memory users = new address[](max-start);
19:         uint256[] memory balances = new uint256[](max-start);
```


```solidity
📁 File: Whitelist.sol

4: contract Whitelist { 
5:     mapping(address => bool) public exec;
6:     mapping(address => bool) public whitelist;
7: 
8:     event File(bytes32 indexed what, address data);
9:     event BatchWhitelist(address[] addresses, bool status);
10: 
```


</details>


---
### [NC&#x2011;76] NatSpec: Error declarations should have `@notice` tags
`@notice` is used to explain to end users what the error does, and the compiler interprets `///` or `/**` comments as this tag if one was't explicitly provided

<details>
<summary><i>There are 53 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

13:     error InvalidFile(); 
14:     error Unauthorized();
15:     error TransferFailed();
```


```solidity
📁 File: Investor.sol

108:     error NotOwner(); 
109:     error InvalidFile();
110:     error WrongStatus();
111:     error NoReentering();
112:     error Unauthorized();
113:     error NotWhitelisted();
114:     error TransferFailed();
115:     error StrategyClosed();
116:     error StrategyExists();
117:     error StrategyOverCap();
118:     error UnknownStrategy();
119:     error UnknownCollateral();
120:     error CollateralOverCap();
121:     error InvalidParameters();
122:     error Undercollateralized();
123:     error NoEditingInSameBlock();
124:     error StrategyUninitialized();
125:     error PositionNotLiquidatable();
```


```solidity
📁 File: InvestorStrategyProxy.sol

21:     error InvalidFile(); 
22:     error Unauthorized();
```


```solidity
📁 File: PositionManager.sol

81:     error InvalidFile(); 
82:     error Unauthorized();
83:     error TransferFailed();
84:     error NotWhitelisted();
```


```solidity
📁 File: Store.sol

22:     error InvalidFile(); 
23:     error Unauthorized();
24:     error OverOrUnderflow();
```


```solidity
📁 File: StrategyCamelotV3.sol

39:     error NotKeeper(); 
40:     error InvalidFile();
41:     error NoReentering();
42:     error Unauthorized();
43:     error PriceSlipped();
44:     error WrongTargetAsset();
45:     error TwapPeriodTooLong();
46:     error TokenIdNeededFirst();
```


```solidity
📁 File: StrategyGMXGM.sol

38:     error NotKeeper(); 
39:     error InvalidFile();
40:     error NoReentering();
41:     error Unauthorized();
42:     error NotGMX();
43:     error BadToken();
44:     error ActionPending();
45:     error ErrorSendingETH();
46:     error WrongReserveRatio();
```


```solidity
📁 File: StrategySushiswap.sol

24:     error NotKeeper(); 
25:     error InvalidFile();
26:     error NoReentering();
27:     error Unauthorized();
```


```solidity
📁 File: Whitelist.sol

11:     error InvalidFile(); 
12:     error Unauthorized();
```


</details>


---
### [NC&#x2011;77] NatSpec: Error declarations should have NatSpec descriptions
It is recommended that errors are fully annotated using NatSpec. It is clearly stated in the Solidity official documentation.

<details>
<summary><i>There are 53 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

13:     error InvalidFile(); 
14:     error Unauthorized();
15:     error TransferFailed();
```


```solidity
📁 File: Investor.sol

108:     error NotOwner(); 
109:     error InvalidFile();
110:     error WrongStatus();
111:     error NoReentering();
112:     error Unauthorized();
113:     error NotWhitelisted();
114:     error TransferFailed();
115:     error StrategyClosed();
116:     error StrategyExists();
117:     error StrategyOverCap();
118:     error UnknownStrategy();
119:     error UnknownCollateral();
120:     error CollateralOverCap();
121:     error InvalidParameters();
122:     error Undercollateralized();
123:     error NoEditingInSameBlock();
124:     error StrategyUninitialized();
125:     error PositionNotLiquidatable();
```


```solidity
📁 File: InvestorStrategyProxy.sol

21:     error InvalidFile(); 
22:     error Unauthorized();
```


```solidity
📁 File: PositionManager.sol

81:     error InvalidFile(); 
82:     error Unauthorized();
83:     error TransferFailed();
84:     error NotWhitelisted();
```


```solidity
📁 File: Store.sol

22:     error InvalidFile(); 
23:     error Unauthorized();
24:     error OverOrUnderflow();
```


```solidity
📁 File: StrategyCamelotV3.sol

39:     error NotKeeper(); 
40:     error InvalidFile();
41:     error NoReentering();
42:     error Unauthorized();
43:     error PriceSlipped();
44:     error WrongTargetAsset();
45:     error TwapPeriodTooLong();
46:     error TokenIdNeededFirst();
```


```solidity
📁 File: StrategyGMXGM.sol

38:     error NotKeeper(); 
39:     error InvalidFile();
40:     error NoReentering();
41:     error Unauthorized();
42:     error NotGMX();
43:     error BadToken();
44:     error ActionPending();
45:     error ErrorSendingETH();
46:     error WrongReserveRatio();
```


```solidity
📁 File: StrategySushiswap.sol

24:     error NotKeeper(); 
25:     error InvalidFile();
26:     error NoReentering();
27:     error Unauthorized();
```


```solidity
📁 File: Whitelist.sol

11:     error InvalidFile(); 
12:     error Unauthorized();
```


</details>


---
### [NC&#x2011;78] NatSpec: Error missing NatSpec `@dev` tag
<details>
<summary><i>There are 53 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

12:  
13:     error InvalidFile();
14:     error Unauthorized();
15:     error TransferFailed();
16: 
```


```solidity
📁 File: Investor.sol

107:  
108:     error NotOwner();
109:     error InvalidFile();
110:     error WrongStatus();
111:     error NoReentering();
112:     error Unauthorized();
113:     error NotWhitelisted();
114:     error TransferFailed();
115:     error StrategyClosed();
116:     error StrategyExists();
117:     error StrategyOverCap();
118:     error UnknownStrategy();
119:     error UnknownCollateral();
120:     error CollateralOverCap();
121:     error InvalidParameters();
122:     error Undercollateralized();
123:     error NoEditingInSameBlock();
124:     error StrategyUninitialized();
125:     error PositionNotLiquidatable();
126: 
```


```solidity
📁 File: InvestorStrategyProxy.sol

20:  
21:     error InvalidFile();
22:     error Unauthorized();
23: 
```


```solidity
📁 File: PositionManager.sol

80:  
81:     error InvalidFile();
82:     error Unauthorized();
83:     error TransferFailed();
84:     error NotWhitelisted();
85: 
```


```solidity
📁 File: Store.sol

21:  
22:     error InvalidFile();
23:     error Unauthorized();
24:     error OverOrUnderflow();
25: 
```


```solidity
📁 File: StrategyCamelotV3.sol

38:  
39:     error NotKeeper();
40:     error InvalidFile();
41:     error NoReentering();
42:     error Unauthorized();
43:     error PriceSlipped();
44:     error WrongTargetAsset();
45:     error TwapPeriodTooLong();
46:     error TokenIdNeededFirst();
47: 
```


```solidity
📁 File: StrategyGMXGM.sol

37:  
38:     error NotKeeper();
39:     error InvalidFile();
40:     error NoReentering();
41:     error Unauthorized();
42:     error NotGMX();
43:     error BadToken();
44:     error ActionPending();
45:     error ErrorSendingETH();
46:     error WrongReserveRatio();
47: 
```


```solidity
📁 File: StrategySushiswap.sol

23:  
24:     error NotKeeper();
25:     error InvalidFile();
26:     error NoReentering();
27:     error Unauthorized();
28: 
```


```solidity
📁 File: Whitelist.sol

10:  
11:     error InvalidFile();
12:     error Unauthorized();
13: 
```


</details>


---
### [NC&#x2011;79] NatSpec: Event declarations should have `@notice` tags
`@notice` is used to explain to end users what the event emits, and the compiler interprets `///` or `/**` comments as this tag if one was't explicitly provided

<details>
<summary><i>There are 34 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

11:     event File(bytes32 indexed what, address data); 
```


```solidity
📁 File: Investor.sol

100:     event File(bytes32 indexed what, uint256 data); 
101:     event File(bytes32 indexed what, address data);
102:     event Open(uint256 indexed id, uint256 borrow, uint256 collateral, uint256 strategy, address token);
103:     event Edit(uint256 indexed id, int256 borrow, int256 collateral);
104:     event Kill(uint256 indexed id, uint256 borrow, uint256 value, uint256 collateral, uint256 shares, uint256 fee);
105:     event StrategyUpdate(uint256 indexed index, address implementation, uint256 status, uint256 cap);
106:     event CollateralUpdate(address indexed token, uint256 factor, uint256 cap);
```


```solidity
📁 File: InvestorStrategyProxy.sol

19:     event File(bytes32 indexed what, address data); 
```


```solidity
📁 File: PositionManager.sol

76:     event Transfer(address indexed from, address indexed to, uint256 indexed id); 
77:     event Approval(address indexed owner, address indexed spender, uint256 indexed id);
78:     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
79:     event File(bytes32 indexed what, address data);
```


```solidity
📁 File: Store.sol

20:     event File(bytes32 indexed what, address data); 
```


```solidity
📁 File: StrategyCamelotV3.sol

32:     event File(bytes32 indexed what, uint256 data); 
33:     event File(bytes32 indexed what, address data);
34:     event Mint(uint256 amount, uint256 shares);
35:     event Burn(uint256 amount, uint256 shares);
36:     event Kill(uint256 amount, uint256 shares);
37:     event Earn(uint256 tvl, uint256 profit);
```


```solidity
📁 File: StrategyGMXGM.sol

31:     event File(bytes32 indexed what, uint256 data); 
32:     event File(bytes32 indexed what, address data);
33:     event Mint(uint256 amount, uint256 shares);
34:     event Burn(uint256 amount, uint256 shares);
35:     event Kill(uint256 amount, uint256 shares);
36:     event Earn(uint256 tvl, uint256 profit);
```


```solidity
📁 File: StrategySushiswap.sol

17:     event File(bytes32 indexed what, uint256 data); 
18:     event File(bytes32 indexed what, address data);
19:     event Mint(uint256 amount, uint256 shares);
20:     event Burn(uint256 amount, uint256 shares);
21:     event Kill(uint256 amount, uint256 shares);
22:     event Earn(uint256 tvl, uint256 profit);
```


```solidity
📁 File: Whitelist.sol

8:     event File(bytes32 indexed what, address data); 
9:     event BatchWhitelist(address[] addresses, bool status);
```


</details>


---
### [NC&#x2011;80] NatSpec: Event declarations should have NatSpec descriptions
It is recommended that events are fully annotated using NatSpec.

<details>
<summary><i>There are 34 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

11:     event File(bytes32 indexed what, address data); 
```


```solidity
📁 File: Investor.sol

100:     event File(bytes32 indexed what, uint256 data); 
101:     event File(bytes32 indexed what, address data);
102:     event Open(uint256 indexed id, uint256 borrow, uint256 collateral, uint256 strategy, address token);
103:     event Edit(uint256 indexed id, int256 borrow, int256 collateral);
104:     event Kill(uint256 indexed id, uint256 borrow, uint256 value, uint256 collateral, uint256 shares, uint256 fee);
105:     event StrategyUpdate(uint256 indexed index, address implementation, uint256 status, uint256 cap);
106:     event CollateralUpdate(address indexed token, uint256 factor, uint256 cap);
```


```solidity
📁 File: InvestorStrategyProxy.sol

19:     event File(bytes32 indexed what, address data); 
```


```solidity
📁 File: PositionManager.sol

76:     event Transfer(address indexed from, address indexed to, uint256 indexed id); 
77:     event Approval(address indexed owner, address indexed spender, uint256 indexed id);
78:     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
79:     event File(bytes32 indexed what, address data);
```


```solidity
📁 File: Store.sol

20:     event File(bytes32 indexed what, address data); 
```


```solidity
📁 File: StrategyCamelotV3.sol

32:     event File(bytes32 indexed what, uint256 data); 
33:     event File(bytes32 indexed what, address data);
34:     event Mint(uint256 amount, uint256 shares);
35:     event Burn(uint256 amount, uint256 shares);
36:     event Kill(uint256 amount, uint256 shares);
37:     event Earn(uint256 tvl, uint256 profit);
```


```solidity
📁 File: StrategyGMXGM.sol

31:     event File(bytes32 indexed what, uint256 data); 
32:     event File(bytes32 indexed what, address data);
33:     event Mint(uint256 amount, uint256 shares);
34:     event Burn(uint256 amount, uint256 shares);
35:     event Kill(uint256 amount, uint256 shares);
36:     event Earn(uint256 tvl, uint256 profit);
```


```solidity
📁 File: StrategySushiswap.sol

17:     event File(bytes32 indexed what, uint256 data); 
18:     event File(bytes32 indexed what, address data);
19:     event Mint(uint256 amount, uint256 shares);
20:     event Burn(uint256 amount, uint256 shares);
21:     event Kill(uint256 amount, uint256 shares);
22:     event Earn(uint256 tvl, uint256 profit);
```


```solidity
📁 File: Whitelist.sol

8:     event File(bytes32 indexed what, address data); 
9:     event BatchWhitelist(address[] addresses, bool status);
```


</details>


---
### [NC&#x2011;81] NatSpec: Event missing NatSpec `@dev` tag
<details>
<summary><i>There are 34 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

10:  
11:     event File(bytes32 indexed what, address data);
12: 
```


```solidity
📁 File: Investor.sol

99:  
100:     event File(bytes32 indexed what, uint256 data);
101:     event File(bytes32 indexed what, address data);
102:     event Open(uint256 indexed id, uint256 borrow, uint256 collateral, uint256 strategy, address token);
103:     event Edit(uint256 indexed id, int256 borrow, int256 collateral);
104:     event Kill(uint256 indexed id, uint256 borrow, uint256 value, uint256 collateral, uint256 shares, uint256 fee);
105:     event StrategyUpdate(uint256 indexed index, address implementation, uint256 status, uint256 cap);
106:     event CollateralUpdate(address indexed token, uint256 factor, uint256 cap);
107: 
```


```solidity
📁 File: InvestorStrategyProxy.sol

18:  
19:     event File(bytes32 indexed what, address data);
20: 
```


```solidity
📁 File: PositionManager.sol

75:  
76:     event Transfer(address indexed from, address indexed to, uint256 indexed id);
77:     event Approval(address indexed owner, address indexed spender, uint256 indexed id);
78:     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
79:     event File(bytes32 indexed what, address data);
80: 
```


```solidity
📁 File: Store.sol

19:  
20:     event File(bytes32 indexed what, address data);
21: 
```


```solidity
📁 File: StrategyCamelotV3.sol

31:  
32:     event File(bytes32 indexed what, uint256 data);
33:     event File(bytes32 indexed what, address data);
34:     event Mint(uint256 amount, uint256 shares);
35:     event Burn(uint256 amount, uint256 shares);
36:     event Kill(uint256 amount, uint256 shares);
37:     event Earn(uint256 tvl, uint256 profit);
38: 
```


```solidity
📁 File: StrategyGMXGM.sol

30:  
31:     event File(bytes32 indexed what, uint256 data);
32:     event File(bytes32 indexed what, address data);
33:     event Mint(uint256 amount, uint256 shares);
34:     event Burn(uint256 amount, uint256 shares);
35:     event Kill(uint256 amount, uint256 shares);
36:     event Earn(uint256 tvl, uint256 profit);
37: 
```


```solidity
📁 File: StrategySushiswap.sol

16:  
17:     event File(bytes32 indexed what, uint256 data);
18:     event File(bytes32 indexed what, address data);
19:     event Mint(uint256 amount, uint256 shares);
20:     event Burn(uint256 amount, uint256 shares);
21:     event Kill(uint256 amount, uint256 shares);
22:     event Earn(uint256 tvl, uint256 profit);
23: 
```


```solidity
📁 File: Whitelist.sol

7:  
8:     event File(bytes32 indexed what, address data);
9:     event BatchWhitelist(address[] addresses, bool status);
10: 
```


</details>


---
### [NC&#x2011;82] NatSpec: Event missing NatSpec `@param` tag
<details>
<summary><i>There are 34 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit Missing @param for all event parameters
11:     event File(bytes32 indexed what, address data); 
```


```solidity
📁 File: Investor.sol

/// @audit Missing @param for all event parameters
100:     event File(bytes32 indexed what, uint256 data); 
/// @audit Missing @param for all event parameters
101:     event File(bytes32 indexed what, address data);
/// @audit Missing @param for all event parameters
102:     event Open(uint256 indexed id, uint256 borrow, uint256 collateral, uint256 strategy, address token);
/// @audit Missing @param for all event parameters
103:     event Edit(uint256 indexed id, int256 borrow, int256 collateral);
/// @audit Missing @param for all event parameters
104:     event Kill(uint256 indexed id, uint256 borrow, uint256 value, uint256 collateral, uint256 shares, uint256 fee);
/// @audit Missing @param for all event parameters
105:     event StrategyUpdate(uint256 indexed index, address implementation, uint256 status, uint256 cap);
/// @audit Missing @param for all event parameters
106:     event CollateralUpdate(address indexed token, uint256 factor, uint256 cap);
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit Missing @param for all event parameters
19:     event File(bytes32 indexed what, address data); 
```


```solidity
📁 File: PositionManager.sol

/// @audit Missing @param for all event parameters
76:     event Transfer(address indexed from, address indexed to, uint256 indexed id); 
/// @audit Missing @param for all event parameters
77:     event Approval(address indexed owner, address indexed spender, uint256 indexed id);
/// @audit Missing @param for all event parameters
78:     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
/// @audit Missing @param for all event parameters
79:     event File(bytes32 indexed what, address data);
```


```solidity
📁 File: Store.sol

/// @audit Missing @param for all event parameters
20:     event File(bytes32 indexed what, address data); 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit Missing @param for all event parameters
32:     event File(bytes32 indexed what, uint256 data); 
/// @audit Missing @param for all event parameters
33:     event File(bytes32 indexed what, address data);
/// @audit Missing @param for all event parameters
34:     event Mint(uint256 amount, uint256 shares);
/// @audit Missing @param for all event parameters
35:     event Burn(uint256 amount, uint256 shares);
/// @audit Missing @param for all event parameters
36:     event Kill(uint256 amount, uint256 shares);
/// @audit Missing @param for all event parameters
37:     event Earn(uint256 tvl, uint256 profit);
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit Missing @param for all event parameters
31:     event File(bytes32 indexed what, uint256 data); 
/// @audit Missing @param for all event parameters
32:     event File(bytes32 indexed what, address data);
/// @audit Missing @param for all event parameters
33:     event Mint(uint256 amount, uint256 shares);
/// @audit Missing @param for all event parameters
34:     event Burn(uint256 amount, uint256 shares);
/// @audit Missing @param for all event parameters
35:     event Kill(uint256 amount, uint256 shares);
/// @audit Missing @param for all event parameters
36:     event Earn(uint256 tvl, uint256 profit);
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit Missing @param for all event parameters
17:     event File(bytes32 indexed what, uint256 data); 
/// @audit Missing @param for all event parameters
18:     event File(bytes32 indexed what, address data);
/// @audit Missing @param for all event parameters
19:     event Mint(uint256 amount, uint256 shares);
/// @audit Missing @param for all event parameters
20:     event Burn(uint256 amount, uint256 shares);
/// @audit Missing @param for all event parameters
21:     event Kill(uint256 amount, uint256 shares);
/// @audit Missing @param for all event parameters
22:     event Earn(uint256 tvl, uint256 profit);
```


```solidity
📁 File: Whitelist.sol

/// @audit Missing @param for all event parameters
8:     event File(bytes32 indexed what, address data); 
/// @audit Missing @param for all event parameters
9:     event BatchWhitelist(address[] addresses, bool status);
```


</details>


---
### [NC&#x2011;83] NatSpec: File is missing NatSpec Documentation
<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: Store.sol

1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: Whitelist.sol

1: // SPDX-License-Identifier: MIT 
```


</details>


---
### [NC&#x2011;84] NatSpec: Function declarations should have `@notice` tags
`@notice` is used to explain to end users what the function does, and the compiler interprets `///` or `/**` comments as this tag if one was't explicitly provided

<details>
<summary><i>There are 308 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

5:     function transfer(address, uint256) external returns (bool); 

26:     function file(bytes32 what, address data) external auth { 

35:     function transferNative(address to, uint256 amount) external auth { 

41:     function transfer(address token, address to, uint256 amount) external auth { 
```


```solidity
📁 File: Helper.sol

5:     function balanceOf(address) external view returns (uint256); 
6:     function approve(address, uint256) external;
7:     function transfer(address, uint256) external;

11:     function killRepayment(uint256) external returns (uint256); 
12:     function kill(uint256 id) external returns (address, bytes memory);

16:     function flashLoanSimple(address receiver, address asset, uint256 amount, bytes calldata params, uint16 referrer) external; 

20:     function swap(address, address, uint256, uint256, address) external returns (uint256); 

24:     function token0() external view returns (address); 
25:     function token1() external view returns (address);
26:     function burn(address) external;

43:     function kill(uint256 id) external { 

48:     function executeOperation( 
49:       address,
50:       uint256 amount,
51:       uint256 premium,
52:       address initiator,
53:       bytes calldata params
54:     ) external returns (bool) {

76:     function swap(address _fromAsset) internal { 
```


```solidity
📁 File: Investor.sol

5:     function decimals() external view returns (uint8); 
6:     function balanceOf(address) external view returns (uint256);
7:     function approve(address, uint256) external;
8:     function transfer(address, uint256) external returns (bool);
9:     function transferFrom(address, address, uint256) external returns (bool);

13:     function decimals() external view returns (uint8); 
14:     function latestAnswer() external view returns (int256);

18:     function exec(address) external view returns (bool); 
19:     function getUint(bytes32) external view returns (uint256);
20:     function getAddress(bytes32) external view returns (address);
21:     function setUint(bytes32, uint256) external;
22:     function setUintDelta(bytes32, int256) external returns (uint256);
23:     function setAddress(bytes32, address) external returns (address);

27:     function exec(address) external view returns (bool); 
28:     function transfer(address, address, uint256) external;

32:     function exec(address) external view returns (bool); 
33:     function asset() external view returns (address);
34:     function oracle() external view returns (address);
35:     function getUpdatedIndex() external view returns (uint256);
36:     function borrow(uint256) external returns (uint256);
37:     function repay(uint256) external returns (uint256);

41:     function price(address) external view returns (uint256); 
42:     function value(address, uint256) external view returns (uint256);
43:     function convert(address, address, uint256) external view returns (uint256);
44:     function swap(address, address, uint256, uint256, address) external returns (uint256);

48:     function totalShares() external view returns (uint256); 
49:     function rate(uint256) external view returns (uint256);
50:     function exit(address) external;
51:     function move(address) external;

55:     function exec(address) external view returns (bool); 
56:     function mint(address, uint256) external returns (uint256);
57:     function burn(address, uint256) external returns (uint256);
58:     function kill(address, uint256, address) external returns (bytes memory);

62:     function check(address) external view returns (bool); 

162:     function file(bytes32 what, address data) external auth { 

188:     function file(bytes32 what, uint256 data) external auth { 

210:     function strategyNew(uint256 index, address implementation) external auth { 

219:     function strategyUgrade(uint256 index, address implementation) external auth { 

227:     function strategySetStatus(uint256 index, uint256 status) external auth { 

233:     function strategySetCap(uint256 index, uint256 cap) external auth { 

239:     function collateralSetFactor(address token, uint256 factor) external auth { 

245:     function collateralSetCap(address token, uint256 cap) external auth { 

251:     function collect(address token) external auth { 

255:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external loop returns (uint256) { 

295:     function edit(uint256 id, int256 borrow, int256 collateral) external loop { 

388:     function killRepayment(uint256 id) external view returns (uint256) { 

396:     function kill(uint256 id) external loop returns (address, bytes memory) { 

446:     function life(uint256 id) external view returns (uint256) { 

451:     function _life(Position memory p) internal view returns (uint256) { 

466:     function getPosition(uint256 id) public view returns (Position memory p) { 

477:     function setPosition(uint256 id, Position memory p) internal { 

488:     function getStrategy(uint256 id) public view returns (Strategy memory s) { 

495:     function getPool() public view returns (address) { 

499:     function push(address asset, address user, uint256 amount) internal { 

506:     function pullToBank(address asset, address user, uint256 amount) internal { 

513:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

5:     function approve(address, uint256) external returns (bool); 
6:     function transfer(address, uint256) external returns (bool);

10:     function mint(uint256 amount) external returns (uint256 shares); 
11:     function burn(uint256 shares) external returns (uint256 amount);
12:     function kill(uint256 shares, address to) external returns (bytes memory);

34:     function file(bytes32 what, address data) public auth { 

43:     function mint(address strategy, uint256 amount) public auth returns (uint256) { 

48:     function burn(address strategy, uint256 shares) public auth returns (uint256) { 

54:     function kill(address strategy, uint256 shares, address target) public auth returns (bytes memory) { 

58:     function call(address strategy, uint256 value, bytes calldata data) public auth { 
```


```solidity
📁 File: PositionManager.sol

8:     function decimals() external view returns (uint8); 
9:     function balanceOf(address) external view returns (uint256);
10:     function approve(address, uint256) external returns (bool);
11:     function transfer(address, uint256) external returns (bool);
12:     function transferFrom(address, address, uint256) external returns (bool);

16:     function latestAnswer() external view returns (int256); 
17:     function decimals() external view returns (uint8);

21:     function asset() external view returns (address); 
22:     function oracle() external view returns (address);
23:     function getUpdatedIndex() external view returns (uint256);

27:     function name() external view returns (string memory); 
28:     function rate(uint256 shares) external view returns (uint256);

47:     function getPool() external view returns (address); 
48:     function getStrategy(uint256 id) external view returns (Strategy memory);
49:     function getPosition(uint256 id) external view returns (Position memory);
50:     function life(uint256 id) external view returns (uint256);
51:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external returns (uint256);
52:     function edit(uint256 id, int256 borrow, int256 collateral) external;

56:     function check(address) external view returns (bool); 

60:     function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4); 

101:     function file(bytes32 what, address data) external admin { 

114:     function ownerOf(uint256 id) public view returns (address owner) { 

118:     function balanceOf(address owner) public view returns (uint256) { 

123:     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) { 

127:     function tokensOfOwner(address owner, uint256 start, uint256 end) external view returns (uint256[] memory v) { 

143:     function approve(address spender, uint256 id) public { 

150:     function setApprovalForAll(address operator, bool approved) public { 

155:     function moveId(address from, address to, uint256 id) internal { 

182:     function transferFrom(address from, address to, uint256 id) public auth(id) { 

188:     function safeTransferFrom(address from, address to, uint256 id) public { 

198:     function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public { 

208:     function supportsInterface(bytes4 interfaceId) public pure returns (bool) { 

214:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow, address to) public returns (uint256) { 

233:     function edit(uint256 id, int256 borrow, int256 collateral) public auth(id) { 

244:     function burn(uint256 id) public auth(id) { 

252:     function forceBurn(uint256 id) public auth(id) { 

258:     function rely(address ast, uint256 amt) internal { 

262:     function pull(address ast, address usr, uint256 amt) internal { 

266:     function push(address ast, address usr) internal { 

272:     function tokenURI(uint256 id) public view returns (string memory) { 

293:     function generateImage(uint256 id) private view returns (string memory) { 

309:     function generateHeader(uint256 id) private view returns (string memory) { 

323:     function generateLabelVal(uint256 id) private view returns (string memory) { 

339:     function generateLabelBor(uint256 id) private view returns (string memory) { 

359:     function generateLabelLif(uint256 id) private view returns (string memory) { 

374:     function formatNumber(uint256 n, uint256 d, uint256 f) internal pure returns (string memory) { 
```


```solidity
📁 File: Store.sol

35:     function file(bytes32 what, address data) external auth { 

44:     function getUint(bytes32 key) external view returns (uint256) { 

47:     function setUint(bytes32 key, uint256 value) external auth returns (uint256) { 

51:     function setUintDelta(bytes32 key, int256 value) external auth returns (uint256) { 

59:     function removeUint(bytes32 key) external auth { 

62:     function getInt(bytes32 key) external view returns (int256) { 

65:     function setInt(bytes32 key, int256 value) external auth returns (int256) { 

69:     function setIntDelta(bytes32 key, int256 value) external auth returns (int256) { 

74:     function removeInt(bytes32 key) external auth { 

77:     function getAddress(bytes32 key) external view returns (address) { 

80:     function setAddress(bytes32 key, address value) external auth returns (address) { 

84:     function removeAddress(bytes32 key) external auth { 

87:     function getBool(bytes32 key) external view returns (bool) { 

90:     function setBool(bytes32 key, bool value) external auth returns (bool) { 

94:     function removeBool(bytes32 key) external auth { 

97:     function getString(bytes32 key) external view returns (string memory) { 

100:     function setString(bytes32 key, string memory value) external auth returns (string memory) { 

104:     function removeString(bytes32 key) external auth { 

107:     function getBytes32(bytes32 key) external view returns (bytes32) { 

110:     function setBytes32(bytes32 key, bytes32 value) external auth returns (bytes32) { 

114:     function removeBytes32(bytes32 key) external auth { 

118:     function getBytes32Array(bytes32 key) external view returns (bytes32[] memory) { 

121:     function setBytes32Array(bytes32 key, bytes32[] memory value) external auth { 

124:     function removeBytes32Array(bytes32 key) external auth { 

128:     function containsBytes32(bytes32 key, bytes32 value) external view returns (bool) { 

131:     function getBytes32Count(bytes32 key) external view returns (uint256) { 

134:     function getBytes32ValuesAt(bytes32 key, uint256 start, uint256 end) external view returns (bytes32[] memory v) { 

140:     function addBytes32(bytes32 key, bytes32 value) external auth { 

147:     function removeBytes32(bytes32 key, bytes32 value) external auth { 
```


```solidity
📁 File: StrategyCamelotV3.sol

90:     function file(bytes32 what, address data) external auth { 

107:     function file(bytes32 what, uint256 data) external auth { 

119:     function setPathToLp(bytes calldata newPathToLp) external auth { 

123:     function setNitroPool(address _nitroPool) external auth { 

133:     function xgrailRedeem(uint256 amount, uint256 duration) external auth { 

137:     function xgrailFinalizeRedeem(uint256 index) external auth { 

141:     function mint(uint256 amount) external auth loop returns (uint256) { 

170:     function burn(uint256 shares) external auth loop returns (uint256) { 

193:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

206:     function stake(uint256 amount) internal { 

218:     function unstake(uint256 amount) internal { 

228:     function earn() external payable loop { 

276:     function exit(address strategy) external auth { 

284:     function move(address old) external auth { 

293:     function rate(uint256 shares) public view returns (uint256) { 

297:     function quoteAddLiquidity(uint256 amt, address trgtAst, bytes memory path) private returns (uint256, uint256) { 

320:     function quoteAndSwap(address trgtAst, uint256 amt, uint256 slp) private returns (uint256 amt0, uint256 amt1) { 

338:     function swap(address trgtAst, address ast, bytes memory path, uint256 toLp, uint256 slp) private { 

344:     function valueLiquidity() private view returns (uint256) { 

370:     function totalManagedAssets() private view returns (uint256) { 

376:     function getPosition(uint160 midX96, int24 minTick, int24 maxTick) private view returns (uint256, uint256) { 

390:     function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external returns (bytes4) { 

397:     function onNFTHarvest(address, address, uint256, uint256, uint256) public pure returns (bool) { 

401:     function onNFTAddToPosition(address, uint256, uint256) public pure returns (bool) { 

405:     function onNFTWithdraw(address, uint256, uint256) public pure returns (bool) { 

409:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

415:     function symbol() external view returns (string memory); 
416:     function balanceOf(address) external view returns (uint256);
417:     function approve(address, uint256) external;
418:     function transfer(address, uint256) external;
419:     function transferFrom(address, address, uint256) external;

423:     function value(address, uint256) external view returns (uint256); 
424:     function convert(address, address, uint256) external view returns (uint256);
425:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

429:     function swap(address ast, bytes calldata path, uint256 amt, uint256 min, address to) external; 

433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares); 
434:     function getDepositAmount(address pos, address token, uint256 deposit) external view returns (uint256 amountStart, uint256 amountEnd);

438:     function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut); 

442:     function withdraw(uint256 shares, address to, address from, uint256[4] memory minAmounts) external returns (uint256 amount0, uint256 amount1); 
443:     function pool() external view returns (IAlgebraPool);
444:     function token0() external view returns (IERC20);
445:     function token1() external view returns (IERC20);
446:     function totalSupply() external view returns (uint256);
447:     function baseLower() external view returns (int24);
448:     function baseUpper() external view returns (int24);
449:     function limitLower() external view returns (int24);
450:     function limitUpper() external view returns (int24);

454:     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external; 
455:     function createPosition(uint256 amount, uint256 lockDuration) external;
456:     function addToPosition(uint256 tokenId, uint256 amountToAdd) external;
457:     function withdrawFromPosition(uint256 tokenId, uint256 amountToWithdraw) external;
458:     function harvestPosition(uint256 tokenId) external;
459:     function getStakingPosition(uint256 tokenId) external view returns (

467:     function harvest() external; 
468:     function withdraw(uint256 tokenId) external;

472:     function token0() external view returns (address); 
473:     function token1() external view returns (address);
474:     function getTimepoints(uint32[] calldata secondsAgos) external view returns (

480:     function positions(bytes32 key) external view returns ( 

491:   function redeem(uint256 xGrailAmount, uint256 duration) external; 
492:   function finalizeRedeem(uint256 redeemIndex) external;
```


```solidity
📁 File: StrategyGMXGM.sol

94:     function file(bytes32 what, address data) external auth { 

115:     function file(bytes32 what, uint256 data) external auth { 

133:     function withdrawEth() external auth { 

138:     function withdrawAirdrop(address token) external auth { 

143:     function mint(uint256 amount) external auth loop returns (uint256) { 

159:     function burn(uint256 shares) external auth loop returns (uint256) { 

171:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

184:     function earn() external payable loop { 

283:     function exit(address strategy) external auth { 

292:     function move(address old) external auth {} 

294:     function rate(uint256 shares) public view returns (uint256) { 

304:     function marketTokenPrice(bool isDeposit) public view returns (uint256) { 

325:     function gmxPrice(address token, bool isIndex) internal view returns (IPrice.Props memory) { 

335:     function afterDepositExecution(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 

340:     function afterDepositCancellation(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 

345:     function afterWithdrawalExecution(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 

353:     function afterWithdrawalCancellation(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 

358:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

364:     function symbol() external view returns (string memory); 
365:     function decimals() external view returns (uint8);
366:     function balanceOf(address) external view returns (uint256);
367:     function approve(address, uint256) external;
368:     function transfer(address, uint256) external;
369:     function transferFrom(address, address, uint256) external;

373:     function price(address) external view returns (uint256); 
374:     function value(address, uint256) external view returns (uint256);
375:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

379:     function depositVault() external view returns (address); 
380:     function withdrawalVault() external view returns (address);

384:     function latestRoundData() external view returns ( 

394:     function getUint(bytes32 key) external view returns (uint256); 
395:     function getAddress(bytes32 key) external view returns (address);
396:     function getBytes32(bytes32 key) external view returns (bytes32);

429:     function sendWnt(address receiver, uint256 amount) external payable; 
430:     function sendTokens(address token, address receiver, uint256 amount) external payable;
431:     function createDeposit(CreateDepositParams calldata params) external payable returns (bytes32);
432:     function createWithdrawal(CreateWithdrawalParams calldata params) external payable returns (bytes32);
433:     function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);
434:     function router() external returns (address);

451:     function mint(address account, uint256 amount) external; 

478:     function getMarket(address dataStore, address key) external view returns (IMarket.Props memory); 
479:     function getMarketTokenPrice(

488:     function getWithdrawalAmountOut( 
```


```solidity
📁 File: StrategySushiswap.sol

52:     function file(bytes32 what, address data) external auth { 

63:     function file(bytes32 what, uint256 data) external auth { 

72:     function rate(uint256 sha) public view returns (uint256) { 

90:     function mint(uint256 amount) public auth loop returns (uint256) {  

117:     function burn(uint256 shares) public auth loop returns (uint256) { 

141:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

153:     function earn() public payable loop { 

177:     function totalManagedAssets() public view returns (uint256) { 

182:     function exit(address strategy) public auth { 

186:     function move(address old) public auth { 

196:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

201:     function sqrt(uint256 a) internal pure returns (uint256) { 

216:     function log2(uint256 value) internal pure returns (uint256) { 

254:     function symbol() external view returns (string memory); 
255:     function decimals() external view returns (uint8);
256:     function balanceOf(address) external view returns (uint256);
257:     function approve(address, uint256) external returns (bool);
258:     function transfer(address, uint256) external returns (bool);
259:     function transferFrom(address, address, uint256) external returns (bool);

263:     function price(address) external view returns (uint256); 
264:     function value(address, uint256) external view returns (uint256);
265:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

269:     function token0() external view returns (address); 
270:     function token1() external view returns (address);
271:     function totalSupply() external view returns (uint256);
272:     function getReserves() external view returns (uint112, uint112, uint32);
273:     function price0CumulativeLast() external view returns (uint256);
274:     function price1CumulativeLast() external view returns (uint256);
275:     function mint(address) external returns (uint256 liquidity);
276:     function burn(address) external returns (uint256 amount0, uint256 amount1);
277:     function swap(uint256, uint256, address, bytes calldata) external;
278:     function skim(address to) external;

282:     function SUSHI() external view returns (address); 
283:     function lpToken(uint256) external view returns (address);
284:     function pendingSushi(uint256, address) external view returns (uint256);
285:     function userInfo(uint256, address) external view returns (uint256, int256);
286:     function deposit(uint256, uint256, address) external;
287:     function withdraw(uint256, uint256, address) external;
288:     function harvest(uint256, address) external;
```


```solidity
📁 File: UtilFarmingBalances.sol

5:     function nextPosition() external view returns (uint256); 
6:     function positions(uint256) external view returns (address, address, uint256, uint256, uint256, uint256, uint256);

10:     function ownerOf(uint256) external view returns (address); 

14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) { 
```


```solidity
📁 File: Whitelist.sol

23:     function file(bytes32 what, address data) external auth { 

34:     function batchWhitelist(address[] memory addresses, bool status) external auth { 

42:     function check(address user) external view returns (bool) { 
```


</details>


---
### [NC&#x2011;85] NatSpec: Function declarations should have NatSpec descriptions
It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.

<details>
<summary><i>There are 309 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

5:     function transfer(address, uint256) external returns (bool); 

26:     function file(bytes32 what, address data) external auth { 

35:     function transferNative(address to, uint256 amount) external auth { 

41:     function transfer(address token, address to, uint256 amount) external auth { 
```


```solidity
📁 File: Helper.sol

5:     function balanceOf(address) external view returns (uint256); 
6:     function approve(address, uint256) external;
7:     function transfer(address, uint256) external;

11:     function killRepayment(uint256) external returns (uint256); 
12:     function kill(uint256 id) external returns (address, bytes memory);

16:     function flashLoanSimple(address receiver, address asset, uint256 amount, bytes calldata params, uint16 referrer) external; 

20:     function swap(address, address, uint256, uint256, address) external returns (uint256); 

24:     function token0() external view returns (address); 
25:     function token1() external view returns (address);
26:     function burn(address) external;

43:     function kill(uint256 id) external { 

48:     function executeOperation( 

76:     function swap(address _fromAsset) internal { 
```


```solidity
📁 File: Investor.sol

5:     function decimals() external view returns (uint8); 
6:     function balanceOf(address) external view returns (uint256);
7:     function approve(address, uint256) external;
8:     function transfer(address, uint256) external returns (bool);
9:     function transferFrom(address, address, uint256) external returns (bool);

13:     function decimals() external view returns (uint8); 
14:     function latestAnswer() external view returns (int256);

18:     function exec(address) external view returns (bool); 
19:     function getUint(bytes32) external view returns (uint256);
20:     function getAddress(bytes32) external view returns (address);
21:     function setUint(bytes32, uint256) external;
22:     function setUintDelta(bytes32, int256) external returns (uint256);
23:     function setAddress(bytes32, address) external returns (address);

27:     function exec(address) external view returns (bool); 
28:     function transfer(address, address, uint256) external;

32:     function exec(address) external view returns (bool); 
33:     function asset() external view returns (address);
34:     function oracle() external view returns (address);
35:     function getUpdatedIndex() external view returns (uint256);
36:     function borrow(uint256) external returns (uint256);
37:     function repay(uint256) external returns (uint256);

41:     function price(address) external view returns (uint256); 
42:     function value(address, uint256) external view returns (uint256);
43:     function convert(address, address, uint256) external view returns (uint256);
44:     function swap(address, address, uint256, uint256, address) external returns (uint256);

48:     function totalShares() external view returns (uint256); 
49:     function rate(uint256) external view returns (uint256);
50:     function exit(address) external;
51:     function move(address) external;

55:     function exec(address) external view returns (bool); 
56:     function mint(address, uint256) external returns (uint256);
57:     function burn(address, uint256) external returns (uint256);
58:     function kill(address, uint256, address) external returns (bytes memory);

62:     function check(address) external view returns (bool); 

162:     function file(bytes32 what, address data) external auth { 

188:     function file(bytes32 what, uint256 data) external auth { 

210:     function strategyNew(uint256 index, address implementation) external auth { 

219:     function strategyUgrade(uint256 index, address implementation) external auth { 

227:     function strategySetStatus(uint256 index, uint256 status) external auth { 

233:     function strategySetCap(uint256 index, uint256 cap) external auth { 

239:     function collateralSetFactor(address token, uint256 factor) external auth { 

245:     function collateralSetCap(address token, uint256 cap) external auth { 

251:     function collect(address token) external auth { 

255:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external loop returns (uint256) { 

295:     function edit(uint256 id, int256 borrow, int256 collateral) external loop { 

388:     function killRepayment(uint256 id) external view returns (uint256) { 

396:     function kill(uint256 id) external loop returns (address, bytes memory) { 

446:     function life(uint256 id) external view returns (uint256) { 

451:     function _life(Position memory p) internal view returns (uint256) { 

466:     function getPosition(uint256 id) public view returns (Position memory p) { 

477:     function setPosition(uint256 id, Position memory p) internal { 

488:     function getStrategy(uint256 id) public view returns (Strategy memory s) { 

495:     function getPool() public view returns (address) { 

499:     function push(address asset, address user, uint256 amount) internal { 

506:     function pullToBank(address asset, address user, uint256 amount) internal { 

513:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

5:     function approve(address, uint256) external returns (bool); 
6:     function transfer(address, uint256) external returns (bool);

10:     function mint(uint256 amount) external returns (uint256 shares); 
11:     function burn(uint256 shares) external returns (uint256 amount);
12:     function kill(uint256 shares, address to) external returns (bytes memory);

34:     function file(bytes32 what, address data) public auth { 

43:     function mint(address strategy, uint256 amount) public auth returns (uint256) { 

48:     function burn(address strategy, uint256 shares) public auth returns (uint256) { 

54:     function kill(address strategy, uint256 shares, address target) public auth returns (bytes memory) { 

58:     function call(address strategy, uint256 value, bytes calldata data) public auth { 
```


```solidity
📁 File: PositionManager.sol

8:     function decimals() external view returns (uint8); 
9:     function balanceOf(address) external view returns (uint256);
10:     function approve(address, uint256) external returns (bool);
11:     function transfer(address, uint256) external returns (bool);
12:     function transferFrom(address, address, uint256) external returns (bool);

16:     function latestAnswer() external view returns (int256); 
17:     function decimals() external view returns (uint8);

21:     function asset() external view returns (address); 
22:     function oracle() external view returns (address);
23:     function getUpdatedIndex() external view returns (uint256);

27:     function name() external view returns (string memory); 
28:     function rate(uint256 shares) external view returns (uint256);

47:     function getPool() external view returns (address); 
48:     function getStrategy(uint256 id) external view returns (Strategy memory);
49:     function getPosition(uint256 id) external view returns (Position memory);
50:     function life(uint256 id) external view returns (uint256);
51:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external returns (uint256);
52:     function edit(uint256 id, int256 borrow, int256 collateral) external;

56:     function check(address) external view returns (bool); 

60:     function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4); 

101:     function file(bytes32 what, address data) external admin { 

114:     function ownerOf(uint256 id) public view returns (address owner) { 

118:     function balanceOf(address owner) public view returns (uint256) { 

123:     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) { 

127:     function tokensOfOwner(address owner, uint256 start, uint256 end) external view returns (uint256[] memory v) { 

143:     function approve(address spender, uint256 id) public { 

150:     function setApprovalForAll(address operator, bool approved) public { 

155:     function moveId(address from, address to, uint256 id) internal { 

182:     function transferFrom(address from, address to, uint256 id) public auth(id) { 

188:     function safeTransferFrom(address from, address to, uint256 id) public { 

198:     function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public { 

208:     function supportsInterface(bytes4 interfaceId) public pure returns (bool) { 

214:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow, address to) public returns (uint256) { 

233:     function edit(uint256 id, int256 borrow, int256 collateral) public auth(id) { 

244:     function burn(uint256 id) public auth(id) { 

252:     function forceBurn(uint256 id) public auth(id) { 

258:     function rely(address ast, uint256 amt) internal { 

262:     function pull(address ast, address usr, uint256 amt) internal { 

266:     function push(address ast, address usr) internal { 

272:     function tokenURI(uint256 id) public view returns (string memory) { 

293:     function generateImage(uint256 id) private view returns (string memory) { 

309:     function generateHeader(uint256 id) private view returns (string memory) { 

323:     function generateLabelVal(uint256 id) private view returns (string memory) { 

339:     function generateLabelBor(uint256 id) private view returns (string memory) { 

359:     function generateLabelLif(uint256 id) private view returns (string memory) { 

374:     function formatNumber(uint256 n, uint256 d, uint256 f) internal pure returns (string memory) { 
```


```solidity
📁 File: Store.sol

35:     function file(bytes32 what, address data) external auth { 

44:     function getUint(bytes32 key) external view returns (uint256) { 

47:     function setUint(bytes32 key, uint256 value) external auth returns (uint256) { 

51:     function setUintDelta(bytes32 key, int256 value) external auth returns (uint256) { 

59:     function removeUint(bytes32 key) external auth { 

62:     function getInt(bytes32 key) external view returns (int256) { 

65:     function setInt(bytes32 key, int256 value) external auth returns (int256) { 

69:     function setIntDelta(bytes32 key, int256 value) external auth returns (int256) { 

74:     function removeInt(bytes32 key) external auth { 

77:     function getAddress(bytes32 key) external view returns (address) { 

80:     function setAddress(bytes32 key, address value) external auth returns (address) { 

84:     function removeAddress(bytes32 key) external auth { 

87:     function getBool(bytes32 key) external view returns (bool) { 

90:     function setBool(bytes32 key, bool value) external auth returns (bool) { 

94:     function removeBool(bytes32 key) external auth { 

97:     function getString(bytes32 key) external view returns (string memory) { 

100:     function setString(bytes32 key, string memory value) external auth returns (string memory) { 

104:     function removeString(bytes32 key) external auth { 

107:     function getBytes32(bytes32 key) external view returns (bytes32) { 

110:     function setBytes32(bytes32 key, bytes32 value) external auth returns (bytes32) { 

114:     function removeBytes32(bytes32 key) external auth { 

118:     function getBytes32Array(bytes32 key) external view returns (bytes32[] memory) { 

121:     function setBytes32Array(bytes32 key, bytes32[] memory value) external auth { 

124:     function removeBytes32Array(bytes32 key) external auth { 

128:     function containsBytes32(bytes32 key, bytes32 value) external view returns (bool) { 

131:     function getBytes32Count(bytes32 key) external view returns (uint256) { 

134:     function getBytes32ValuesAt(bytes32 key, uint256 start, uint256 end) external view returns (bytes32[] memory v) { 

140:     function addBytes32(bytes32 key, bytes32 value) external auth { 

147:     function removeBytes32(bytes32 key, bytes32 value) external auth { 
```


```solidity
📁 File: StrategyCamelotV3.sol

90:     function file(bytes32 what, address data) external auth { 

107:     function file(bytes32 what, uint256 data) external auth { 

119:     function setPathToLp(bytes calldata newPathToLp) external auth { 

123:     function setNitroPool(address _nitroPool) external auth { 

133:     function xgrailRedeem(uint256 amount, uint256 duration) external auth { 

137:     function xgrailFinalizeRedeem(uint256 index) external auth { 

141:     function mint(uint256 amount) external auth loop returns (uint256) { 

170:     function burn(uint256 shares) external auth loop returns (uint256) { 

193:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

206:     function stake(uint256 amount) internal { 

218:     function unstake(uint256 amount) internal { 

228:     function earn() external payable loop { 

276:     function exit(address strategy) external auth { 

284:     function move(address old) external auth { 

293:     function rate(uint256 shares) public view returns (uint256) { 

297:     function quoteAddLiquidity(uint256 amt, address trgtAst, bytes memory path) private returns (uint256, uint256) { 

320:     function quoteAndSwap(address trgtAst, uint256 amt, uint256 slp) private returns (uint256 amt0, uint256 amt1) { 

338:     function swap(address trgtAst, address ast, bytes memory path, uint256 toLp, uint256 slp) private { 

344:     function valueLiquidity() private view returns (uint256) { 

370:     function totalManagedAssets() private view returns (uint256) { 

376:     function getPosition(uint160 midX96, int24 minTick, int24 maxTick) private view returns (uint256, uint256) { 

390:     function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external returns (bytes4) { 

397:     function onNFTHarvest(address, address, uint256, uint256, uint256) public pure returns (bool) { 

401:     function onNFTAddToPosition(address, uint256, uint256) public pure returns (bool) { 

405:     function onNFTWithdraw(address, uint256, uint256) public pure returns (bool) { 

409:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

415:     function symbol() external view returns (string memory); 
416:     function balanceOf(address) external view returns (uint256);
417:     function approve(address, uint256) external;
418:     function transfer(address, uint256) external;
419:     function transferFrom(address, address, uint256) external;

423:     function value(address, uint256) external view returns (uint256); 
424:     function convert(address, address, uint256) external view returns (uint256);
425:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

429:     function swap(address ast, bytes calldata path, uint256 amt, uint256 min, address to) external; 

433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares); 
434:     function getDepositAmount(address pos, address token, uint256 deposit) external view returns (uint256 amountStart, uint256 amountEnd);

438:     function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut); 

442:     function withdraw(uint256 shares, address to, address from, uint256[4] memory minAmounts) external returns (uint256 amount0, uint256 amount1); 
443:     function pool() external view returns (IAlgebraPool);
444:     function token0() external view returns (IERC20);
445:     function token1() external view returns (IERC20);
446:     function totalSupply() external view returns (uint256);
447:     function baseLower() external view returns (int24);
448:     function baseUpper() external view returns (int24);
449:     function limitLower() external view returns (int24);
450:     function limitUpper() external view returns (int24);

454:     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external; 
455:     function createPosition(uint256 amount, uint256 lockDuration) external;
456:     function addToPosition(uint256 tokenId, uint256 amountToAdd) external;
457:     function withdrawFromPosition(uint256 tokenId, uint256 amountToWithdraw) external;
458:     function harvestPosition(uint256 tokenId) external;
459:     function getStakingPosition(uint256 tokenId) external view returns (

467:     function harvest() external; 
468:     function withdraw(uint256 tokenId) external;

472:     function token0() external view returns (address); 
473:     function token1() external view returns (address);
474:     function getTimepoints(uint32[] calldata secondsAgos) external view returns (

480:     function positions(bytes32 key) external view returns ( 

491:   function redeem(uint256 xGrailAmount, uint256 duration) external; 
492:   function finalizeRedeem(uint256 redeemIndex) external;
```


```solidity
📁 File: StrategyGMXGM.sol

80:     receive() external payable {} 

94:     function file(bytes32 what, address data) external auth { 

115:     function file(bytes32 what, uint256 data) external auth { 

133:     function withdrawEth() external auth { 

138:     function withdrawAirdrop(address token) external auth { 

143:     function mint(uint256 amount) external auth loop returns (uint256) { 

159:     function burn(uint256 shares) external auth loop returns (uint256) { 

171:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

184:     function earn() external payable loop { 

283:     function exit(address strategy) external auth { 

292:     function move(address old) external auth {} 

294:     function rate(uint256 shares) public view returns (uint256) { 

304:     function marketTokenPrice(bool isDeposit) public view returns (uint256) { 

325:     function gmxPrice(address token, bool isIndex) internal view returns (IPrice.Props memory) { 

335:     function afterDepositExecution(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 

340:     function afterDepositCancellation(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 

345:     function afterWithdrawalExecution(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 

353:     function afterWithdrawalCancellation(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 

358:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

364:     function symbol() external view returns (string memory); 
365:     function decimals() external view returns (uint8);
366:     function balanceOf(address) external view returns (uint256);
367:     function approve(address, uint256) external;
368:     function transfer(address, uint256) external;
369:     function transferFrom(address, address, uint256) external;

373:     function price(address) external view returns (uint256); 
374:     function value(address, uint256) external view returns (uint256);
375:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

379:     function depositVault() external view returns (address); 
380:     function withdrawalVault() external view returns (address);

384:     function latestRoundData() external view returns ( 

394:     function getUint(bytes32 key) external view returns (uint256); 
395:     function getAddress(bytes32 key) external view returns (address);
396:     function getBytes32(bytes32 key) external view returns (bytes32);

429:     function sendWnt(address receiver, uint256 amount) external payable; 
430:     function sendTokens(address token, address receiver, uint256 amount) external payable;
431:     function createDeposit(CreateDepositParams calldata params) external payable returns (bytes32);
432:     function createWithdrawal(CreateWithdrawalParams calldata params) external payable returns (bytes32);
433:     function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);
434:     function router() external returns (address);

451:     function mint(address account, uint256 amount) external; 

478:     function getMarket(address dataStore, address key) external view returns (IMarket.Props memory); 
479:     function getMarketTokenPrice(

488:     function getWithdrawalAmountOut( 
```


```solidity
📁 File: StrategySushiswap.sol

52:     function file(bytes32 what, address data) external auth { 

63:     function file(bytes32 what, uint256 data) external auth { 

72:     function rate(uint256 sha) public view returns (uint256) { 

90:     function mint(uint256 amount) public auth loop returns (uint256) {  

117:     function burn(uint256 shares) public auth loop returns (uint256) { 

141:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

153:     function earn() public payable loop { 

177:     function totalManagedAssets() public view returns (uint256) { 

182:     function exit(address strategy) public auth { 

186:     function move(address old) public auth { 

196:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

201:     function sqrt(uint256 a) internal pure returns (uint256) { 

216:     function log2(uint256 value) internal pure returns (uint256) { 

254:     function symbol() external view returns (string memory); 
255:     function decimals() external view returns (uint8);
256:     function balanceOf(address) external view returns (uint256);
257:     function approve(address, uint256) external returns (bool);
258:     function transfer(address, uint256) external returns (bool);
259:     function transferFrom(address, address, uint256) external returns (bool);

263:     function price(address) external view returns (uint256); 
264:     function value(address, uint256) external view returns (uint256);
265:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

269:     function token0() external view returns (address); 
270:     function token1() external view returns (address);
271:     function totalSupply() external view returns (uint256);
272:     function getReserves() external view returns (uint112, uint112, uint32);
273:     function price0CumulativeLast() external view returns (uint256);
274:     function price1CumulativeLast() external view returns (uint256);
275:     function mint(address) external returns (uint256 liquidity);
276:     function burn(address) external returns (uint256 amount0, uint256 amount1);
277:     function swap(uint256, uint256, address, bytes calldata) external;
278:     function skim(address to) external;

282:     function SUSHI() external view returns (address); 
283:     function lpToken(uint256) external view returns (address);
284:     function pendingSushi(uint256, address) external view returns (uint256);
285:     function userInfo(uint256, address) external view returns (uint256, int256);
286:     function deposit(uint256, uint256, address) external;
287:     function withdraw(uint256, uint256, address) external;
288:     function harvest(uint256, address) external;
```


```solidity
📁 File: UtilFarmingBalances.sol

5:     function nextPosition() external view returns (uint256); 
6:     function positions(uint256) external view returns (address, address, uint256, uint256, uint256, uint256, uint256);

10:     function ownerOf(uint256) external view returns (address); 

14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) { 
```


```solidity
📁 File: Whitelist.sol

23:     function file(bytes32 what, address data) external auth { 

34:     function batchWhitelist(address[] memory addresses, bool status) external auth { 

42:     function check(address user) external view returns (bool) { 
```


</details>


---
### [NC&#x2011;86] NatSpec: Functions missing NatSpec `@dev` tag
<details>
<summary><i>There are 319 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

4: interface IERC20 { 
5:     function transfer(address, uint256) external returns (bool);
6: }

16:  
17:     constructor() {
18:         exec[msg.sender] = true;

25:  
26:     function file(bytes32 what, address data) external auth {
27:         if (what == "exec") {

34:  
35:     function transferNative(address to, uint256 amount) external auth {
36:         if (amount == 0) return;

40:  
41:     function transfer(address token, address to, uint256 amount) external auth {
42:         if (amount == 0) return;
```


```solidity
📁 File: Helper.sol

4: interface IERC20 { 
5:     function balanceOf(address) external view returns (uint256);
6:     function approve(address, uint256) external;
7:     function transfer(address, uint256) external;
8: }

10: interface IInvestor { 
11:     function killRepayment(uint256) external returns (uint256);
12:     function kill(uint256 id) external returns (address, bytes memory);
13: }

15: interface IAavePool { 
16:     function flashLoanSimple(address receiver, address asset, uint256 amount, bytes calldata params, uint16 referrer) external;
17: }

19: interface IStrategyHelper { 
20:     function swap(address, address, uint256, uint256, address) external returns (uint256);
21: }

23: interface ISushi { 
24:     function token0() external view returns (address);
25:     function token1() external view returns (address);
26:     function burn(address) external;
27: }

35:  
36:     constructor(address _investor, address _asset, address _lender, address _sh) {
37:         investor = IInvestor(_investor);

42:  
43:     function kill(uint256 id) external {
44:         uint256 repay = investor.killRepayment(id);

47:  
48:     function executeOperation(
49:       address,

75:  
76:     function swap(address _fromAsset) internal {
77:         IERC20 fromAsset = IERC20(_fromAsset);
```


```solidity
📁 File: Investor.sol

4: interface IERC20 { 
5:     function decimals() external view returns (uint8);
6:     function balanceOf(address) external view returns (uint256);
7:     function approve(address, uint256) external;
8:     function transfer(address, uint256) external returns (bool);
9:     function transferFrom(address, address, uint256) external returns (bool);
10: }

12: interface IOracle { 
13:     function decimals() external view returns (uint8);
14:     function latestAnswer() external view returns (int256);
15: }

17: interface IStore { 
18:     function exec(address) external view returns (bool);
19:     function getUint(bytes32) external view returns (uint256);
20:     function getAddress(bytes32) external view returns (address);
21:     function setUint(bytes32, uint256) external;
22:     function setUintDelta(bytes32, int256) external returns (uint256);
23:     function setAddress(bytes32, address) external returns (address);
24: }

26: interface IBank { 
27:     function exec(address) external view returns (bool);
28:     function transfer(address, address, uint256) external;
29: }

31: interface IPool { 
32:     function exec(address) external view returns (bool);
33:     function asset() external view returns (address);
34:     function oracle() external view returns (address);
35:     function getUpdatedIndex() external view returns (uint256);
36:     function borrow(uint256) external returns (uint256);
37:     function repay(uint256) external returns (uint256);
38: }

40: interface IHelper { 
41:     function price(address) external view returns (uint256);
42:     function value(address, uint256) external view returns (uint256);
43:     function convert(address, address, uint256) external view returns (uint256);
44:     function swap(address, address, uint256, uint256, address) external returns (uint256);
45: }

47: interface IStrategy { 
48:     function totalShares() external view returns (uint256);
49:     function rate(uint256) external view returns (uint256);
50:     function exit(address) external;
51:     function move(address) external;
52: }

54: interface IStrategyProxy { 
55:     function exec(address) external view returns (bool);
56:     function mint(address, uint256) external returns (uint256);
57:     function burn(address, uint256) external returns (uint256);
58:     function kill(address, uint256, address) external returns (bytes memory);
59: }

61: interface IWhitelist { 
62:     function check(address) external view returns (bool);
63: }

143:  
144:     constructor(address _store, address _helper) {
145:         store = IStore(_store);

161:  
162:     function file(bytes32 what, address data) external auth {
163:         if (what == "exec") {

187:  
188:     function file(bytes32 what, uint256 data) external auth {
189:         if (what == "slippage") {

209:  
210:     function strategyNew(uint256 index, address implementation) external auth {
211:         if (store.getAddress(keccak256(abi.encode(index, STRATEGIES_ADDRESS))) != address(0)) {

218:  
219:     function strategyUgrade(uint256 index, address implementation) external auth {
220:         Strategy memory s = getStrategy(index);

226:  
227:     function strategySetStatus(uint256 index, uint256 status) external auth {
228:         Strategy memory s = getStrategy(index);

232:  
233:     function strategySetCap(uint256 index, uint256 cap) external auth {
234:         Strategy memory s = getStrategy(index);

238:  
239:     function collateralSetFactor(address token, uint256 factor) external auth {
240:         uint256 cap = store.getUint(keccak256(abi.encode(token, COLLATERAL_CAP)));

244:  
245:     function collateralSetCap(address token, uint256 cap) external auth {
246:         uint256 factor = store.getUint(keccak256(abi.encode(token, COLLATERAL_FACTOR)));

250:  
251:     function collect(address token) external auth {
252:         IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));

254:  
255:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external loop returns (uint256) {
256:         if (address(whitelist) != address(0)) {

294:  
295:     function edit(uint256 id, int256 borrow, int256 collateral) external loop {
296:         IBank bank = IBank(store.getAddress(BANK));

387:  
388:     function killRepayment(uint256 id) external view returns (uint256) {
389:         IPool pool = IPool(store.getAddress(POOL));

395:  
396:     function kill(uint256 id) external loop returns (address, bytes memory) {
397:         IBank bank = IBank(store.getAddress(BANK));

445:  
446:     function life(uint256 id) external view returns (uint256) {
447:         Position memory p = getPosition(id);

450:  
451:     function _life(Position memory p) internal view returns (uint256) {
452:         if (p.borrow == 0) return 1e18;

465:  
466:     function getPosition(uint256 id) public view returns (Position memory p) {
467:         p.owner = store.getAddress(keccak256(abi.encode(id, POSITIONS_OWNER)));

476:  
477:     function setPosition(uint256 id, Position memory p) internal {
478:         store.setAddress(keccak256(abi.encode(id, POSITIONS_OWNER)), p.owner);

487:  
488:     function getStrategy(uint256 id) public view returns (Strategy memory s) {
489:         s.implementation = store.getAddress(keccak256(abi.encode(id, STRATEGIES_ADDRESS)));

494:  
495:     function getPool() public view returns (address) {
496:         return store.getAddress(POOL);

498:  
499:     function push(address asset, address user, uint256 amount) internal {
500:         if (amount == 0) return;

505:  
506:     function pullToBank(address asset, address user, uint256 amount) internal {
507:         if (amount == 0) return;

512:  
513:     function min(uint256 a, uint256 b) internal pure returns (uint256) {
514:         return a < b ? a : b;
```


```solidity
📁 File: InvestorStrategyProxy.sol

4: interface IERC20 { 
5:     function approve(address, uint256) external returns (bool);
6:     function transfer(address, uint256) external returns (bool);
7: }

9: interface IStrategy { 
10:     function mint(uint256 amount) external returns (uint256 shares);
11:     function burn(uint256 shares) external returns (uint256 amount);
12:     function kill(uint256 shares, address to) external returns (bytes memory);
13: }

23:  
24:     constructor(address _asset) {
25:         asset = IERC20(_asset);

33:  
34:     function file(bytes32 what, address data) public auth {
35:         if (what == "exec") {

42:  
43:     function mint(address strategy, uint256 amount) public auth returns (uint256) {
44:         asset.approve(strategy, amount);

47:  
48:     function burn(address strategy, uint256 shares) public auth returns (uint256) {
49:         uint256 amount = IStrategy(strategy).burn(shares);

53:  
54:     function kill(address strategy, uint256 shares, address target) public auth returns (bytes memory) {
55:         return IStrategy(strategy).kill(shares, target);

57:  
58:     function call(address strategy, uint256 value, bytes calldata data) public auth {
59:         (bool success,) = strategy.call{value: value}(data);
```


```solidity
📁 File: PositionManager.sol

7: interface IERC20 { 
8:     function decimals() external view returns (uint8);
9:     function balanceOf(address) external view returns (uint256);
10:     function approve(address, uint256) external returns (bool);
11:     function transfer(address, uint256) external returns (bool);
12:     function transferFrom(address, address, uint256) external returns (bool);
13: }

15: interface IOracle { 
16:     function latestAnswer() external view returns (int256);
17:     function decimals() external view returns (uint8);
18: }

20: interface IPool { 
21:     function asset() external view returns (address);
22:     function oracle() external view returns (address);
23:     function getUpdatedIndex() external view returns (uint256);
24: }

26: interface IStrategy { 
27:     function name() external view returns (string memory);
28:     function rate(uint256 shares) external view returns (uint256);
29: }

46:     } 
47:     function getPool() external view returns (address);
48:     function getStrategy(uint256 id) external view returns (Strategy memory);
49:     function getPosition(uint256 id) external view returns (Position memory);
50:     function life(uint256 id) external view returns (uint256);
51:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external returns (uint256);
52:     function edit(uint256 id, int256 borrow, int256 collateral) external;
53: }

55: interface IWhitelist { 
56:     function check(address) external view returns (bool);
57: }

59: interface ERC721TokenReceiver { 
60:     function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4);
61: }

90:  
91:     constructor(address _investor) {
92:         investor = IInvestor(_investor);

100:  
101:     function file(bytes32 what, address data) external admin {
102:         if (what == "exec") {

113:  
114:     function ownerOf(uint256 id) public view returns (address owner) {
115:         require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");

117:  
118:     function balanceOf(address owner) public view returns (uint256) {
119:         require(owner != address(0), "ZERO_ADDRESS");

122:  
123:     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) {
124:         return _ownerIds[owner].values[index];

126:  
127:     function tokensOfOwner(address owner, uint256 start, uint256 end) external view returns (uint256[] memory v) {
128:         v = new uint256[](end-start);

142:  
143:     function approve(address spender, uint256 id) public {
144:         address owner = _ownerOf[id];

149:  
150:     function setApprovalForAll(address operator, bool approved) public {
151:         isApprovedForAll[msg.sender][operator] = approved;

154:  
155:     function moveId(address from, address to, uint256 id) internal {
156:         if (from != address(0)) {

181:  
182:     function transferFrom(address from, address to, uint256 id) public auth(id) {
183:         require(from == _ownerOf[id], "WRONG_FROM");

187:  
188:     function safeTransferFrom(address from, address to, uint256 id) public {
189:         transferFrom(from, to, id);

197:  
198:     function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public {
199:         transferFrom(from, to, id);

207:  
208:     function supportsInterface(bytes4 interfaceId) public pure returns (bool) {
209:         return interfaceId == 0x01ffc9a7 // ERC165

213:  
214:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow, address to) public returns (uint256) {
215:         if (address(whitelist) != address(0)) {

232:  
233:     function edit(uint256 id, int256 borrow, int256 collateral) public auth(id) {
234:         IInvestor.Position memory p = investor.getPosition(id);

243:  
244:     function burn(uint256 id) public auth(id) {
245:         IInvestor.Position memory p = investor.getPosition(id);

251:  
252:     function forceBurn(uint256 id) public auth(id) {
253:         address owner = _ownerOf[id];

257:  
258:     function rely(address ast, uint256 amt) internal {
259:         if (!IERC20(ast).approve(address(investor), amt)) revert TransferFailed();

261:  
262:     function pull(address ast, address usr, uint256 amt) internal {
263:         if (!IERC20(ast).transferFrom(usr, address(this), amt)) revert TransferFailed();

265:  
266:     function push(address ast, address usr) internal {
267:         IERC20 asset = IERC20(ast);

271:  
272:     function tokenURI(uint256 id) public view returns (string memory) {
273:         string memory image = generateImage(id);

292:  
293:     function generateImage(uint256 id) private view returns (string memory) {
294:         return Base64.encode(

308:  
309:     function generateHeader(uint256 id) private view returns (string memory) {
310:         IInvestor.Position memory p = investor.getPosition(id);

322:  
323:     function generateLabelVal(uint256 id) private view returns (string memory) {
324:         IInvestor.Position memory p = investor.getPosition(id);

338:  
339:     function generateLabelBor(uint256 id) private view returns (string memory) {
340:         IInvestor.Position memory p = investor.getPosition(id);

358:  
359:     function generateLabelLif(uint256 id) private view returns (string memory) {
360:         uint256 amt = investor.life(id);

373:  
374:     function formatNumber(uint256 n, uint256 d, uint256 f) internal pure returns (string memory) {
375:         uint256 x = 10 ** d;
```


```solidity
📁 File: Store.sol

25:  
26:     constructor() {
27:         exec[msg.sender] = true;

34:  
35:     function file(bytes32 what, address data) external auth {
36:         if (what == "exec") {

43:  
44:     function getUint(bytes32 key) external view returns (uint256) {
45:         return uintValues[key];
46:     }
47:     function setUint(bytes32 key, uint256 value) external auth returns (uint256) {
48:         uintValues[key] = value;

50:     } 
51:     function setUintDelta(bytes32 key, int256 value) external auth returns (uint256) {
52:         uint256 prev = uintValues[key];

58:     } 
59:     function removeUint(bytes32 key) external auth {
60:         delete uintValues[key];
61:     }
62:     function getInt(bytes32 key) external view returns (int256) {
63:         return intValues[key];
64:     }
65:     function setInt(bytes32 key, int256 value) external auth returns (int256) {
66:         intValues[key] = value;

68:     } 
69:     function setIntDelta(bytes32 key, int256 value) external auth returns (int256) {
70:         int256 next = intValues[key] + value;

73:     } 
74:     function removeInt(bytes32 key) external auth {
75:         delete intValues[key];
76:     }
77:     function getAddress(bytes32 key) external view returns (address) {
78:         return addressValues[key];
79:     }
80:     function setAddress(bytes32 key, address value) external auth returns (address) {
81:         addressValues[key] = value;

83:     } 
84:     function removeAddress(bytes32 key) external auth {
85:         delete addressValues[key];
86:     }
87:     function getBool(bytes32 key) external view returns (bool) {
88:         return boolValues[key];
89:     }
90:     function setBool(bytes32 key, bool value) external auth returns (bool) {
91:         boolValues[key] = value;

93:     } 
94:     function removeBool(bytes32 key) external auth {
95:         delete boolValues[key];
96:     }
97:     function getString(bytes32 key) external view returns (string memory) {
98:         return stringValues[key];
99:     }
100:     function setString(bytes32 key, string memory value) external auth returns (string memory) {
101:         stringValues[key] = value;

103:     } 
104:     function removeString(bytes32 key) external auth {
105:         delete stringValues[key];
106:     }
107:     function getBytes32(bytes32 key) external view returns (bytes32) {
108:         return bytes32Values[key];
109:     }
110:     function setBytes32(bytes32 key, bytes32 value) external auth returns (bytes32) {
111:         bytes32Values[key] = value;

113:     } 
114:     function removeBytes32(bytes32 key) external auth {
115:         delete bytes32Values[key];

117:  
118:     function getBytes32Array(bytes32 key) external view returns (bytes32[] memory) {
119:         return bytes32ArrayValues[key];
120:     }
121:     function setBytes32Array(bytes32 key, bytes32[] memory value) external auth {
122:         bytes32ArrayValues[key] = value;
123:     }
124:     function removeBytes32Array(bytes32 key) external auth {
125:         delete bytes32ArrayValues[key];

127:  
128:     function containsBytes32(bytes32 key, bytes32 value) external view returns (bool) {
129:         return bytes32Sets[key].positions[value] != 0;
130:     }
131:     function getBytes32Count(bytes32 key) external view returns (uint256) {
132:         return bytes32Sets[key].values.length;
133:     }
134:     function getBytes32ValuesAt(bytes32 key, uint256 start, uint256 end) external view returns (bytes32[] memory v) {
135:         v = new bytes32[](end-start);

139:     } 
140:     function addBytes32(bytes32 key, bytes32 value) external auth {
141:         Bytes32Set storage s = bytes32Sets[key];

146:     } 
147:     function removeBytes32(bytes32 key, bytes32 value) external auth {
148:         Bytes32Set storage s = bytes32Sets[key];
```


```solidity
📁 File: StrategyCamelotV3.sol

47:  
48:     constructor(
49:         address _asset,

89:  
90:     function file(bytes32 what, address data) external auth {
91:         if (what == "exec") {

106:  
107:     function file(bytes32 what, uint256 data) external auth {
108:         if (what == "slippage") {

118:  
119:     function setPathToLp(bytes calldata newPathToLp) external auth {
120:         pathToLp = newPathToLp;

122:  
123:     function setNitroPool(address _nitroPool) external auth {
124:         if (tokenId == 0) revert TokenIdNeededFirst();

132:  
133:     function xgrailRedeem(uint256 amount, uint256 duration) external auth {
134:         xgrail.redeem(amount, duration);

136:  
137:     function xgrailFinalizeRedeem(uint256 index) external auth {
138:         xgrail.finalizeRedeem(index);

140:  
141:     function mint(uint256 amount) external auth loop returns (uint256) {
142:         asset.transferFrom(msg.sender, address(this), amount);

169:  
170:     function burn(uint256 shares) external auth loop returns (uint256) {
171:         uint256 tma = totalManagedAssets();

192:  
193:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) {
194:         uint256 amount = shares * totalManagedAssets() / totalShares;

205:  
206:     function stake(uint256 amount) internal {
207:         IERC20(address(hypervisor)).approve(address(nftPool), amount);

217:  
218:     function unstake(uint256 amount) internal {
219:         if (address(nitroPool) != address(0)) {

227:  
228:     function earn() external payable loop {
229:         if (!keepers[msg.sender]) revert NotKeeper();

275:  
276:     function exit(address strategy) external auth {
277:         if (tokenId == 0) return;

283:  
284:     function move(address old) external auth {
285:         nftPool = StrategyCamelotV3(old).nftPool();

292:  
293:     function rate(uint256 shares) public view returns (uint256) {
294:         return shares * valueLiquidity() / totalShares;

296:  
297:     function quoteAddLiquidity(uint256 amt, address trgtAst, bytes memory path) private returns (uint256, uint256) {
298:         uint256 lp0Amt = amt / 2;

319:  
320:     function quoteAndSwap(address trgtAst, uint256 amt, uint256 slp) private returns (uint256 amt0, uint256 amt1) {
321:         bytes memory path = pathToLp;

337:  
338:     function swap(address trgtAst, address ast, bytes memory path, uint256 toLp, uint256 slp) private {
339:         uint256 minOut = strategyHelper.convert(trgtAst, ast, toLp) * (10000 - slp) / 10000;

343:  
344:     function valueLiquidity() private view returns (uint256) {
345:         uint32 period = twapPeriod;

369:  
370:     function totalManagedAssets() private view returns (uint256) {
371:         if (tokenId == 0) return 0;

375:  
376:     function getPosition(uint160 midX96, int24 minTick, int24 maxTick) private view returns (uint256, uint256) {
377:         bytes32 key;

389:  
390:     function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external returns (bytes4) {
391:         if (msg.sender == address(nftPool) && tokenId == 0) {

396:  
397:     function onNFTHarvest(address, address, uint256, uint256, uint256) public pure returns (bool) {
398:         return true;

400:  
401:     function onNFTAddToPosition(address, uint256, uint256) public pure returns (bool) {
402:         return true;

404:  
405:     function onNFTWithdraw(address, uint256, uint256) public pure returns (bool) {
406:         return true;

408:  
409:     function min(uint256 a, uint256 b) internal pure returns (uint256) {
410:         return a < b ? a : b;

414: interface IERC20 { 
415:     function symbol() external view returns (string memory);
416:     function balanceOf(address) external view returns (uint256);
417:     function approve(address, uint256) external;
418:     function transfer(address, uint256) external;
419:     function transferFrom(address, address, uint256) external;
420: }

422: interface IStrategyHelper { 
423:     function value(address, uint256) external view returns (uint256);
424:     function convert(address, address, uint256) external view returns (uint256);
425:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);
426: }

428: interface IStrategyHelperUniswapV3 { 
429:     function swap(address ast, bytes calldata path, uint256 amt, uint256 min, address to) external;
430: }

432: interface IUniProxy { 
433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares);
434:     function getDepositAmount(address pos, address token, uint256 deposit) external view returns (uint256 amountStart, uint256 amountEnd);
435: }

437: interface IQuoter { 
438:     function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);
439: }

441: interface IHypervisor is IERC20 { 
442:     function withdraw(uint256 shares, address to, address from, uint256[4] memory minAmounts) external returns (uint256 amount0, uint256 amount1);
443:     function pool() external view returns (IAlgebraPool);
444:     function token0() external view returns (IERC20);
445:     function token1() external view returns (IERC20);
446:     function totalSupply() external view returns (uint256);
447:     function baseLower() external view returns (int24);
448:     function baseUpper() external view returns (int24);
449:     function limitLower() external view returns (int24);
450:     function limitUpper() external view returns (int24);
451: }

453: interface INFTPool { 
454:     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;
455:     function createPosition(uint256 amount, uint256 lockDuration) external;
456:     function addToPosition(uint256 tokenId, uint256 amountToAdd) external;
457:     function withdrawFromPosition(uint256 tokenId, uint256 amountToWithdraw) external;
458:     function harvestPosition(uint256 tokenId) external;
459:     function getStakingPosition(uint256 tokenId) external view returns (
460:         uint256 amount, uint256 amountWithMultiplier, uint256 startLockTime,

466: interface INitroPool { 
467:     function harvest() external;
468:     function withdraw(uint256 tokenId) external;
469: }

471: interface IAlgebraPool { 
472:     function token0() external view returns (address);
473:     function token1() external view returns (address);
474:     function getTimepoints(uint32[] calldata secondsAgos) external view returns (
475:         int56[] memory tickCumulatives,

479:     ); 
480:     function positions(bytes32 key) external view returns (
481:         uint128 liquidityAmount,

490: interface IXGrail { 
491:   function redeem(uint256 xGrailAmount, uint256 duration) external;
492:   function finalizeRedeem(uint256 redeemIndex) external;
493: }
```


```solidity
📁 File: StrategyGMXGM.sol

47:  
48:     constructor(
49:         address _asset,

79:  
80:     receive() external payable {}
81: 

93:  
94:     function file(bytes32 what, address data) external auth {
95:         if (what == "exec") {

114:  
115:     function file(bytes32 what, uint256 data) external auth {
116:         if (what == "slippage") {

132:  
133:     function withdrawEth() external auth {
134:         (bool success,) = address(msg.sender).call{value: address(this).balance}("");

137:  
138:     function withdrawAirdrop(address token) external auth {
139:       if (token == address(market) || token == tokenShort || token == tokenLong) revert BadToken();

142:  
143:     function mint(uint256 amount) external auth loop returns (uint256) {
144:         uint256 slp = slippage;

158:  
159:     function burn(uint256 shares) external auth loop returns (uint256) {
160:         uint256 slp = slippage;

170:  
171:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) {
172:         uint256 value = rate(shares);

183:  
184:     function earn() external payable loop {
185:         if (!keepers[msg.sender]) revert NotKeeper();

282:  
283:     function exit(address strategy) external auth {
284:         if (amountPendingDeposit != 0 || amountPendingWithdraw != 0) {

291:  
292:     function move(address old) external auth {}
293: 
294:     function rate(uint256 shares) public view returns (uint256) {
295:         uint256 val = strategyHelper.value(tokenLong, IERC20(tokenLong).balanceOf(address(this)));

303:  
304:     function marketTokenPrice(bool isDeposit) public view returns (uint256) {
305:         IReader r = reader;

324:  
325:     function gmxPrice(address token, bool isIndex) internal view returns (IPrice.Props memory) {
326:         uint256 decimals = isIndex ? indexTokenDecimals : 0;

334:  
335:     function afterDepositExecution(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external {
336:         if (msg.sender != depositHandler) revert NotGMX();

339:  
340:     function afterDepositCancellation(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external {
341:         if (msg.sender != depositHandler) revert NotGMX();

344:  
345:     function afterWithdrawalExecution(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external {
346:         if (msg.sender != withdrawalHandler) revert NotGMX();

352:  
353:     function afterWithdrawalCancellation(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external {
354:         if (msg.sender != withdrawalHandler) revert NotGMX();

357:  
358:     function min(uint256 a, uint256 b) internal pure returns (uint256) {
359:         return a < b ? a : b;

363: interface IERC20 { 
364:     function symbol() external view returns (string memory);
365:     function decimals() external view returns (uint8);
366:     function balanceOf(address) external view returns (uint256);
367:     function approve(address, uint256) external;
368:     function transfer(address, uint256) external;
369:     function transferFrom(address, address, uint256) external;
370: }

372: interface IStrategyHelper { 
373:     function price(address) external view returns (uint256);
374:     function value(address, uint256) external view returns (uint256);
375:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);
376: }

378: interface IHandler { 
379:     function depositVault() external view returns (address);
380:     function withdrawalVault() external view returns (address);
381: }

383: interface IPriceFeed { 
384:     function latestRoundData() external view returns (
385:         uint80 roundId,

393: interface IDataStore { 
394:     function getUint(bytes32 key) external view returns (uint256);
395:     function getAddress(bytes32 key) external view returns (address);
396:     function getBytes32(bytes32 key) external view returns (bytes32);
397: }

428:  
429:     function sendWnt(address receiver, uint256 amount) external payable;
430:     function sendTokens(address token, address receiver, uint256 amount) external payable;
431:     function createDeposit(CreateDepositParams calldata params) external payable returns (bytes32);
432:     function createWithdrawal(CreateWithdrawalParams calldata params) external payable returns (bytes32);
433:     function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);
434:     function router() external returns (address);
435: }

450:  
451:     function mint(address account, uint256 amount) external;
452: }

477: interface IReader { 
478:     function getMarket(address dataStore, address key) external view returns (IMarket.Props memory);
479:     function getMarketTokenPrice(
480:         address dataStore,

487:     ) external view returns (int256, IMarketPoolValueInfo.Props memory); 
488:     function getWithdrawalAmountOut(
489:         address dataStore,
```


```solidity
📁 File: StrategySushiswap.sol

28:  
29:     constructor(address _asset, address _strategyHelper, address _rewarder, uint256 _poolId) {
30:         exec[msg.sender] = true;

51:  
52:     function file(bytes32 what, address data) external auth {
53:         if (what == "exec") {

62:  
63:     function file(bytes32 what, uint256 data) external auth {
64:         if (what == "slippage") {

71:  
72:     function rate(uint256 sha) public view returns (uint256) {
73:         if (sha == 0 || totalShares == 0) return 0;

89:  
90:     function mint(uint256 amount) public auth loop returns (uint256) { 
91:         asset.transferFrom(msg.sender, address(this), amount);

116:  
117:     function burn(uint256 shares) public auth loop returns (uint256) {
118:         IUniswapV2Pair pair = pool;

140:  
141:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) {
142:         uint256 amount = shares * totalManagedAssets() / totalShares;

152:  
153:     function earn() public payable loop {
154:         if (!keepers[msg.sender]) revert NotKeeper();

176:  
177:     function totalManagedAssets() public view returns (uint256) {
178:         (uint256 amt,) = rewarder.userInfo(poolId, address(this));

181:  
182:     function exit(address strategy) public auth {
183:         rewarder.withdraw(poolId, totalShares, strategy);

185:  
186:     function move(address old) public auth {
187:         require(totalShares == 0, "ts=0");

195:  
196:     function min(uint256 a, uint256 b) internal pure returns (uint256) {
197:         return a < b ? a : b;

200:     // from OZ Math 
201:     function sqrt(uint256 a) internal pure returns (uint256) {
202:         if (a == 0) return 0;

215:  
216:     function log2(uint256 value) internal pure returns (uint256) {
217:         uint256 result = 0;

253: interface IERC20 { 
254:     function symbol() external view returns (string memory);
255:     function decimals() external view returns (uint8);
256:     function balanceOf(address) external view returns (uint256);
257:     function approve(address, uint256) external returns (bool);
258:     function transfer(address, uint256) external returns (bool);
259:     function transferFrom(address, address, uint256) external returns (bool);
260: }

262: interface IStrategyHelper { 
263:     function price(address) external view returns (uint256);
264:     function value(address, uint256) external view returns (uint256);
265:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);
266: }

268: interface IUniswapV2Pair { 
269:     function token0() external view returns (address);
270:     function token1() external view returns (address);
271:     function totalSupply() external view returns (uint256);
272:     function getReserves() external view returns (uint112, uint112, uint32);
273:     function price0CumulativeLast() external view returns (uint256);
274:     function price1CumulativeLast() external view returns (uint256);
275:     function mint(address) external returns (uint256 liquidity);
276:     function burn(address) external returns (uint256 amount0, uint256 amount1);
277:     function swap(uint256, uint256, address, bytes calldata) external;
278:     function skim(address to) external;
279: }

281: interface ISushiswapMiniChefV2 { 
282:     function SUSHI() external view returns (address);
283:     function lpToken(uint256) external view returns (address);
284:     function pendingSushi(uint256, address) external view returns (uint256);
285:     function userInfo(uint256, address) external view returns (uint256, int256);
286:     function deposit(uint256, uint256, address) external;
287:     function withdraw(uint256, uint256, address) external;
288:     function harvest(uint256, address) external;
289: }
```


```solidity
📁 File: UtilFarmingBalances.sol

4: interface IInvestor { 
5:     function nextPosition() external view returns (uint256);
6:     function positions(uint256) external view returns (address, address, uint256, uint256, uint256, uint256, uint256);
7: }

9: interface IPositionManager { 
10:     function ownerOf(uint256) external view returns (address);
11: }

13: contract UtilFarmingBalances { 
14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) {
15:         IInvestor i = IInvestor(0x8accf43Dd31DfCd4919cc7d65912A475BfA60369);
```


```solidity
📁 File: Whitelist.sol

13:  
14:     constructor() {
15:         exec[msg.sender] = true;

22:  
23:     function file(bytes32 what, address data) external auth {
24:         if (what == "exec") {

33:  
34:     function batchWhitelist(address[] memory addresses, bool status) external auth {
35:         uint256 l = addresses.length;

41:  
42:     function check(address user) external view returns (bool) {
43:         return whitelist[user];
```


</details>


---
### [NC&#x2011;87] NatSpec: Functions missing NatSpec `@param` tag
It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.

<details>
<summary><i>There are 262 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit Missing @param for all function parameters
5:     function transfer(address, uint256) external returns (bool); 

/// @audit Missing @param for all function parameters
26:     function file(bytes32 what, address data) external auth { 

/// @audit Missing @param for all function parameters
35:     function transferNative(address to, uint256 amount) external auth { 

/// @audit Missing @param for all function parameters
41:     function transfer(address token, address to, uint256 amount) external auth { 
```


```solidity
📁 File: Helper.sol

/// @audit Missing @param for all function parameters
5:     function balanceOf(address) external view returns (uint256); 
/// @audit Missing @param for all function parameters
6:     function approve(address, uint256) external;
/// @audit Missing @param for all function parameters
7:     function transfer(address, uint256) external;

/// @audit Missing @param for all function parameters
11:     function killRepayment(uint256) external returns (uint256); 
/// @audit Missing @param for all function parameters
12:     function kill(uint256 id) external returns (address, bytes memory);

/// @audit Missing @param for all function parameters
16:     function flashLoanSimple(address receiver, address asset, uint256 amount, bytes calldata params, uint16 referrer) external; 

/// @audit Missing @param for all function parameters
20:     function swap(address, address, uint256, uint256, address) external returns (uint256); 

/// @audit Missing @param for all function parameters
26:     function burn(address) external; 

/// @audit Missing @param for all function parameters
36:     constructor(address _investor, address _asset, address _lender, address _sh) { 

/// @audit Missing @param for all function parameters
43:     function kill(uint256 id) external { 

/// @audit Missing @param for all function parameters
48:     function executeOperation( 
49:       address,
50:       uint256 amount,
51:       uint256 premium,
52:       address initiator,
53:       bytes calldata params
54:     ) external returns (bool) {

/// @audit Missing @param for all function parameters
76:     function swap(address _fromAsset) internal { 
```


```solidity
📁 File: Investor.sol

/// @audit Missing @param for all function parameters
6:     function balanceOf(address) external view returns (uint256); 
/// @audit Missing @param for all function parameters
7:     function approve(address, uint256) external;
/// @audit Missing @param for all function parameters
8:     function transfer(address, uint256) external returns (bool);
/// @audit Missing @param for all function parameters
9:     function transferFrom(address, address, uint256) external returns (bool);

/// @audit Missing @param for all function parameters
18:     function exec(address) external view returns (bool); 
/// @audit Missing @param for all function parameters
19:     function getUint(bytes32) external view returns (uint256);
/// @audit Missing @param for all function parameters
20:     function getAddress(bytes32) external view returns (address);
/// @audit Missing @param for all function parameters
21:     function setUint(bytes32, uint256) external;
/// @audit Missing @param for all function parameters
22:     function setUintDelta(bytes32, int256) external returns (uint256);
/// @audit Missing @param for all function parameters
23:     function setAddress(bytes32, address) external returns (address);

/// @audit Missing @param for all function parameters
27:     function exec(address) external view returns (bool); 
/// @audit Missing @param for all function parameters
28:     function transfer(address, address, uint256) external;

/// @audit Missing @param for all function parameters
32:     function exec(address) external view returns (bool); 

/// @audit Missing @param for all function parameters
36:     function borrow(uint256) external returns (uint256); 
/// @audit Missing @param for all function parameters
37:     function repay(uint256) external returns (uint256);

/// @audit Missing @param for all function parameters
41:     function price(address) external view returns (uint256); 
/// @audit Missing @param for all function parameters
42:     function value(address, uint256) external view returns (uint256);
/// @audit Missing @param for all function parameters
43:     function convert(address, address, uint256) external view returns (uint256);
/// @audit Missing @param for all function parameters
44:     function swap(address, address, uint256, uint256, address) external returns (uint256);

/// @audit Missing @param for all function parameters
49:     function rate(uint256) external view returns (uint256); 
/// @audit Missing @param for all function parameters
50:     function exit(address) external;
/// @audit Missing @param for all function parameters
51:     function move(address) external;

/// @audit Missing @param for all function parameters
55:     function exec(address) external view returns (bool); 
/// @audit Missing @param for all function parameters
56:     function mint(address, uint256) external returns (uint256);
/// @audit Missing @param for all function parameters
57:     function burn(address, uint256) external returns (uint256);
/// @audit Missing @param for all function parameters
58:     function kill(address, uint256, address) external returns (bytes memory);

/// @audit Missing @param for all function parameters
62:     function check(address) external view returns (bool); 

/// @audit Missing @param for all function parameters
144:     constructor(address _store, address _helper) { 

/// @audit Missing @param for all function parameters
162:     function file(bytes32 what, address data) external auth { 

/// @audit Missing @param for all function parameters
188:     function file(bytes32 what, uint256 data) external auth { 

/// @audit Missing @param for all function parameters
210:     function strategyNew(uint256 index, address implementation) external auth { 

/// @audit Missing @param for all function parameters
219:     function strategyUgrade(uint256 index, address implementation) external auth { 

/// @audit Missing @param for all function parameters
227:     function strategySetStatus(uint256 index, uint256 status) external auth { 

/// @audit Missing @param for all function parameters
233:     function strategySetCap(uint256 index, uint256 cap) external auth { 

/// @audit Missing @param for all function parameters
239:     function collateralSetFactor(address token, uint256 factor) external auth { 

/// @audit Missing @param for all function parameters
245:     function collateralSetCap(address token, uint256 cap) external auth { 

/// @audit Missing @param for all function parameters
251:     function collect(address token) external auth { 

/// @audit Missing @param for all function parameters
255:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external loop returns (uint256) { 

/// @audit Missing @param for all function parameters
295:     function edit(uint256 id, int256 borrow, int256 collateral) external loop { 

/// @audit Missing @param for all function parameters
388:     function killRepayment(uint256 id) external view returns (uint256) { 

/// @audit Missing @param for all function parameters
396:     function kill(uint256 id) external loop returns (address, bytes memory) { 

/// @audit Missing @param for all function parameters
446:     function life(uint256 id) external view returns (uint256) { 

/// @audit Missing @param for all function parameters
451:     function _life(Position memory p) internal view returns (uint256) { 

/// @audit Missing @param for all function parameters
466:     function getPosition(uint256 id) public view returns (Position memory p) { 

/// @audit Missing @param for all function parameters
477:     function setPosition(uint256 id, Position memory p) internal { 

/// @audit Missing @param for all function parameters
488:     function getStrategy(uint256 id) public view returns (Strategy memory s) { 

/// @audit Missing @param for all function parameters
499:     function push(address asset, address user, uint256 amount) internal { 

/// @audit Missing @param for all function parameters
506:     function pullToBank(address asset, address user, uint256 amount) internal { 

/// @audit Missing @param for all function parameters
513:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit Missing @param for all function parameters
5:     function approve(address, uint256) external returns (bool); 
/// @audit Missing @param for all function parameters
6:     function transfer(address, uint256) external returns (bool);

/// @audit Missing @param for all function parameters
10:     function mint(uint256 amount) external returns (uint256 shares); 
/// @audit Missing @param for all function parameters
11:     function burn(uint256 shares) external returns (uint256 amount);
/// @audit Missing @param for all function parameters
12:     function kill(uint256 shares, address to) external returns (bytes memory);

/// @audit Missing @param for all function parameters
24:     constructor(address _asset) { 

/// @audit Missing @param for all function parameters
34:     function file(bytes32 what, address data) public auth { 

/// @audit Missing @param for all function parameters
43:     function mint(address strategy, uint256 amount) public auth returns (uint256) { 

/// @audit Missing @param for all function parameters
48:     function burn(address strategy, uint256 shares) public auth returns (uint256) { 

/// @audit Missing @param for all function parameters
54:     function kill(address strategy, uint256 shares, address target) public auth returns (bytes memory) { 

/// @audit Missing @param for all function parameters
58:     function call(address strategy, uint256 value, bytes calldata data) public auth { 
```


```solidity
📁 File: PositionManager.sol

/// @audit Missing @param for all function parameters
9:     function balanceOf(address) external view returns (uint256); 
/// @audit Missing @param for all function parameters
10:     function approve(address, uint256) external returns (bool);
/// @audit Missing @param for all function parameters
11:     function transfer(address, uint256) external returns (bool);
/// @audit Missing @param for all function parameters
12:     function transferFrom(address, address, uint256) external returns (bool);

/// @audit Missing @param for all function parameters
28:     function rate(uint256 shares) external view returns (uint256); 

/// @audit Missing @param for all function parameters
48:     function getStrategy(uint256 id) external view returns (Strategy memory); 
/// @audit Missing @param for all function parameters
49:     function getPosition(uint256 id) external view returns (Position memory);
/// @audit Missing @param for all function parameters
50:     function life(uint256 id) external view returns (uint256);
/// @audit Missing @param for all function parameters
51:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external returns (uint256);
/// @audit Missing @param for all function parameters
52:     function edit(uint256 id, int256 borrow, int256 collateral) external;

/// @audit Missing @param for all function parameters
56:     function check(address) external view returns (bool); 

/// @audit Missing @param for all function parameters
60:     function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4); 

/// @audit Missing @param for all function parameters
91:     constructor(address _investor) { 

/// @audit Missing @param for all function parameters
101:     function file(bytes32 what, address data) external admin { 

/// @audit Missing @param for all function parameters
114:     function ownerOf(uint256 id) public view returns (address owner) { 

/// @audit Missing @param for all function parameters
118:     function balanceOf(address owner) public view returns (uint256) { 

/// @audit Missing @param for all function parameters
123:     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) { 

/// @audit Missing @param for all function parameters
127:     function tokensOfOwner(address owner, uint256 start, uint256 end) external view returns (uint256[] memory v) { 

/// @audit Missing @param for all function parameters
143:     function approve(address spender, uint256 id) public { 

/// @audit Missing @param for all function parameters
150:     function setApprovalForAll(address operator, bool approved) public { 

/// @audit Missing @param for all function parameters
155:     function moveId(address from, address to, uint256 id) internal { 

/// @audit Missing @param for all function parameters
182:     function transferFrom(address from, address to, uint256 id) public auth(id) { 

/// @audit Missing @param for all function parameters
188:     function safeTransferFrom(address from, address to, uint256 id) public { 

/// @audit Missing @param for all function parameters
198:     function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public { 

/// @audit Missing @param for all function parameters
208:     function supportsInterface(bytes4 interfaceId) public pure returns (bool) { 

/// @audit Missing @param for all function parameters
214:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow, address to) public returns (uint256) { 

/// @audit Missing @param for all function parameters
233:     function edit(uint256 id, int256 borrow, int256 collateral) public auth(id) { 

/// @audit Missing @param for all function parameters
244:     function burn(uint256 id) public auth(id) { 

/// @audit Missing @param for all function parameters
252:     function forceBurn(uint256 id) public auth(id) { 

/// @audit Missing @param for all function parameters
258:     function rely(address ast, uint256 amt) internal { 

/// @audit Missing @param for all function parameters
262:     function pull(address ast, address usr, uint256 amt) internal { 

/// @audit Missing @param for all function parameters
266:     function push(address ast, address usr) internal { 

/// @audit Missing @param for all function parameters
272:     function tokenURI(uint256 id) public view returns (string memory) { 

/// @audit Missing @param for all function parameters
293:     function generateImage(uint256 id) private view returns (string memory) { 

/// @audit Missing @param for all function parameters
309:     function generateHeader(uint256 id) private view returns (string memory) { 

/// @audit Missing @param for all function parameters
323:     function generateLabelVal(uint256 id) private view returns (string memory) { 

/// @audit Missing @param for all function parameters
339:     function generateLabelBor(uint256 id) private view returns (string memory) { 

/// @audit Missing @param for all function parameters
359:     function generateLabelLif(uint256 id) private view returns (string memory) { 

/// @audit Missing @param for all function parameters
374:     function formatNumber(uint256 n, uint256 d, uint256 f) internal pure returns (string memory) { 
```


```solidity
📁 File: Store.sol

/// @audit Missing @param for all function parameters
35:     function file(bytes32 what, address data) external auth { 

/// @audit Missing @param for all function parameters
44:     function getUint(bytes32 key) external view returns (uint256) { 

/// @audit Missing @param for all function parameters
47:     function setUint(bytes32 key, uint256 value) external auth returns (uint256) { 

/// @audit Missing @param for all function parameters
51:     function setUintDelta(bytes32 key, int256 value) external auth returns (uint256) { 

/// @audit Missing @param for all function parameters
59:     function removeUint(bytes32 key) external auth { 

/// @audit Missing @param for all function parameters
62:     function getInt(bytes32 key) external view returns (int256) { 

/// @audit Missing @param for all function parameters
65:     function setInt(bytes32 key, int256 value) external auth returns (int256) { 

/// @audit Missing @param for all function parameters
69:     function setIntDelta(bytes32 key, int256 value) external auth returns (int256) { 

/// @audit Missing @param for all function parameters
74:     function removeInt(bytes32 key) external auth { 

/// @audit Missing @param for all function parameters
77:     function getAddress(bytes32 key) external view returns (address) { 

/// @audit Missing @param for all function parameters
80:     function setAddress(bytes32 key, address value) external auth returns (address) { 

/// @audit Missing @param for all function parameters
84:     function removeAddress(bytes32 key) external auth { 

/// @audit Missing @param for all function parameters
87:     function getBool(bytes32 key) external view returns (bool) { 

/// @audit Missing @param for all function parameters
90:     function setBool(bytes32 key, bool value) external auth returns (bool) { 

/// @audit Missing @param for all function parameters
94:     function removeBool(bytes32 key) external auth { 

/// @audit Missing @param for all function parameters
97:     function getString(bytes32 key) external view returns (string memory) { 

/// @audit Missing @param for all function parameters
100:     function setString(bytes32 key, string memory value) external auth returns (string memory) { 

/// @audit Missing @param for all function parameters
104:     function removeString(bytes32 key) external auth { 

/// @audit Missing @param for all function parameters
107:     function getBytes32(bytes32 key) external view returns (bytes32) { 

/// @audit Missing @param for all function parameters
110:     function setBytes32(bytes32 key, bytes32 value) external auth returns (bytes32) { 

/// @audit Missing @param for all function parameters
114:     function removeBytes32(bytes32 key) external auth { 

/// @audit Missing @param for all function parameters
118:     function getBytes32Array(bytes32 key) external view returns (bytes32[] memory) { 

/// @audit Missing @param for all function parameters
121:     function setBytes32Array(bytes32 key, bytes32[] memory value) external auth { 

/// @audit Missing @param for all function parameters
124:     function removeBytes32Array(bytes32 key) external auth { 

/// @audit Missing @param for all function parameters
128:     function containsBytes32(bytes32 key, bytes32 value) external view returns (bool) { 

/// @audit Missing @param for all function parameters
131:     function getBytes32Count(bytes32 key) external view returns (uint256) { 

/// @audit Missing @param for all function parameters
134:     function getBytes32ValuesAt(bytes32 key, uint256 start, uint256 end) external view returns (bytes32[] memory v) { 

/// @audit Missing @param for all function parameters
140:     function addBytes32(bytes32 key, bytes32 value) external auth { 

/// @audit Missing @param for all function parameters
147:     function removeBytes32(bytes32 key, bytes32 value) external auth { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit Missing @param for all function parameters
48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _xgrail,
52:         address _strategyHelperUniswapV3,
53:         address _uniProxy,
54:         address _quoter,
55:         address _hypervisor,
56:         address _nftPool,
57:         address _targetAsset,
58:         bytes memory _pathToLp
59:     ) {

/// @audit Missing @param for all function parameters
90:     function file(bytes32 what, address data) external auth { 

/// @audit Missing @param for all function parameters
107:     function file(bytes32 what, uint256 data) external auth { 

/// @audit Missing @param for all function parameters
119:     function setPathToLp(bytes calldata newPathToLp) external auth { 

/// @audit Missing @param for all function parameters
123:     function setNitroPool(address _nitroPool) external auth { 

/// @audit Missing @param for all function parameters
133:     function xgrailRedeem(uint256 amount, uint256 duration) external auth { 

/// @audit Missing @param for all function parameters
137:     function xgrailFinalizeRedeem(uint256 index) external auth { 

/// @audit Missing @param for all function parameters
141:     function mint(uint256 amount) external auth loop returns (uint256) { 

/// @audit Missing @param for all function parameters
170:     function burn(uint256 shares) external auth loop returns (uint256) { 

/// @audit Missing @param for all function parameters
193:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit Missing @param for all function parameters
206:     function stake(uint256 amount) internal { 

/// @audit Missing @param for all function parameters
218:     function unstake(uint256 amount) internal { 

/// @audit Missing @param for all function parameters
276:     function exit(address strategy) external auth { 

/// @audit Missing @param for all function parameters
284:     function move(address old) external auth { 

/// @audit Missing @param for all function parameters
293:     function rate(uint256 shares) public view returns (uint256) { 

/// @audit Missing @param for all function parameters
297:     function quoteAddLiquidity(uint256 amt, address trgtAst, bytes memory path) private returns (uint256, uint256) { 

/// @audit Missing @param for all function parameters
320:     function quoteAndSwap(address trgtAst, uint256 amt, uint256 slp) private returns (uint256 amt0, uint256 amt1) { 

/// @audit Missing @param for all function parameters
338:     function swap(address trgtAst, address ast, bytes memory path, uint256 toLp, uint256 slp) private { 

/// @audit Missing @param for all function parameters
376:     function getPosition(uint160 midX96, int24 minTick, int24 maxTick) private view returns (uint256, uint256) { 

/// @audit Missing @param for all function parameters
390:     function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external returns (bytes4) { 

/// @audit Missing @param for all function parameters
397:     function onNFTHarvest(address, address, uint256, uint256, uint256) public pure returns (bool) { 

/// @audit Missing @param for all function parameters
401:     function onNFTAddToPosition(address, uint256, uint256) public pure returns (bool) { 

/// @audit Missing @param for all function parameters
405:     function onNFTWithdraw(address, uint256, uint256) public pure returns (bool) { 

/// @audit Missing @param for all function parameters
409:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

/// @audit Missing @param for all function parameters
416:     function balanceOf(address) external view returns (uint256); 
/// @audit Missing @param for all function parameters
417:     function approve(address, uint256) external;
/// @audit Missing @param for all function parameters
418:     function transfer(address, uint256) external;
/// @audit Missing @param for all function parameters
419:     function transferFrom(address, address, uint256) external;

/// @audit Missing @param for all function parameters
423:     function value(address, uint256) external view returns (uint256); 
/// @audit Missing @param for all function parameters
424:     function convert(address, address, uint256) external view returns (uint256);
/// @audit Missing @param for all function parameters
425:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

/// @audit Missing @param for all function parameters
429:     function swap(address ast, bytes calldata path, uint256 amt, uint256 min, address to) external; 

/// @audit Missing @param for all function parameters
433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares); 
/// @audit Missing @param for all function parameters
434:     function getDepositAmount(address pos, address token, uint256 deposit) external view returns (uint256 amountStart, uint256 amountEnd);

/// @audit Missing @param for all function parameters
438:     function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut); 

/// @audit Missing @param for all function parameters
442:     function withdraw(uint256 shares, address to, address from, uint256[4] memory minAmounts) external returns (uint256 amount0, uint256 amount1); 

/// @audit Missing @param for all function parameters
454:     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external; 
/// @audit Missing @param for all function parameters
455:     function createPosition(uint256 amount, uint256 lockDuration) external;
/// @audit Missing @param for all function parameters
456:     function addToPosition(uint256 tokenId, uint256 amountToAdd) external;
/// @audit Missing @param for all function parameters
457:     function withdrawFromPosition(uint256 tokenId, uint256 amountToWithdraw) external;
/// @audit Missing @param for all function parameters
458:     function harvestPosition(uint256 tokenId) external;
/// @audit Missing @param for all function parameters
459:     function getStakingPosition(uint256 tokenId) external view returns (

/// @audit Missing @param for all function parameters
468:     function withdraw(uint256 tokenId) external; 

/// @audit Missing @param for all function parameters
474:     function getTimepoints(uint32[] calldata secondsAgos) external view returns ( 

/// @audit Missing @param for all function parameters
480:     function positions(bytes32 key) external view returns ( 

/// @audit Missing @param for all function parameters
491:   function redeem(uint256 xGrailAmount, uint256 duration) external; 
/// @audit Missing @param for all function parameters
492:   function finalizeRedeem(uint256 redeemIndex) external;
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit Missing @param for all function parameters
48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _exchangeRouter,
52:         address _reader,
53:         address _depositHandler,
54:         address _withdrawalHandler,
55:         address _dataStore,
56:         address _market
57:     ) {

/// @audit Missing @param for all function parameters
94:     function file(bytes32 what, address data) external auth { 

/// @audit Missing @param for all function parameters
115:     function file(bytes32 what, uint256 data) external auth { 

/// @audit Missing @param for all function parameters
138:     function withdrawAirdrop(address token) external auth { 

/// @audit Missing @param for all function parameters
143:     function mint(uint256 amount) external auth loop returns (uint256) { 

/// @audit Missing @param for all function parameters
159:     function burn(uint256 shares) external auth loop returns (uint256) { 

/// @audit Missing @param for all function parameters
171:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit Missing @param for all function parameters
283:     function exit(address strategy) external auth { 

/// @audit Missing @param for all function parameters
292:     function move(address old) external auth {} 

/// @audit Missing @param for all function parameters
294:     function rate(uint256 shares) public view returns (uint256) { 

/// @audit Missing @param for all function parameters
304:     function marketTokenPrice(bool isDeposit) public view returns (uint256) { 

/// @audit Missing @param for all function parameters
325:     function gmxPrice(address token, bool isIndex) internal view returns (IPrice.Props memory) { 

/// @audit Missing @param for all function parameters
335:     function afterDepositExecution(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 

/// @audit Missing @param for all function parameters
340:     function afterDepositCancellation(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 

/// @audit Missing @param for all function parameters
345:     function afterWithdrawalExecution(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 

/// @audit Missing @param for all function parameters
353:     function afterWithdrawalCancellation(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 

/// @audit Missing @param for all function parameters
358:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

/// @audit Missing @param for all function parameters
366:     function balanceOf(address) external view returns (uint256); 
/// @audit Missing @param for all function parameters
367:     function approve(address, uint256) external;
/// @audit Missing @param for all function parameters
368:     function transfer(address, uint256) external;
/// @audit Missing @param for all function parameters
369:     function transferFrom(address, address, uint256) external;

/// @audit Missing @param for all function parameters
373:     function price(address) external view returns (uint256); 
/// @audit Missing @param for all function parameters
374:     function value(address, uint256) external view returns (uint256);
/// @audit Missing @param for all function parameters
375:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

/// @audit Missing @param for all function parameters
394:     function getUint(bytes32 key) external view returns (uint256); 
/// @audit Missing @param for all function parameters
395:     function getAddress(bytes32 key) external view returns (address);
/// @audit Missing @param for all function parameters
396:     function getBytes32(bytes32 key) external view returns (bytes32);

/// @audit Missing @param for all function parameters
429:     function sendWnt(address receiver, uint256 amount) external payable; 
/// @audit Missing @param for all function parameters
430:     function sendTokens(address token, address receiver, uint256 amount) external payable;
/// @audit Missing @param for all function parameters
431:     function createDeposit(CreateDepositParams calldata params) external payable returns (bytes32);
/// @audit Missing @param for all function parameters
432:     function createWithdrawal(CreateWithdrawalParams calldata params) external payable returns (bytes32);
/// @audit Missing @param for all function parameters
433:     function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);

/// @audit Missing @param for all function parameters
451:     function mint(address account, uint256 amount) external; 

/// @audit Missing @param for all function parameters
478:     function getMarket(address dataStore, address key) external view returns (IMarket.Props memory); 
/// @audit Missing @param for all function parameters
479:     function getMarketTokenPrice(

/// @audit Missing @param for all function parameters
488:     function getWithdrawalAmountOut( 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit Missing @param for all function parameters
29:     constructor(address _asset, address _strategyHelper, address _rewarder, uint256 _poolId) { 

/// @audit Missing @param for all function parameters
52:     function file(bytes32 what, address data) external auth { 

/// @audit Missing @param for all function parameters
63:     function file(bytes32 what, uint256 data) external auth { 

/// @audit Missing @param for all function parameters
72:     function rate(uint256 sha) public view returns (uint256) { 

/// @audit Missing @param for all function parameters
90:     function mint(uint256 amount) public auth loop returns (uint256) {  

/// @audit Missing @param for all function parameters
117:     function burn(uint256 shares) public auth loop returns (uint256) { 

/// @audit Missing @param for all function parameters
141:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit Missing @param for all function parameters
182:     function exit(address strategy) public auth { 

/// @audit Missing @param for all function parameters
186:     function move(address old) public auth { 

/// @audit Missing @param for all function parameters
196:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

/// @audit Missing @param for all function parameters
201:     function sqrt(uint256 a) internal pure returns (uint256) { 

/// @audit Missing @param for all function parameters
216:     function log2(uint256 value) internal pure returns (uint256) { 

/// @audit Missing @param for all function parameters
256:     function balanceOf(address) external view returns (uint256); 
/// @audit Missing @param for all function parameters
257:     function approve(address, uint256) external returns (bool);
/// @audit Missing @param for all function parameters
258:     function transfer(address, uint256) external returns (bool);
/// @audit Missing @param for all function parameters
259:     function transferFrom(address, address, uint256) external returns (bool);

/// @audit Missing @param for all function parameters
263:     function price(address) external view returns (uint256); 
/// @audit Missing @param for all function parameters
264:     function value(address, uint256) external view returns (uint256);
/// @audit Missing @param for all function parameters
265:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

/// @audit Missing @param for all function parameters
275:     function mint(address) external returns (uint256 liquidity); 
/// @audit Missing @param for all function parameters
276:     function burn(address) external returns (uint256 amount0, uint256 amount1);
/// @audit Missing @param for all function parameters
277:     function swap(uint256, uint256, address, bytes calldata) external;
/// @audit Missing @param for all function parameters
278:     function skim(address to) external;

/// @audit Missing @param for all function parameters
283:     function lpToken(uint256) external view returns (address); 
/// @audit Missing @param for all function parameters
284:     function pendingSushi(uint256, address) external view returns (uint256);
/// @audit Missing @param for all function parameters
285:     function userInfo(uint256, address) external view returns (uint256, int256);
/// @audit Missing @param for all function parameters
286:     function deposit(uint256, uint256, address) external;
/// @audit Missing @param for all function parameters
287:     function withdraw(uint256, uint256, address) external;
/// @audit Missing @param for all function parameters
288:     function harvest(uint256, address) external;
```


```solidity
📁 File: UtilFarmingBalances.sol

/// @audit Missing @param for all function parameters
6:     function positions(uint256) external view returns (address, address, uint256, uint256, uint256, uint256, uint256); 

/// @audit Missing @param for all function parameters
10:     function ownerOf(uint256) external view returns (address); 

/// @audit Missing @param for all function parameters
14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) { 
```


```solidity
📁 File: Whitelist.sol

/// @audit Missing @param for all function parameters
23:     function file(bytes32 what, address data) external auth { 

/// @audit Missing @param for all function parameters
34:     function batchWhitelist(address[] memory addresses, bool status) external auth { 

/// @audit Missing @param for all function parameters
42:     function check(address user) external view returns (bool) { 
```


</details>


---
### [NC&#x2011;88] NatSpec: Functions missing NatSpec `@return` tag
It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.

<details>
<summary><i>There are 200 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit Missing @return for all function parameters
5:     function transfer(address, uint256) external returns (bool); 
```


```solidity
📁 File: Helper.sol

/// @audit Missing @return for all function parameters
5:     function balanceOf(address) external view returns (uint256); 

/// @audit Missing @return for all function parameters
11:     function killRepayment(uint256) external returns (uint256); 
/// @audit Missing @return for all function parameters
12:     function kill(uint256 id) external returns (address, bytes memory);

/// @audit Missing @return for all function parameters
20:     function swap(address, address, uint256, uint256, address) external returns (uint256); 

/// @audit Missing @return for all function parameters
24:     function token0() external view returns (address); 
/// @audit Missing @return for all function parameters
25:     function token1() external view returns (address);

/// @audit Missing @return for all function parameters
48:     function executeOperation( 
49:       address,
50:       uint256 amount,
51:       uint256 premium,
52:       address initiator,
53:       bytes calldata params
54:     ) external returns (bool) {
```


```solidity
📁 File: Investor.sol

/// @audit Missing @return for all function parameters
5:     function decimals() external view returns (uint8); 
/// @audit Missing @return for all function parameters
6:     function balanceOf(address) external view returns (uint256);

/// @audit Missing @return for all function parameters
8:     function transfer(address, uint256) external returns (bool); 
/// @audit Missing @return for all function parameters
9:     function transferFrom(address, address, uint256) external returns (bool);

/// @audit Missing @return for all function parameters
13:     function decimals() external view returns (uint8); 
/// @audit Missing @return for all function parameters
14:     function latestAnswer() external view returns (int256);

/// @audit Missing @return for all function parameters
18:     function exec(address) external view returns (bool); 
/// @audit Missing @return for all function parameters
19:     function getUint(bytes32) external view returns (uint256);
/// @audit Missing @return for all function parameters
20:     function getAddress(bytes32) external view returns (address);

/// @audit Missing @return for all function parameters
22:     function setUintDelta(bytes32, int256) external returns (uint256); 
/// @audit Missing @return for all function parameters
23:     function setAddress(bytes32, address) external returns (address);

/// @audit Missing @return for all function parameters
27:     function exec(address) external view returns (bool); 

/// @audit Missing @return for all function parameters
32:     function exec(address) external view returns (bool); 
/// @audit Missing @return for all function parameters
33:     function asset() external view returns (address);
/// @audit Missing @return for all function parameters
34:     function oracle() external view returns (address);
/// @audit Missing @return for all function parameters
35:     function getUpdatedIndex() external view returns (uint256);
/// @audit Missing @return for all function parameters
36:     function borrow(uint256) external returns (uint256);
/// @audit Missing @return for all function parameters
37:     function repay(uint256) external returns (uint256);

/// @audit Missing @return for all function parameters
41:     function price(address) external view returns (uint256); 
/// @audit Missing @return for all function parameters
42:     function value(address, uint256) external view returns (uint256);
/// @audit Missing @return for all function parameters
43:     function convert(address, address, uint256) external view returns (uint256);
/// @audit Missing @return for all function parameters
44:     function swap(address, address, uint256, uint256, address) external returns (uint256);

/// @audit Missing @return for all function parameters
48:     function totalShares() external view returns (uint256); 
/// @audit Missing @return for all function parameters
49:     function rate(uint256) external view returns (uint256);

/// @audit Missing @return for all function parameters
55:     function exec(address) external view returns (bool); 
/// @audit Missing @return for all function parameters
56:     function mint(address, uint256) external returns (uint256);
/// @audit Missing @return for all function parameters
57:     function burn(address, uint256) external returns (uint256);
/// @audit Missing @return for all function parameters
58:     function kill(address, uint256, address) external returns (bytes memory);

/// @audit Missing @return for all function parameters
62:     function check(address) external view returns (bool); 

/// @audit Missing @return for all function parameters
255:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external loop returns (uint256) { 

/// @audit Missing @return for all function parameters
388:     function killRepayment(uint256 id) external view returns (uint256) { 

/// @audit Missing @return for all function parameters
396:     function kill(uint256 id) external loop returns (address, bytes memory) { 

/// @audit Missing @return for all function parameters
446:     function life(uint256 id) external view returns (uint256) { 

/// @audit Missing @return for all function parameters
451:     function _life(Position memory p) internal view returns (uint256) { 

/// @audit Missing @return for all function parameters
466:     function getPosition(uint256 id) public view returns (Position memory p) { 

/// @audit Missing @return for all function parameters
488:     function getStrategy(uint256 id) public view returns (Strategy memory s) { 

/// @audit Missing @return for all function parameters
495:     function getPool() public view returns (address) { 

/// @audit Missing @return for all function parameters
513:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit Missing @return for all function parameters
5:     function approve(address, uint256) external returns (bool); 
/// @audit Missing @return for all function parameters
6:     function transfer(address, uint256) external returns (bool);

/// @audit Missing @return for all function parameters
10:     function mint(uint256 amount) external returns (uint256 shares); 
/// @audit Missing @return for all function parameters
11:     function burn(uint256 shares) external returns (uint256 amount);
/// @audit Missing @return for all function parameters
12:     function kill(uint256 shares, address to) external returns (bytes memory);

/// @audit Missing @return for all function parameters
43:     function mint(address strategy, uint256 amount) public auth returns (uint256) { 

/// @audit Missing @return for all function parameters
48:     function burn(address strategy, uint256 shares) public auth returns (uint256) { 

/// @audit Missing @return for all function parameters
54:     function kill(address strategy, uint256 shares, address target) public auth returns (bytes memory) { 
```


```solidity
📁 File: PositionManager.sol

/// @audit Missing @return for all function parameters
8:     function decimals() external view returns (uint8); 
/// @audit Missing @return for all function parameters
9:     function balanceOf(address) external view returns (uint256);
/// @audit Missing @return for all function parameters
10:     function approve(address, uint256) external returns (bool);
/// @audit Missing @return for all function parameters
11:     function transfer(address, uint256) external returns (bool);
/// @audit Missing @return for all function parameters
12:     function transferFrom(address, address, uint256) external returns (bool);

/// @audit Missing @return for all function parameters
16:     function latestAnswer() external view returns (int256); 
/// @audit Missing @return for all function parameters
17:     function decimals() external view returns (uint8);

/// @audit Missing @return for all function parameters
21:     function asset() external view returns (address); 
/// @audit Missing @return for all function parameters
22:     function oracle() external view returns (address);
/// @audit Missing @return for all function parameters
23:     function getUpdatedIndex() external view returns (uint256);

/// @audit Missing @return for all function parameters
27:     function name() external view returns (string memory); 
/// @audit Missing @return for all function parameters
28:     function rate(uint256 shares) external view returns (uint256);

/// @audit Missing @return for all function parameters
47:     function getPool() external view returns (address); 
/// @audit Missing @return for all function parameters
48:     function getStrategy(uint256 id) external view returns (Strategy memory);
/// @audit Missing @return for all function parameters
49:     function getPosition(uint256 id) external view returns (Position memory);
/// @audit Missing @return for all function parameters
50:     function life(uint256 id) external view returns (uint256);
/// @audit Missing @return for all function parameters
51:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external returns (uint256);

/// @audit Missing @return for all function parameters
56:     function check(address) external view returns (bool); 

/// @audit Missing @return for all function parameters
60:     function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4); 

/// @audit Missing @return for all function parameters
114:     function ownerOf(uint256 id) public view returns (address owner) { 

/// @audit Missing @return for all function parameters
118:     function balanceOf(address owner) public view returns (uint256) { 

/// @audit Missing @return for all function parameters
123:     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) { 

/// @audit Missing @return for all function parameters
127:     function tokensOfOwner(address owner, uint256 start, uint256 end) external view returns (uint256[] memory v) { 

/// @audit Missing @return for all function parameters
208:     function supportsInterface(bytes4 interfaceId) public pure returns (bool) { 

/// @audit Missing @return for all function parameters
214:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow, address to) public returns (uint256) { 

/// @audit Missing @return for all function parameters
272:     function tokenURI(uint256 id) public view returns (string memory) { 

/// @audit Missing @return for all function parameters
293:     function generateImage(uint256 id) private view returns (string memory) { 

/// @audit Missing @return for all function parameters
309:     function generateHeader(uint256 id) private view returns (string memory) { 

/// @audit Missing @return for all function parameters
323:     function generateLabelVal(uint256 id) private view returns (string memory) { 

/// @audit Missing @return for all function parameters
339:     function generateLabelBor(uint256 id) private view returns (string memory) { 

/// @audit Missing @return for all function parameters
359:     function generateLabelLif(uint256 id) private view returns (string memory) { 

/// @audit Missing @return for all function parameters
374:     function formatNumber(uint256 n, uint256 d, uint256 f) internal pure returns (string memory) { 
```


```solidity
📁 File: Store.sol

/// @audit Missing @return for all function parameters
44:     function getUint(bytes32 key) external view returns (uint256) { 

/// @audit Missing @return for all function parameters
47:     function setUint(bytes32 key, uint256 value) external auth returns (uint256) { 

/// @audit Missing @return for all function parameters
51:     function setUintDelta(bytes32 key, int256 value) external auth returns (uint256) { 

/// @audit Missing @return for all function parameters
62:     function getInt(bytes32 key) external view returns (int256) { 

/// @audit Missing @return for all function parameters
65:     function setInt(bytes32 key, int256 value) external auth returns (int256) { 

/// @audit Missing @return for all function parameters
69:     function setIntDelta(bytes32 key, int256 value) external auth returns (int256) { 

/// @audit Missing @return for all function parameters
77:     function getAddress(bytes32 key) external view returns (address) { 

/// @audit Missing @return for all function parameters
80:     function setAddress(bytes32 key, address value) external auth returns (address) { 

/// @audit Missing @return for all function parameters
87:     function getBool(bytes32 key) external view returns (bool) { 

/// @audit Missing @return for all function parameters
90:     function setBool(bytes32 key, bool value) external auth returns (bool) { 

/// @audit Missing @return for all function parameters
97:     function getString(bytes32 key) external view returns (string memory) { 

/// @audit Missing @return for all function parameters
100:     function setString(bytes32 key, string memory value) external auth returns (string memory) { 

/// @audit Missing @return for all function parameters
107:     function getBytes32(bytes32 key) external view returns (bytes32) { 

/// @audit Missing @return for all function parameters
110:     function setBytes32(bytes32 key, bytes32 value) external auth returns (bytes32) { 

/// @audit Missing @return for all function parameters
118:     function getBytes32Array(bytes32 key) external view returns (bytes32[] memory) { 

/// @audit Missing @return for all function parameters
128:     function containsBytes32(bytes32 key, bytes32 value) external view returns (bool) { 

/// @audit Missing @return for all function parameters
131:     function getBytes32Count(bytes32 key) external view returns (uint256) { 

/// @audit Missing @return for all function parameters
134:     function getBytes32ValuesAt(bytes32 key, uint256 start, uint256 end) external view returns (bytes32[] memory v) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit Missing @return for all function parameters
141:     function mint(uint256 amount) external auth loop returns (uint256) { 

/// @audit Missing @return for all function parameters
170:     function burn(uint256 shares) external auth loop returns (uint256) { 

/// @audit Missing @return for all function parameters
193:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit Missing @return for all function parameters
293:     function rate(uint256 shares) public view returns (uint256) { 

/// @audit Missing @return for all function parameters
297:     function quoteAddLiquidity(uint256 amt, address trgtAst, bytes memory path) private returns (uint256, uint256) { 

/// @audit Missing @return for all function parameters
320:     function quoteAndSwap(address trgtAst, uint256 amt, uint256 slp) private returns (uint256 amt0, uint256 amt1) { 

/// @audit Missing @return for all function parameters
344:     function valueLiquidity() private view returns (uint256) { 

/// @audit Missing @return for all function parameters
370:     function totalManagedAssets() private view returns (uint256) { 

/// @audit Missing @return for all function parameters
376:     function getPosition(uint160 midX96, int24 minTick, int24 maxTick) private view returns (uint256, uint256) { 

/// @audit Missing @return for all function parameters
390:     function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external returns (bytes4) { 

/// @audit Missing @return for all function parameters
397:     function onNFTHarvest(address, address, uint256, uint256, uint256) public pure returns (bool) { 

/// @audit Missing @return for all function parameters
401:     function onNFTAddToPosition(address, uint256, uint256) public pure returns (bool) { 

/// @audit Missing @return for all function parameters
405:     function onNFTWithdraw(address, uint256, uint256) public pure returns (bool) { 

/// @audit Missing @return for all function parameters
409:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

/// @audit Missing @return for all function parameters
415:     function symbol() external view returns (string memory); 
/// @audit Missing @return for all function parameters
416:     function balanceOf(address) external view returns (uint256);

/// @audit Missing @return for all function parameters
423:     function value(address, uint256) external view returns (uint256); 
/// @audit Missing @return for all function parameters
424:     function convert(address, address, uint256) external view returns (uint256);
/// @audit Missing @return for all function parameters
425:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

/// @audit Missing @return for all function parameters
433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares); 
/// @audit Missing @return for all function parameters
434:     function getDepositAmount(address pos, address token, uint256 deposit) external view returns (uint256 amountStart, uint256 amountEnd);

/// @audit Missing @return for all function parameters
438:     function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut); 

/// @audit Missing @return for all function parameters
442:     function withdraw(uint256 shares, address to, address from, uint256[4] memory minAmounts) external returns (uint256 amount0, uint256 amount1); 
/// @audit Missing @return for all function parameters
443:     function pool() external view returns (IAlgebraPool);
/// @audit Missing @return for all function parameters
444:     function token0() external view returns (IERC20);
/// @audit Missing @return for all function parameters
445:     function token1() external view returns (IERC20);
/// @audit Missing @return for all function parameters
446:     function totalSupply() external view returns (uint256);
/// @audit Missing @return for all function parameters
447:     function baseLower() external view returns (int24);
/// @audit Missing @return for all function parameters
448:     function baseUpper() external view returns (int24);
/// @audit Missing @return for all function parameters
449:     function limitLower() external view returns (int24);
/// @audit Missing @return for all function parameters
450:     function limitUpper() external view returns (int24);

/// @audit Missing @return for all function parameters
459:     function getStakingPosition(uint256 tokenId) external view returns ( 

/// @audit Missing @return for all function parameters
472:     function token0() external view returns (address); 
/// @audit Missing @return for all function parameters
473:     function token1() external view returns (address);
/// @audit Missing @return for all function parameters
474:     function getTimepoints(uint32[] calldata secondsAgos) external view returns (

/// @audit Missing @return for all function parameters
480:     function positions(bytes32 key) external view returns ( 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit Missing @return for all function parameters
143:     function mint(uint256 amount) external auth loop returns (uint256) { 

/// @audit Missing @return for all function parameters
159:     function burn(uint256 shares) external auth loop returns (uint256) { 

/// @audit Missing @return for all function parameters
171:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit Missing @return for all function parameters
294:     function rate(uint256 shares) public view returns (uint256) { 

/// @audit Missing @return for all function parameters
304:     function marketTokenPrice(bool isDeposit) public view returns (uint256) { 

/// @audit Missing @return for all function parameters
325:     function gmxPrice(address token, bool isIndex) internal view returns (IPrice.Props memory) { 

/// @audit Missing @return for all function parameters
358:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

/// @audit Missing @return for all function parameters
364:     function symbol() external view returns (string memory); 
/// @audit Missing @return for all function parameters
365:     function decimals() external view returns (uint8);
/// @audit Missing @return for all function parameters
366:     function balanceOf(address) external view returns (uint256);

/// @audit Missing @return for all function parameters
373:     function price(address) external view returns (uint256); 
/// @audit Missing @return for all function parameters
374:     function value(address, uint256) external view returns (uint256);
/// @audit Missing @return for all function parameters
375:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

/// @audit Missing @return for all function parameters
379:     function depositVault() external view returns (address); 
/// @audit Missing @return for all function parameters
380:     function withdrawalVault() external view returns (address);

/// @audit Missing @return for all function parameters
384:     function latestRoundData() external view returns ( 

/// @audit Missing @return for all function parameters
394:     function getUint(bytes32 key) external view returns (uint256); 
/// @audit Missing @return for all function parameters
395:     function getAddress(bytes32 key) external view returns (address);
/// @audit Missing @return for all function parameters
396:     function getBytes32(bytes32 key) external view returns (bytes32);

/// @audit Missing @return for all function parameters
431:     function createDeposit(CreateDepositParams calldata params) external payable returns (bytes32); 
/// @audit Missing @return for all function parameters
432:     function createWithdrawal(CreateWithdrawalParams calldata params) external payable returns (bytes32);
/// @audit Missing @return for all function parameters
433:     function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);
/// @audit Missing @return for all function parameters
434:     function router() external returns (address);

/// @audit Missing @return for all function parameters
478:     function getMarket(address dataStore, address key) external view returns (IMarket.Props memory); 
/// @audit Missing @return for all function parameters
479:     function getMarketTokenPrice(

/// @audit Missing @return for all function parameters
488:     function getWithdrawalAmountOut( 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit Missing @return for all function parameters
72:     function rate(uint256 sha) public view returns (uint256) { 

/// @audit Missing @return for all function parameters
90:     function mint(uint256 amount) public auth loop returns (uint256) {  

/// @audit Missing @return for all function parameters
117:     function burn(uint256 shares) public auth loop returns (uint256) { 

/// @audit Missing @return for all function parameters
141:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit Missing @return for all function parameters
177:     function totalManagedAssets() public view returns (uint256) { 

/// @audit Missing @return for all function parameters
196:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

/// @audit Missing @return for all function parameters
201:     function sqrt(uint256 a) internal pure returns (uint256) { 

/// @audit Missing @return for all function parameters
216:     function log2(uint256 value) internal pure returns (uint256) { 

/// @audit Missing @return for all function parameters
254:     function symbol() external view returns (string memory); 
/// @audit Missing @return for all function parameters
255:     function decimals() external view returns (uint8);
/// @audit Missing @return for all function parameters
256:     function balanceOf(address) external view returns (uint256);
/// @audit Missing @return for all function parameters
257:     function approve(address, uint256) external returns (bool);
/// @audit Missing @return for all function parameters
258:     function transfer(address, uint256) external returns (bool);
/// @audit Missing @return for all function parameters
259:     function transferFrom(address, address, uint256) external returns (bool);

/// @audit Missing @return for all function parameters
263:     function price(address) external view returns (uint256); 
/// @audit Missing @return for all function parameters
264:     function value(address, uint256) external view returns (uint256);
/// @audit Missing @return for all function parameters
265:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

/// @audit Missing @return for all function parameters
269:     function token0() external view returns (address); 
/// @audit Missing @return for all function parameters
270:     function token1() external view returns (address);
/// @audit Missing @return for all function parameters
271:     function totalSupply() external view returns (uint256);
/// @audit Missing @return for all function parameters
272:     function getReserves() external view returns (uint112, uint112, uint32);
/// @audit Missing @return for all function parameters
273:     function price0CumulativeLast() external view returns (uint256);
/// @audit Missing @return for all function parameters
274:     function price1CumulativeLast() external view returns (uint256);
/// @audit Missing @return for all function parameters
275:     function mint(address) external returns (uint256 liquidity);
/// @audit Missing @return for all function parameters
276:     function burn(address) external returns (uint256 amount0, uint256 amount1);

/// @audit Missing @return for all function parameters
282:     function SUSHI() external view returns (address); 
/// @audit Missing @return for all function parameters
283:     function lpToken(uint256) external view returns (address);
/// @audit Missing @return for all function parameters
284:     function pendingSushi(uint256, address) external view returns (uint256);
/// @audit Missing @return for all function parameters
285:     function userInfo(uint256, address) external view returns (uint256, int256);
```


```solidity
📁 File: UtilFarmingBalances.sol

/// @audit Missing @return for all function parameters
5:     function nextPosition() external view returns (uint256); 
/// @audit Missing @return for all function parameters
6:     function positions(uint256) external view returns (address, address, uint256, uint256, uint256, uint256, uint256);

/// @audit Missing @return for all function parameters
10:     function ownerOf(uint256) external view returns (address); 

/// @audit Missing @return for all function parameters
14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) { 
```


```solidity
📁 File: Whitelist.sol

/// @audit Missing @return for all function parameters
42:     function check(address user) external view returns (bool) { 
```


</details>


---
### [NC&#x2011;89] NatSpec: Modifier declarations should have NatSpec descriptions
It is recommended that modifiers are fully annotated using NatSpec.

<details>
<summary><i>There are 14 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

21:     modifier auth() { 
```


```solidity
📁 File: Investor.sol

150:     modifier auth() { 

155:     modifier loop() { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

29:     modifier auth() { 
```


```solidity
📁 File: PositionManager.sol

96:     modifier admin() { 

134:     modifier auth(uint256 id) { 
```


```solidity
📁 File: Store.sol

30:     modifier auth() { 
```


```solidity
📁 File: StrategyCamelotV3.sol

78:     modifier loop() { 

85:     modifier auth() { 
```


```solidity
📁 File: StrategyGMXGM.sol

82:     modifier loop() { 

89:     modifier auth() { 
```


```solidity
📁 File: StrategySushiswap.sol

40:     modifier loop() { 

47:     modifier auth() { 
```


```solidity
📁 File: Whitelist.sol

18:     modifier auth() { 
```


</details>


---
### [NC&#x2011;90] NatSpec: Modifier missing NatSpec `@dev` tag
<details>
<summary><i>There are 14 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

20:  
21:     modifier auth() {
22:         if (!exec[msg.sender]) revert Unauthorized();
```


```solidity
📁 File: Investor.sol

149:  
150:     modifier auth() {
151:         if (!exec[msg.sender]) revert Unauthorized();

154:  
155:     modifier loop() {
156:         if (entered) revert NoReentering();
```


```solidity
📁 File: InvestorStrategyProxy.sol

28:  
29:     modifier auth() {
30:         if (!exec[msg.sender]) revert Unauthorized();
```


```solidity
📁 File: PositionManager.sol

95:  
96:     modifier admin() {
97:         if (!exec[msg.sender]) revert Unauthorized();

133:  
134:     modifier auth(uint256 id) {
135:         address owner = _ownerOf[id];
```


```solidity
📁 File: Store.sol

29:  
30:     modifier auth() {
31:         if (!exec[msg.sender]) revert Unauthorized();
```


```solidity
📁 File: StrategyCamelotV3.sol

77:  
78:     modifier loop() {
79:         if (entered) revert NoReentering();

84:  
85:     modifier auth() {
86:         if (!exec[msg.sender]) revert Unauthorized();
```


```solidity
📁 File: StrategyGMXGM.sol

81:  
82:     modifier loop() {
83:         if (entered) revert NoReentering();

88:  
89:     modifier auth() {
90:         if (!exec[msg.sender]) revert Unauthorized();
```


```solidity
📁 File: StrategySushiswap.sol

39:  
40:     modifier loop() {
41:         if (entered) revert NoReentering();

46:  
47:     modifier auth() {
48:         if (!exec[msg.sender]) revert Unauthorized();
```


```solidity
📁 File: Whitelist.sol

17:  
18:     modifier auth() {
19:         if (!exec[msg.sender]) revert Unauthorized();
```


</details>


---
### [NC&#x2011;91] NatSpec: Modifier missing NatSpec `@param` tag
It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.


<i>There is one instance of this issue:</i>

```solidity
📁 File: PositionManager.sol

/// @audit Missing @param for all modifier parameters
134:     modifier auth(uint256 id) { 
```



---
### [NC&#x2011;92] NatSpec: Struct declarations should have `@notice` tags
<details>
<summary><i>There are 42 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

127:     struct Strategy { 

133:     struct Position { 
```


```solidity
📁 File: PositionManager.sol

32:     struct Strategy { 

37:     struct Position { 

86:     struct Ids { 
```


```solidity
📁 File: Store.sol

15:     struct Bytes32Set { 
```


```solidity
📁 File: StrategyGMXGM.sol

400:     struct CreateDepositParams { 

415:     struct CreateWithdrawalParams { 

438:     struct Prices { 

444:     struct Props { 

455:     struct Props { 

462:     struct Props { 

498:     struct Props { 

504:     struct Addresses { 

516:     struct Numbers { 

525:     struct Flags { 

531:     struct Props { 

537:     struct Addresses { 

547:     struct Numbers { 

556:     struct Flags { 

562:     struct EventLogData { 

572:     struct AddressItems { 

577:     struct UintItems { 

582:     struct IntItems { 

587:     struct BoolItems { 

592:     struct Bytes32Items { 

597:     struct BytesItems { 

602:     struct StringItems { 

607:     struct AddressKeyValue { 

612:     struct AddressArrayKeyValue { 

617:     struct UintKeyValue { 

622:     struct UintArrayKeyValue { 

627:     struct IntKeyValue { 

632:     struct IntArrayKeyValue { 

637:     struct BoolKeyValue { 

642:     struct BoolArrayKeyValue { 

647:     struct Bytes32KeyValue { 

652:     struct Bytes32ArrayKeyValue { 

657:     struct BytesKeyValue { 

662:     struct BytesArrayKeyValue { 

667:     struct StringKeyValue { 

672:     struct StringArrayKeyValue { 
```


</details>


---
### [NC&#x2011;93] NatSpec: Struct declarations should have NatSpec descriptions
<details>
<summary><i>There are 42 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

127:     struct Strategy { 

133:     struct Position { 
```


```solidity
📁 File: PositionManager.sol

32:     struct Strategy { 

37:     struct Position { 

86:     struct Ids { 
```


```solidity
📁 File: Store.sol

15:     struct Bytes32Set { 
```


```solidity
📁 File: StrategyGMXGM.sol

400:     struct CreateDepositParams { 

415:     struct CreateWithdrawalParams { 

438:     struct Prices { 

444:     struct Props { 

455:     struct Props { 

462:     struct Props { 

498:     struct Props { 

504:     struct Addresses { 

516:     struct Numbers { 

525:     struct Flags { 

531:     struct Props { 

537:     struct Addresses { 

547:     struct Numbers { 

556:     struct Flags { 

562:     struct EventLogData { 

572:     struct AddressItems { 

577:     struct UintItems { 

582:     struct IntItems { 

587:     struct BoolItems { 

592:     struct Bytes32Items { 

597:     struct BytesItems { 

602:     struct StringItems { 

607:     struct AddressKeyValue { 

612:     struct AddressArrayKeyValue { 

617:     struct UintKeyValue { 

622:     struct UintArrayKeyValue { 

627:     struct IntKeyValue { 

632:     struct IntArrayKeyValue { 

637:     struct BoolKeyValue { 

642:     struct BoolArrayKeyValue { 

647:     struct Bytes32KeyValue { 

652:     struct Bytes32ArrayKeyValue { 

657:     struct BytesKeyValue { 

662:     struct BytesArrayKeyValue { 

667:     struct StringKeyValue { 

672:     struct StringArrayKeyValue { 
```


</details>


---
### [NC&#x2011;94] Non-`external`/`public` function names should begin with an underscore
According to the Solidity Style Guide, Non-`external`/`public` function names should begin with an <a href="https://docs.soliditylang.org/en/latest/style-guide.html#underscore-prefix-for-non-external-functions-and-variables">underscore</a>.

<details>
<summary><i>There are 29 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @audit _swap
76:     function swap(address _fromAsset) internal { 
```


```solidity
📁 File: Investor.sol

/// @audit _setPosition
477:     function setPosition(uint256 id, Position memory p) internal { 

/// @audit _push
499:     function push(address asset, address user, uint256 amount) internal { 

/// @audit _pullToBank
506:     function pullToBank(address asset, address user, uint256 amount) internal { 

/// @audit _min
513:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
```


```solidity
📁 File: PositionManager.sol

/// @audit _moveId
155:     function moveId(address from, address to, uint256 id) internal { 

/// @audit _rely
258:     function rely(address ast, uint256 amt) internal { 

/// @audit _pull
262:     function pull(address ast, address usr, uint256 amt) internal { 

/// @audit _push
266:     function push(address ast, address usr) internal { 

/// @audit _generateImage
293:     function generateImage(uint256 id) private view returns (string memory) { 

/// @audit _generateHeader
309:     function generateHeader(uint256 id) private view returns (string memory) { 

/// @audit _generateLabelVal
323:     function generateLabelVal(uint256 id) private view returns (string memory) { 

/// @audit _generateLabelBor
339:     function generateLabelBor(uint256 id) private view returns (string memory) { 

/// @audit _generateLabelLif
359:     function generateLabelLif(uint256 id) private view returns (string memory) { 

/// @audit _formatNumber
374:     function formatNumber(uint256 n, uint256 d, uint256 f) internal pure returns (string memory) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit _stake
206:     function stake(uint256 amount) internal { 

/// @audit _unstake
218:     function unstake(uint256 amount) internal { 

/// @audit _quoteAddLiquidity
297:     function quoteAddLiquidity(uint256 amt, address trgtAst, bytes memory path) private returns (uint256, uint256) { 

/// @audit _quoteAndSwap
320:     function quoteAndSwap(address trgtAst, uint256 amt, uint256 slp) private returns (uint256 amt0, uint256 amt1) { 

/// @audit _swap
338:     function swap(address trgtAst, address ast, bytes memory path, uint256 toLp, uint256 slp) private { 

/// @audit _valueLiquidity
344:     function valueLiquidity() private view returns (uint256) { 

/// @audit _totalManagedAssets
370:     function totalManagedAssets() private view returns (uint256) { 

/// @audit _getPosition
376:     function getPosition(uint160 midX96, int24 minTick, int24 maxTick) private view returns (uint256, uint256) { 

/// @audit _min
409:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit _gmxPrice
325:     function gmxPrice(address token, bool isIndex) internal view returns (IPrice.Props memory) { 

/// @audit _min
358:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit _min
196:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

/// @audit _sqrt
201:     function sqrt(uint256 a) internal pure returns (uint256) { 

/// @audit _log2
216:     function log2(uint256 value) internal pure returns (uint256) { 
```


</details>


---
### [NC&#x2011;95] Non-`external`/`public` state variables should begin with an underscore
According to the Solidity Style Guide, Non-`external`/`public` state variables should begin with an <a href="https://docs.soliditylang.org/en/latest/style-guide.html#underscore-prefix-for-non-external-functions-and-variables">underscore</a>.
> ❗ Issue is removed from: (pech)

<details>
<summary><i>There are 160 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

/// @audit _entered
74:     bool internal entered; 
/// @audit _lastBlock
75:     mapping(uint256 => uint256) private lastBlock;

/// @audit _implementation
128:       address implementation; 
/// @audit _cap
129:       uint256 cap;
/// @audit _status
130:       uint256 status;

/// @audit _owner
134:         address owner; 
/// @audit _start
135:         uint256 start;
/// @audit _strategy
136:         uint256 strategy;
/// @audit _token
137:         address token;
/// @audit _collateral
138:         uint256 collateral;
/// @audit _borrow
139:         uint256 borrow;
/// @audit _shares
140:         uint256 shares;
/// @audit _basis
141:         uint256 basis;
```


```solidity
📁 File: PositionManager.sol

/// @audit _implementation
33:       address implementation; 
/// @audit _cap
34:       uint256 cap;
/// @audit _status
35:       uint256 status;

/// @audit _owner
38:         address owner; 
/// @audit _start
39:         uint256 start;
/// @audit _strategy
40:         uint256 strategy;
/// @audit _token
41:         address token;
/// @audit _collateral
42:         uint256 collateral;
/// @audit _borrow
43:         uint256 borrow;
/// @audit _shares
44:         uint256 shares;
/// @audit _basis
45:         uint256 basis;

/// @audit _values
87:         uint256[] values; 
/// @audit _positions
88:         mapping(uint256 => uint256) positions;
```


```solidity
📁 File: Store.sol

/// @audit _bytes32Sets
13:     mapping(bytes32 => Bytes32Set) internal bytes32Sets; 

/// @audit _values
16:         bytes32[] values; 
/// @audit _positions
17:         mapping(bytes32 => uint256) positions;
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit _entered
11:     bool internal entered; 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit _entered
8:     bool internal entered; 

/// @audit _receiver
401:         address receiver; 
/// @audit _callbackContract
402:         address callbackContract;
/// @audit _uiFeeReceiver
403:         address uiFeeReceiver;
/// @audit _market
404:         address market;
/// @audit _initialLongToken
405:         address initialLongToken;
/// @audit _initialShortToken
406:         address initialShortToken;
/// @audit _longTokenSwapPath
407:         address[] longTokenSwapPath;
/// @audit _shortTokenSwapPath
408:         address[] shortTokenSwapPath;
/// @audit _minMarketTokens
409:         uint256 minMarketTokens;
/// @audit _shouldUnwrapNativeToken
410:         bool shouldUnwrapNativeToken;
/// @audit _executionFee
411:         uint256 executionFee;
/// @audit _callbackGasLimit
412:         uint256 callbackGasLimit;

/// @audit _receiver
416:         address receiver; 
/// @audit _callbackContract
417:         address callbackContract;
/// @audit _uiFeeReceiver
418:         address uiFeeReceiver;
/// @audit _market
419:         address market;
/// @audit _longTokenSwapPath
420:         address[] longTokenSwapPath;
/// @audit _shortTokenSwapPath
421:         address[] shortTokenSwapPath;
/// @audit _minLongTokenAmount
422:         uint256 minLongTokenAmount;
/// @audit _minShortTokenAmount
423:         uint256 minShortTokenAmount;
/// @audit _shouldUnwrapNativeToken
424:         bool shouldUnwrapNativeToken;
/// @audit _executionFee
425:         uint256 executionFee;
/// @audit _callbackGasLimit
426:         uint256 callbackGasLimit;

/// @audit _indexTokenPrice
439:         IPrice.Props indexTokenPrice; 
/// @audit _longTokenPrice
440:         IPrice.Props longTokenPrice;
/// @audit _shortTokenPrice
441:         IPrice.Props shortTokenPrice;

/// @audit _marketToken
445:         address marketToken; 
/// @audit _indexToken
446:         address indexToken;
/// @audit _longToken
447:         address longToken;
/// @audit _shortToken
448:         address shortToken;

/// @audit _min
456:         uint256 min; 
/// @audit _max
457:         uint256 max;

/// @audit _poolValue
463:         int256 poolValue; 
/// @audit _longPnl
464:         int256 longPnl;
/// @audit _shortPnl
465:         int256 shortPnl;
/// @audit _netPnl
466:         int256 netPnl;
/// @audit _longTokenAmount
467:         uint256 longTokenAmount;
/// @audit _shortTokenAmount
468:         uint256 shortTokenAmount;
/// @audit _longTokenUsd
469:         uint256 longTokenUsd;
/// @audit _shortTokenUsd
470:         uint256 shortTokenUsd;
/// @audit _totalBorrowingFees
471:         uint256 totalBorrowingFees;
/// @audit _borrowingFeePoolFactor
472:         uint256 borrowingFeePoolFactor;
/// @audit _impactPoolAmount
473:         uint256 impactPoolAmount;

/// @audit _addresses
499:         Addresses addresses; 
/// @audit _numbers
500:         Numbers numbers;
/// @audit _flags
501:         Flags flags;

/// @audit _account
505:         address account; 
/// @audit _receiver
506:         address receiver;
/// @audit _callbackContract
507:         address callbackContract;
/// @audit _uiFeeReceiver
508:         address uiFeeReceiver;
/// @audit _market
509:         address market;
/// @audit _initialLongToken
510:         address initialLongToken;
/// @audit _initialShortToken
511:         address initialShortToken;
/// @audit _longTokenSwapPath
512:         address[] longTokenSwapPath;
/// @audit _shortTokenSwapPath
513:         address[] shortTokenSwapPath;

/// @audit _initialLongTokenAmount
517:         uint256 initialLongTokenAmount; 
/// @audit _initialShortTokenAmount
518:         uint256 initialShortTokenAmount;
/// @audit _minMarketTokens
519:         uint256 minMarketTokens;
/// @audit _updatedAtBlock
520:         uint256 updatedAtBlock;
/// @audit _executionFee
521:         uint256 executionFee;
/// @audit _callbackGasLimit
522:         uint256 callbackGasLimit;

/// @audit _shouldUnwrapNativeToken
526:         bool shouldUnwrapNativeToken; 

/// @audit _addresses
532:         Addresses addresses; 
/// @audit _numbers
533:         Numbers numbers;
/// @audit _flags
534:         Flags flags;

/// @audit _account
538:         address account; 
/// @audit _receiver
539:         address receiver;
/// @audit _callbackContract
540:         address callbackContract;
/// @audit _uiFeeReceiver
541:         address uiFeeReceiver;
/// @audit _market
542:         address market;
/// @audit _longTokenSwapPath
543:         address[] longTokenSwapPath;
/// @audit _shortTokenSwapPath
544:         address[] shortTokenSwapPath;

/// @audit _marketTokenAmount
548:         uint256 marketTokenAmount; 
/// @audit _minLongTokenAmount
549:         uint256 minLongTokenAmount;
/// @audit _minShortTokenAmount
550:         uint256 minShortTokenAmount;
/// @audit _updatedAtBlock
551:         uint256 updatedAtBlock;
/// @audit _executionFee
552:         uint256 executionFee;
/// @audit _callbackGasLimit
553:         uint256 callbackGasLimit;

/// @audit _shouldUnwrapNativeToken
557:         bool shouldUnwrapNativeToken; 

/// @audit _addressItems
563:         AddressItems addressItems; 
/// @audit _uintItems
564:         UintItems uintItems;
/// @audit _intItems
565:         IntItems intItems;
/// @audit _boolItems
566:         BoolItems boolItems;
/// @audit _bytes32Items
567:         Bytes32Items bytes32Items;
/// @audit _bytesItems
568:         BytesItems bytesItems;
/// @audit _stringItems
569:         StringItems stringItems;

/// @audit _items
573:         AddressKeyValue[] items; 
/// @audit _arrayItems
574:         AddressArrayKeyValue[] arrayItems;

/// @audit _items
578:         UintKeyValue[] items; 
/// @audit _arrayItems
579:         UintArrayKeyValue[] arrayItems;

/// @audit _items
583:         IntKeyValue[] items; 
/// @audit _arrayItems
584:         IntArrayKeyValue[] arrayItems;

/// @audit _items
588:         BoolKeyValue[] items; 
/// @audit _arrayItems
589:         BoolArrayKeyValue[] arrayItems;

/// @audit _items
593:         Bytes32KeyValue[] items; 
/// @audit _arrayItems
594:         Bytes32ArrayKeyValue[] arrayItems;

/// @audit _items
598:         BytesKeyValue[] items; 
/// @audit _arrayItems
599:         BytesArrayKeyValue[] arrayItems;

/// @audit _items
603:         StringKeyValue[] items; 
/// @audit _arrayItems
604:         StringArrayKeyValue[] arrayItems;

/// @audit _key
608:         string key; 
/// @audit _value
609:         address value;

/// @audit _key
613:         string key; 
/// @audit _value
614:         address[] value;

/// @audit _key
618:         string key; 
/// @audit _value
619:         uint256 value;

/// @audit _key
623:         string key; 
/// @audit _value
624:         uint256[] value;

/// @audit _key
628:         string key; 
/// @audit _value
629:         int256 value;

/// @audit _key
633:         string key; 
/// @audit _value
634:         int256[] value;

/// @audit _key
638:         string key; 
/// @audit _value
639:         bool value;

/// @audit _key
643:         string key; 
/// @audit _value
644:         bool[] value;

/// @audit _key
648:         string key; 
/// @audit _value
649:         bytes32 value;

/// @audit _key
653:         string key; 
/// @audit _value
654:         bytes32[] value;

/// @audit _key
658:         string key; 
/// @audit _value
659:         bytes value;

/// @audit _key
663:         string key; 
/// @audit _value
664:         bytes[] value;

/// @audit _key
668:         string key; 
/// @audit _value
669:         string value;

/// @audit _key
673:         string key; 
/// @audit _value
674:         string[] value;
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit _entered
8:     bool internal entered; 
```


</details>


---
### [NC&#x2011;96] Non-library/interface files should use fixed compiler versions, not floating ones
To prevent the actual contracts being deployed from behaving differently depending on the compiler version, it is recommended to use fixed solidity versions for contracts and libraries.

Although we can configure a specific version through config (like hardhat, forge config files), it is recommended to **set the fixed version in the solidity pragma directly** before deploying to the mainnet.

<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Helper.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Investor.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Store.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: UtilFarmingBalances.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Whitelist.sol

2: pragma solidity ^0.8.0; 
```


</details>


---
### [NC&#x2011;97] Numeric values having to do with time should use time units for readability
There are [units](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units) for seconds, minutes, hours, days, and weeks, and since they're defined, they should be used


<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyCamelotV3.sol

27:     uint32 public twapPeriod = 43200; 
```



---
### [NC&#x2011;98] Outdated Solidity version
Upgrade to the latest solidity version.

<a href="https://blog.soliditylang.org/2021/04/21/solidity-0.8.4-release-announcement/">0.8.4</a>: bytes.concat() instead of abi.encodePacked(<bytes>,<bytes>) 
<a href="https://blog.soliditylang.org/2022/02/16/solidity-0.8.12-release-announcement/">0.8.12</a>: string.concat() instead of abi.encodePacked(<str>,<str>) 
<a href="https://blog.soliditylang.org/2022/03/16/solidity-0.8.13-release-announcement/">0.8.13</a>:
- Ability to use using for with a list of free functions

<a href="https://blog.soliditylang.org/2022/05/18/solidity-0.8.14-release-announcement/">0.8.14</a>:
- ABI Encoder: When ABI-encoding values from calldata that contain nested arrays, correctly validate the nested array length against calldatasize() in all cases.
- Override Checker: Allow changing data location for parameters only when overriding external functions.

<a href="https://blog.soliditylang.org/2022/06/15/solidity-0.8.15-release-announcement/">0.8.15</a>:
- Code Generation: Avoid writing dirty bytes to storage when copying bytes arrays.
- Yul Optimizer: Keep all memory side-effects of inline assembly blocks.

<a href="https://blog.soliditylang.org/2022/08/08/solidity-0.8.16-release-announcement/">0.8.16</a>:
 - Code Generation: Fix data corruption that affected ABI-encoding of calldata values represented by tuples: structs at any nesting level; argument lists of external functions, events and errors; return value lists of external functions. The 32 leading bytes of the first dynamically-encoded value in the tuple would get zeroed when the last component contained a statically-encoded array.

<a href="https://blog.soliditylang.org/2022/09/08/solidity-0.8.17-release-announcement/">0.8.17</a>:
 - Yul Optimizer: Prevent the incorrect removal of storage writes before calls to Yul functions that conditionally terminate the external EVM call.

<a href="https://blog.soliditylang.org/2023/02/22/solidity-0.8.19-release-announcement/">0.8.19</a>:
- SMTChecker: New trusted mode that assumes that any compile-time available code is the actual used code, even in external calls.

Bug Fixes:
- Assembler: Avoid duplicating subassembly bytecode where possible.
- Code Generator: Avoid including references to the deployed label of referenced functions if they are called right away.
- ContractLevelChecker: Properly distinguish the case of missing base constructor arguments from having an unimplemented base function.
- SMTChecker: Fix internal error caused by unhandled z3 expressions that come from the solver when bitwise operators are used.
- SMTChecker: Fix internal error when using the custom NatSpec annotation to abstract free functions.
- TypeChecker: Also allow external library functions in using for.

<a href="https://blog.soliditylang.org/2023/05/10/solidity-0.8.20-release-announcement/">0.8.20</a>:
- Assembler: Use push0 for placing 0 on the stack for EVM versions starting from “Shanghai”. This decreases the deployment and runtime costs.
- Optimizer: Re-implement simplified version of UnusedAssignEliminator and UnusedStoreEliminator. It can correctly remove some unused assignments in deeply nested loops that were ignored by the old version.
- Parser: Unary plus is no longer recognized as a unary operator in the AST and triggers an error at the parsing stage (rather than later during the analysis).
- SMTChecker: Group all messages about unsupported language features in a single warning. The CLI option --model-checker-show-unsupported and the JSON option settings.modelChecker.showUnsupported can be enabled to show the full list.
- SMTChecker: Properties that are proved safe are now reported explicitly at the end of analysis. By default, only the number of safe properties is shown. The CLI option --model-checker-show-proved-safe and the JSON option settings.modelChecker.showProvedSafe can be enabled to show the full list of safe properties.
- Standard JSON Interface: Add experimental support for importing ASTs via Standard JSON.
- Yul EVM Code Transform: If available, use push0 instead of codesize to produce an arbitrary value on stack in order to create equal stack heights between branches.

<a href="https://soliditylang.org/blog/2023/07/19/solidity-0.8.21-release-announcement">0.8.21</a>:
- Code Generator: Always generate code for the expression in `<expression>.selector` in the legacy code generation pipeline.
- Yul Optimizer: Fix FullInliner step (i) not preserving the evaluation order of arguments passed into inlined functions in code that is not in expression-split form.
- Allow qualified access to events from other contracts.
- Relax restrictions on initialization of immutable variables. Reads and writes may now happen at any point at construction time outside of functions and modifiers. Explicit initialization is no longer mandatory.


<details>
<summary><i>There are 11 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Helper.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Investor.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: InvestorStrategyProxy.sol

2: pragma solidity 0.8.17; 
```


```solidity
📁 File: PositionManager.sol

2: pragma solidity 0.8.17; 
```


```solidity
📁 File: Store.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: StrategyCamelotV3.sol

2: pragma solidity 0.8.17; 
```


```solidity
📁 File: StrategyGMXGM.sol

2: pragma solidity 0.8.17; 
```


```solidity
📁 File: StrategySushiswap.sol

2: pragma solidity 0.8.17; 
```


```solidity
📁 File: UtilFarmingBalances.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Whitelist.sol

2: pragma solidity ^0.8.0; 
```


</details>


---
### [NC&#x2011;99] Overly complicated arithmetic
To maintain readability in code, particularly in Solidity which can involve complex mathematical operations, it is often recommended to limit the number of arithmetic operations to a maximum of 2-3 per line. Too many operations in a single line can make the code difficult to read and understand, increase the likelihood of mistakes, and complicate the process of debugging and reviewing the code.

<details>
<summary><i>There are 8 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

357:             push(poolAsset, msg.sender, (amount - used) * (10000 - performanceFee) / 10000); 

462:         uint256 borrow = (scaled * pool.getUpdatedIndex() / 1e18) * price / 1e18; 
```


```solidity
📁 File: PositionManager.sol

343:         uint256 amt = ( 
344:             (p.borrow * IPool(pool).getUpdatedIndex() / 1e18) * 1e18 / (10 ** IERC20(IPool(pool).asset()).decimals())
345:         ) * uint256(oracle.latestAnswer()) / (10 ** oracle.decimals());

376:         uint256 r = n / (10 ** (d - f)) % (10 ** f); 
```


```solidity
📁 File: StrategyCamelotV3.sol

314:         uint256 toLp0 = amt * 1e18 / ((((start + end) / 2) * 1e18 / out1) + 1e18); 
```


```solidity
📁 File: StrategyGMXGM.sol

331:         price = price * (10 ** (30 - decimals)) / 1e18; 
```


```solidity
📁 File: StrategySushiswap.sol

86:         uint256 val = 2 * ((sqrt(reserve0 * reserve1) * sqrt(price0 * price1)) / tot); 
87:         return sha * (val * amt / 1e18) / totalShares;
```


</details>


---
### [NC&#x2011;100] Overridden function has no body
Consider adding a NatSpec comment describing why the function doesn't need a body and or the purpose it serves


<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

292:     function move(address old) external auth {} 
```



---
### [NC&#x2011;101] Parameter change does not emit event
Events help non-contract tools to track changes

<details>
<summary><i>There are 9 instances of this issue:</i></summary>

```solidity
📁 File: Store.sol

59:     function removeUint(bytes32 key) external auth { 
60:         delete uintValues[key];
61:     }

74:     function removeInt(bytes32 key) external auth { 
75:         delete intValues[key];
76:     }

84:     function removeAddress(bytes32 key) external auth { 
85:         delete addressValues[key];
86:     }

94:     function removeBool(bytes32 key) external auth { 
95:         delete boolValues[key];
96:     }

104:     function removeString(bytes32 key) external auth { 
105:         delete stringValues[key];
106:     }

114:     function removeBytes32(bytes32 key) external auth { 
115:         delete bytes32Values[key];
116:     }

124:     function removeBytes32Array(bytes32 key) external auth { 
125:         delete bytes32ArrayValues[key];
126:     }
```


```solidity
📁 File: StrategyCamelotV3.sol

119:     function setPathToLp(bytes calldata newPathToLp) external auth { 
120:         pathToLp = newPathToLp;
121:     }

123:     function setNitroPool(address _nitroPool) external auth { 
124:         if (tokenId == 0) revert TokenIdNeededFirst();
125:         if (_nitroPool == address(0)) {
126:             nitroPool.withdraw(tokenId);
127:         } else {
128:             nftPool.safeTransferFrom(address(this), _nitroPool, tokenId, "");
129:         }
130:         nitroPool = INitroPool(_nitroPool);
131:     }
```


</details>


---
### [NC&#x2011;102] Place `interface` files into a dedicated folder
Using a separate folder for interfaces keeps the codebase organised and helps to facilitate security audits as well as future development.

<details>
<summary><i>There are 53 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

4: interface IERC20 { 
```


```solidity
📁 File: Helper.sol

4: interface IERC20 { 

10: interface IInvestor { 

15: interface IAavePool { 

19: interface IStrategyHelper { 

23: interface ISushi { 
```


```solidity
📁 File: Investor.sol

4: interface IERC20 { 

12: interface IOracle { 

17: interface IStore { 

26: interface IBank { 

31: interface IPool { 

40: interface IHelper { 

47: interface IStrategy { 

54: interface IStrategyProxy { 

61: interface IWhitelist { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

4: interface IERC20 { 

9: interface IStrategy { 
```


```solidity
📁 File: PositionManager.sol

7: interface IERC20 { 

15: interface IOracle { 

20: interface IPool { 

26: interface IStrategy { 

31: interface IInvestor { 

55: interface IWhitelist { 

59: interface ERC721TokenReceiver { 
```


```solidity
📁 File: StrategyCamelotV3.sol

414: interface IERC20 { 

422: interface IStrategyHelper { 

428: interface IStrategyHelperUniswapV3 { 

432: interface IUniProxy { 

437: interface IQuoter { 

441: interface IHypervisor is IERC20 { 

453: interface INFTPool { 

466: interface INitroPool { 

471: interface IAlgebraPool { 

490: interface IXGrail { 
```


```solidity
📁 File: StrategyGMXGM.sol

363: interface IERC20 { 

372: interface IStrategyHelper { 

378: interface IHandler { 

383: interface IPriceFeed { 

393: interface IDataStore { 

399: interface IExchangeRouter { 

437: interface IMarket { 

454: interface IPrice { 

461: interface IMarketPoolValueInfo { 

477: interface IReader { 

497: interface IDeposit { 

530: interface IWithdrawal { 

561: interface IEventUtils { 
```


```solidity
📁 File: StrategySushiswap.sol

253: interface IERC20 { 

262: interface IStrategyHelper { 

268: interface IUniswapV2Pair { 

281: interface ISushiswapMiniChefV2 { 
```


```solidity
📁 File: UtilFarmingBalances.sol

4: interface IInvestor { 

9: interface IPositionManager { 
```


</details>


---
### [NC&#x2011;103] Polymorphic functions make security audits more time-consuming and error-prone
The instances below point to one of two functions with the same name. Consider naming each function differently, in order to make code navigation and analysis easier.

<details>
<summary><i>There are 12 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

/// @audit file(bytes32 what, address data)
/// @audit file(bytes32 what, uint256 data)
65: contract Investor { 
```


```solidity
📁 File: PositionManager.sol

/// @audit safeTransferFrom(address from, address to, uint256 id)
/// @audit safeTransferFrom(address from, address to, uint256 id, bytes calldata data)
64: contract PositionManager { 
```


```solidity
📁 File: Store.sol

/// @audit removeBytes32(bytes32 key)
/// @audit removeBytes32(bytes32 key, bytes32 value)
4: contract Store { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit file(bytes32 what, address data)
/// @audit file(bytes32 what, uint256 data)
7: contract StrategyCamelotV3 { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit file(bytes32 what, address data)
/// @audit file(bytes32 what, uint256 data)
4: contract StrategyGMXGM { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit file(bytes32 what, address data)
/// @audit file(bytes32 what, uint256 data)
4: contract StrategySushiswap { 
```


</details>


---
### [NC&#x2011;104] `public` functions not called by the contract should be declared `external` instead
Contracts are allowed to override their parents’ functions and change the visibility from public to external.

<details>
<summary><i>There are 26 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

495:     function getPool() public view returns (address) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

34:     function file(bytes32 what, address data) public auth { 

43:     function mint(address strategy, uint256 amount) public auth returns (uint256) { 

48:     function burn(address strategy, uint256 shares) public auth returns (uint256) { 

54:     function kill(address strategy, uint256 shares, address target) public auth returns (bytes memory) { 

58:     function call(address strategy, uint256 value, bytes calldata data) public auth { 
```


```solidity
📁 File: PositionManager.sol

114:     function ownerOf(uint256 id) public view returns (address owner) { 

118:     function balanceOf(address owner) public view returns (uint256) { 

143:     function approve(address spender, uint256 id) public { 

150:     function setApprovalForAll(address operator, bool approved) public { 

188:     function safeTransferFrom(address from, address to, uint256 id) public { 

198:     function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public { 

208:     function supportsInterface(bytes4 interfaceId) public pure returns (bool) { 

214:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow, address to) public returns (uint256) { 

233:     function edit(uint256 id, int256 borrow, int256 collateral) public auth(id) { 

244:     function burn(uint256 id) public auth(id) { 

252:     function forceBurn(uint256 id) public auth(id) { 

272:     function tokenURI(uint256 id) public view returns (string memory) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

397:     function onNFTHarvest(address, address, uint256, uint256, uint256) public pure returns (bool) { 

401:     function onNFTAddToPosition(address, uint256, uint256) public pure returns (bool) { 

405:     function onNFTWithdraw(address, uint256, uint256) public pure returns (bool) { 
```


```solidity
📁 File: StrategySushiswap.sol

90:     function mint(uint256 amount) public auth loop returns (uint256) {  

117:     function burn(uint256 shares) public auth loop returns (uint256) { 

153:     function earn() public payable loop { 

182:     function exit(address strategy) public auth { 

186:     function move(address old) public auth { 
```


</details>


---
### [NC&#x2011;105] `receive()`/`payable fallback()` function does not authorize requests
If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`). Having no access control on the function means that someone may send Ether to the contract, and have no way to get anything back out, which is a loss of funds. If the concern is having to spend a small amount of gas to check the sender against an immutable address, the code should at least have a function to rescue unused Ether.


<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

80:     receive() external payable {} 
```



---
### [NC&#x2011;106] Returning a struct instead of a bunch of variables is better
If a function returns [too many variables](https://docs.soliditylang.org/en/v0.8.21/contracts.html#returning-multiple-values), replacing them with a struct can improve code readability, maintainability and reusability.

<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: StrategyCamelotV3.sol

459:     function getStakingPosition(uint256 tokenId) external view returns ( 

474:     function getTimepoints(uint32[] calldata secondsAgos) external view returns ( 

480:     function positions(bytes32 key) external view returns ( 
```


```solidity
📁 File: StrategyGMXGM.sol

384:     function latestRoundData() external view returns ( 
```


```solidity
📁 File: StrategySushiswap.sol

272:     function getReserves() external view returns (uint112, uint112, uint32); 
```


```solidity
📁 File: UtilFarmingBalances.sol

6:     function positions(uint256) external view returns (address, address, uint256, uint256, uint256, uint256, uint256); 
```


</details>


---
### [NC&#x2011;107] Simplify complex require statements
Simplifying complex `require` statements with local variables and `if`(or `revert`) statements can improve readability, make debugging easier, and promote modularity and reusability in the code.


<i>There is one instance of this issue:</i>

```solidity
📁 File: PositionManager.sol

136:         require( 
137:             msg.sender == owner || isApprovedForAll[owner][msg.sender] || msg.sender == getApproved[id],
138:             "NOT_AUTHORIZED"
139:         );
```



---
### [NC&#x2011;108] Some variables have a implicit default visibility
Consider always adding an explicit visibility modifier for variables, as the default is `internal`.

<details>
<summary><i>There are 19 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

82:     bytes32 constant STATUS = keccak256(abi.encode("STATUS")); 
83:     bytes32 constant BANK = keccak256(abi.encode("BANK"));
84:     bytes32 constant POOL = keccak256(abi.encode("POOL"));
85:     bytes32 constant STRATEGIES_ADDRESS = keccak256(abi.encode("STRATEGIES_ADDRESS"));
86:     bytes32 constant STRATEGIES_CAP = keccak256(abi.encode("STRATEGIES_CAP"));
87:     bytes32 constant STRATEGIES_STATUS = keccak256(abi.encode("STRATEGIES_STATUS"));
88:     bytes32 constant COLLATERAL_FACTOR = keccak256(abi.encode("COLLATERAL_FACTOR"));
89:     bytes32 constant COLLATERAL_CAP = keccak256(abi.encode("COLLATERAL_CAP"));
90:     bytes32 constant POSITIONS = keccak256(abi.encode("POSITIONS"));
91:     bytes32 constant POSITIONS_OWNER = keccak256(abi.encode("POSITIONS_OWNER"));
92:     bytes32 constant POSITIONS_START = keccak256(abi.encode("POSITIONS_START"));
93:     bytes32 constant POSITIONS_STRATEGY = keccak256(abi.encode("POSITIONS_STRATEGY"));
94:     bytes32 constant POSITIONS_TOKEN = keccak256(abi.encode("POSITIONS_TOKEN"));
95:     bytes32 constant POSITIONS_COLLATERAL = keccak256(abi.encode("POSITIONS_COLLATERAL"));
96:     bytes32 constant POSITIONS_BASIS = keccak256(abi.encode("POSITIONS_BASIS"));
97:     bytes32 constant POSITIONS_SHARES = keccak256(abi.encode("POSITIONS_SHARES"));
98:     bytes32 constant POSITIONS_BORROW = keccak256(abi.encode("POSITIONS_BORROW"));
```


```solidity
📁 File: StrategyGMXGM.sol

322:     bytes32 constant MAX_PNL_FACTOR_FOR_DEPOSITS = keccak256(abi.encode("MAX_PNL_FACTOR_FOR_DEPOSITS")); 
323:     bytes32 constant MAX_PNL_FACTOR_FOR_WITHDRAWALS = keccak256(abi.encode("MAX_PNL_FACTOR_FOR_WITHDRAWALS"));
```


</details>


---
### [NC&#x2011;109] State variables should include comments
Consider adding some comments on critical state variables to explain what they are supposed to do: this will help for future code reviews.

<details>
<summary><i>There are 264 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

9:     mapping(address => bool) public exec; 
```


```solidity
📁 File: Helper.sol

30:     IInvestor public investor; 
31:     IERC20 public asset;

34:     uint256 public slippage = 2500; 
```


```solidity
📁 File: Investor.sol

66:     IStore public store; 
67:     IHelper public helper;
68:     IWhitelist public whitelist;
69:     IStrategyProxy public strategyProxy;
70:     uint256 public slippage = 200;
71:     uint256 public performanceFee = 2000;
72:     uint256 public killCollateralPadding = 500;
73:     uint256 public closeCollateralPadding = 400;
74:     bool internal entered;
75:     mapping(uint256 => uint256) private lastBlock;
76:     mapping(address => bool) public exec;

78:     uint256 public constant STATUS_LIVE = 4; 
79:     uint256 public constant STATUS_WITHDRAW = 3;
80:     uint256 public constant STATUS_LIQUIDATE = 2;
81:     uint256 public constant STATUS_PAUSED = 1;
82:     bytes32 constant STATUS = keccak256(abi.encode("STATUS"));
83:     bytes32 constant BANK = keccak256(abi.encode("BANK"));
84:     bytes32 constant POOL = keccak256(abi.encode("POOL"));
85:     bytes32 constant STRATEGIES_ADDRESS = keccak256(abi.encode("STRATEGIES_ADDRESS"));
86:     bytes32 constant STRATEGIES_CAP = keccak256(abi.encode("STRATEGIES_CAP"));
87:     bytes32 constant STRATEGIES_STATUS = keccak256(abi.encode("STRATEGIES_STATUS"));
88:     bytes32 constant COLLATERAL_FACTOR = keccak256(abi.encode("COLLATERAL_FACTOR"));
89:     bytes32 constant COLLATERAL_CAP = keccak256(abi.encode("COLLATERAL_CAP"));
90:     bytes32 constant POSITIONS = keccak256(abi.encode("POSITIONS"));
91:     bytes32 constant POSITIONS_OWNER = keccak256(abi.encode("POSITIONS_OWNER"));
92:     bytes32 constant POSITIONS_START = keccak256(abi.encode("POSITIONS_START"));
93:     bytes32 constant POSITIONS_STRATEGY = keccak256(abi.encode("POSITIONS_STRATEGY"));
94:     bytes32 constant POSITIONS_TOKEN = keccak256(abi.encode("POSITIONS_TOKEN"));
95:     bytes32 constant POSITIONS_COLLATERAL = keccak256(abi.encode("POSITIONS_COLLATERAL"));
96:     bytes32 constant POSITIONS_BASIS = keccak256(abi.encode("POSITIONS_BASIS"));
97:     bytes32 constant POSITIONS_SHARES = keccak256(abi.encode("POSITIONS_SHARES"));
98:     bytes32 constant POSITIONS_BORROW = keccak256(abi.encode("POSITIONS_BORROW"));

128:       address implementation; 
129:       uint256 cap;
130:       uint256 status;

134:         address owner; 
135:         uint256 start;
136:         uint256 strategy;
137:         address token;
138:         uint256 collateral;
139:         uint256 borrow;
140:         uint256 shares;
141:         uint256 basis;
```


```solidity
📁 File: InvestorStrategyProxy.sol

16:     IERC20 public asset; 
17:     mapping(address => bool) public exec;
```


```solidity
📁 File: PositionManager.sol

33:       address implementation; 
34:       uint256 cap;
35:       uint256 status;

38:         address owner; 
39:         uint256 start;
40:         uint256 strategy;
41:         address token;
42:         uint256 collateral;
43:         uint256 borrow;
44:         uint256 shares;
45:         uint256 basis;

65:     string public constant name = "Rodeo V2 Position"; 
66:     string public constant symbol = "RP2";
67:     IInvestor public investor;
68:     IWhitelist public whitelist;
69:     mapping(address => bool) public exec;
70:     mapping(uint256 => address) internal _ownerOf;
71:     mapping(address => uint256) internal _balanceOf;
72:     mapping(address => Ids) internal _ownerIds;
73:     mapping(uint256 => address) public getApproved;
74:     mapping(address => mapping(address => bool)) public isApprovedForAll;

87:         uint256[] values; 
88:         mapping(uint256 => uint256) positions;
```


```solidity
📁 File: Store.sol

5:     mapping(address => bool) public exec; 
6:     mapping(bytes32 => uint256) public uintValues;
7:     mapping(bytes32 => int256) public intValues;
8:     mapping(bytes32 => address) public addressValues;
9:     mapping(bytes32 => bool) public boolValues;
10:     mapping(bytes32 => string) public stringValues;
11:     mapping(bytes32 => bytes32) public bytes32Values;
12:     mapping(bytes32 => bytes32[]) public bytes32ArrayValues;
13:     mapping(bytes32 => Bytes32Set) internal bytes32Sets;

16:         bytes32[] values; 
17:         mapping(bytes32 => uint256) positions;
```


```solidity
📁 File: StrategyCamelotV3.sol

8:     string public name; 
9:     uint256 public totalShares = 1_000_000;
10:     uint256 public slippage = 500;
11:     bool internal entered;
12:     IERC20 public asset;
13:     IStrategyHelper public strategyHelper;
14:     mapping(address => bool) public exec;
15:     mapping(address => bool) public keepers;

17:     IXGrail public immutable xgrail; 
18:     IStrategyHelperUniswapV3 public immutable strategyHelperUniswapV3;
19:     IUniProxy public immutable uniProxy;
20:     IQuoter public immutable quoter;
21:     IHypervisor public immutable hypervisor;

24:     INFTPool public nftPool; 
25:     INitroPool public nitroPool;
26:     uint256 public tokenId;
27:     uint32 public twapPeriod = 43200;
28:     address public rewardToken1;
29:     address public rewardToken2;
30:     address public rewardToken3;
```


```solidity
📁 File: StrategyGMXGM.sol

5:     string public name; 
6:     uint256 public totalShares = 1_000_000;
7:     uint256 public slippage = 500;
8:     bool internal entered;
9:     IERC20 public asset;
10:     IStrategyHelper public strategyHelper;
11:     mapping(address => bool) public exec;
12:     mapping(address => bool) public keepers;

14:     IExchangeRouter public exchangeRouter; 
15:     IReader public reader;
16:     address public depositHandler;
17:     address public withdrawalHandler;
18:     address public depositVault;
19:     address public withdrawalVault;
20:     address public immutable dataStore;
21:     address public immutable market;

26:     uint256 public amountPendingWithdraw; 

29:     uint256 public callbackGasLimit = 500_000; 

322:     bytes32 constant MAX_PNL_FACTOR_FOR_DEPOSITS = keccak256(abi.encode("MAX_PNL_FACTOR_FOR_DEPOSITS")); 
323:     bytes32 constant MAX_PNL_FACTOR_FOR_WITHDRAWALS = keccak256(abi.encode("MAX_PNL_FACTOR_FOR_WITHDRAWALS"));

401:         address receiver; 
402:         address callbackContract;
403:         address uiFeeReceiver;
404:         address market;
405:         address initialLongToken;
406:         address initialShortToken;
407:         address[] longTokenSwapPath;
408:         address[] shortTokenSwapPath;
409:         uint256 minMarketTokens;
410:         bool shouldUnwrapNativeToken;
411:         uint256 executionFee;
412:         uint256 callbackGasLimit;

416:         address receiver; 
417:         address callbackContract;
418:         address uiFeeReceiver;
419:         address market;
420:         address[] longTokenSwapPath;
421:         address[] shortTokenSwapPath;
422:         uint256 minLongTokenAmount;
423:         uint256 minShortTokenAmount;
424:         bool shouldUnwrapNativeToken;
425:         uint256 executionFee;
426:         uint256 callbackGasLimit;

439:         IPrice.Props indexTokenPrice; 
440:         IPrice.Props longTokenPrice;
441:         IPrice.Props shortTokenPrice;

445:         address marketToken; 
446:         address indexToken;
447:         address longToken;
448:         address shortToken;

456:         uint256 min; 
457:         uint256 max;

463:         int256 poolValue; 
464:         int256 longPnl;
465:         int256 shortPnl;
466:         int256 netPnl;
467:         uint256 longTokenAmount;
468:         uint256 shortTokenAmount;
469:         uint256 longTokenUsd;
470:         uint256 shortTokenUsd;
471:         uint256 totalBorrowingFees;
472:         uint256 borrowingFeePoolFactor;
473:         uint256 impactPoolAmount;

499:         Addresses addresses; 
500:         Numbers numbers;
501:         Flags flags;

505:         address account; 
506:         address receiver;
507:         address callbackContract;
508:         address uiFeeReceiver;
509:         address market;
510:         address initialLongToken;
511:         address initialShortToken;
512:         address[] longTokenSwapPath;
513:         address[] shortTokenSwapPath;

517:         uint256 initialLongTokenAmount; 
518:         uint256 initialShortTokenAmount;
519:         uint256 minMarketTokens;
520:         uint256 updatedAtBlock;
521:         uint256 executionFee;
522:         uint256 callbackGasLimit;

526:         bool shouldUnwrapNativeToken; 

532:         Addresses addresses; 
533:         Numbers numbers;
534:         Flags flags;

538:         address account; 
539:         address receiver;
540:         address callbackContract;
541:         address uiFeeReceiver;
542:         address market;
543:         address[] longTokenSwapPath;
544:         address[] shortTokenSwapPath;

548:         uint256 marketTokenAmount; 
549:         uint256 minLongTokenAmount;
550:         uint256 minShortTokenAmount;
551:         uint256 updatedAtBlock;
552:         uint256 executionFee;
553:         uint256 callbackGasLimit;

557:         bool shouldUnwrapNativeToken; 

563:         AddressItems addressItems; 
564:         UintItems uintItems;
565:         IntItems intItems;
566:         BoolItems boolItems;
567:         Bytes32Items bytes32Items;
568:         BytesItems bytesItems;
569:         StringItems stringItems;

573:         AddressKeyValue[] items; 
574:         AddressArrayKeyValue[] arrayItems;

578:         UintKeyValue[] items; 
579:         UintArrayKeyValue[] arrayItems;

583:         IntKeyValue[] items; 
584:         IntArrayKeyValue[] arrayItems;

588:         BoolKeyValue[] items; 
589:         BoolArrayKeyValue[] arrayItems;

593:         Bytes32KeyValue[] items; 
594:         Bytes32ArrayKeyValue[] arrayItems;

598:         BytesKeyValue[] items; 
599:         BytesArrayKeyValue[] arrayItems;

603:         StringKeyValue[] items; 
604:         StringArrayKeyValue[] arrayItems;

608:         string key; 
609:         address value;

613:         string key; 
614:         address[] value;

618:         string key; 
619:         uint256 value;

623:         string key; 
624:         uint256[] value;

628:         string key; 
629:         int256 value;

633:         string key; 
634:         int256[] value;

638:         string key; 
639:         bool value;

643:         string key; 
644:         bool[] value;

648:         string key; 
649:         bytes32 value;

653:         string key; 
654:         bytes32[] value;

658:         string key; 
659:         bytes value;

663:         string key; 
664:         bytes[] value;

668:         string key; 
669:         string value;

673:         string key; 
674:         string[] value;
```


```solidity
📁 File: StrategySushiswap.sol

5:     string public name; 
6:     uint256 public totalShares = 1_000_000;
7:     uint256 public slippage = 500;
8:     bool internal entered;
9:     IERC20 public asset;
10:     IStrategyHelper public strategyHelper;
11:     ISushiswapMiniChefV2 public rewarder;
12:     IUniswapV2Pair public pool;
13:     uint256 public poolId;
14:     mapping(address => bool) public exec;
15:     mapping(address => bool) public keepers;
```


```solidity
📁 File: Whitelist.sol

5:     mapping(address => bool) public exec; 
6:     mapping(address => bool) public whitelist;
```


</details>


---
### [NC&#x2011;110] Top-level declarations should be separated by at least two lines
<details>
<summary><i>There are 338 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

4: interface IERC20 { 
5:     function transfer(address, uint256) external returns (bool);

8: contract Bank { 
9:     mapping(address => bool) public exec;
10: 
11:     event File(bytes32 indexed what, address data);
12: 
13:     error InvalidFile();

19:     } 
20: 
21:     modifier auth() {

24:     } 
25: 
26:     function file(bytes32 what, address data) external auth {

33:     } 
34: 
35:     function transferNative(address to, uint256 amount) external auth {

39:     } 
40: 
41:     function transfer(address token, address to, uint256 amount) external auth {

44:     } 
```


```solidity
📁 File: Helper.sol

4: interface IERC20 { 
5:     function balanceOf(address) external view returns (uint256);
6:     function approve(address, uint256) external;
7:     function transfer(address, uint256) external;

10: interface IInvestor { 
11:     function killRepayment(uint256) external returns (uint256);
12:     function kill(uint256 id) external returns (address, bytes memory);

15: interface IAavePool { 
16:     function flashLoanSimple(address receiver, address asset, uint256 amount, bytes calldata params, uint16 referrer) external;

19: interface IStrategyHelper { 
20:     function swap(address, address, uint256, uint256, address) external returns (uint256);

23: interface ISushi { 
24:     function token0() external view returns (address);
25:     function token1() external view returns (address);
26:     function burn(address) external;

29: contract Helper { 
30:     IInvestor public investor;

41:     } 
42: 
43:     function kill(uint256 id) external {

46:     } 
47: 
48:     function executeOperation(

74:     } 
75: 
76:     function swap(address _fromAsset) internal {
```


```solidity
📁 File: Investor.sol

4: interface IERC20 { 
5:     function decimals() external view returns (uint8);
6:     function balanceOf(address) external view returns (uint256);
7:     function approve(address, uint256) external;
8:     function transfer(address, uint256) external returns (bool);
9:     function transferFrom(address, address, uint256) external returns (bool);

12: interface IOracle { 
13:     function decimals() external view returns (uint8);
14:     function latestAnswer() external view returns (int256);

17: interface IStore { 
18:     function exec(address) external view returns (bool);
19:     function getUint(bytes32) external view returns (uint256);
20:     function getAddress(bytes32) external view returns (address);
21:     function setUint(bytes32, uint256) external;
22:     function setUintDelta(bytes32, int256) external returns (uint256);
23:     function setAddress(bytes32, address) external returns (address);

26: interface IBank { 
27:     function exec(address) external view returns (bool);
28:     function transfer(address, address, uint256) external;

31: interface IPool { 
32:     function exec(address) external view returns (bool);
33:     function asset() external view returns (address);
34:     function oracle() external view returns (address);
35:     function getUpdatedIndex() external view returns (uint256);
36:     function borrow(uint256) external returns (uint256);
37:     function repay(uint256) external returns (uint256);

40: interface IHelper { 
41:     function price(address) external view returns (uint256);
42:     function value(address, uint256) external view returns (uint256);
43:     function convert(address, address, uint256) external view returns (uint256);
44:     function swap(address, address, uint256, uint256, address) external returns (uint256);

47: interface IStrategy { 
48:     function totalShares() external view returns (uint256);
49:     function rate(uint256) external view returns (uint256);
50:     function exit(address) external;
51:     function move(address) external;

54: interface IStrategyProxy { 
55:     function exec(address) external view returns (bool);
56:     function mint(address, uint256) external returns (uint256);
57:     function burn(address, uint256) external returns (uint256);
58:     function kill(address, uint256, address) external returns (bytes memory);

61: interface IWhitelist { 
62:     function check(address) external view returns (bool);

65: contract Investor { 
66:     IStore public store;

148:     } 
149: 
150:     modifier auth() {

186:     } 
187: 
188:     function file(bytes32 what, uint256 data) external auth {

208:     } 
209: 
210:     function strategyNew(uint256 index, address implementation) external auth {

217:     } 
218: 
219:     function strategyUgrade(uint256 index, address implementation) external auth {

225:     } 
226: 
227:     function strategySetStatus(uint256 index, uint256 status) external auth {

231:     } 
232: 
233:     function strategySetCap(uint256 index, uint256 cap) external auth {

237:     } 
238: 
239:     function collateralSetFactor(address token, uint256 factor) external auth {

243:     } 
244: 
245:     function collateralSetCap(address token, uint256 cap) external auth {

249:     } 
250: 
251:     function collect(address token) external auth {

253:     } 
254: 
255:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external loop returns (uint256) {

293:     } 
294: 
295:     function edit(uint256 id, int256 borrow, int256 collateral) external loop {

386:     } 
387: 
388:     function killRepayment(uint256 id) external view returns (uint256) {

394:     } 
395: 
396:     function kill(uint256 id) external loop returns (address, bytes memory) {

444:     } 
445: 
446:     function life(uint256 id) external view returns (uint256) {

449:     } 
450: 
451:     function _life(Position memory p) internal view returns (uint256) {

464:     } 
465: 
466:     function getPosition(uint256 id) public view returns (Position memory p) {

475:     } 
476: 
477:     function setPosition(uint256 id, Position memory p) internal {

486:     } 
487: 
488:     function getStrategy(uint256 id) public view returns (Strategy memory s) {

493:     } 
494: 
495:     function getPool() public view returns (address) {

497:     } 
498: 
499:     function push(address asset, address user, uint256 amount) internal {

504:     } 
505: 
506:     function pullToBank(address asset, address user, uint256 amount) internal {

511:     } 
512: 
513:     function min(uint256 a, uint256 b) internal pure returns (uint256) {

515:     } 
```


```solidity
📁 File: InvestorStrategyProxy.sol

4: interface IERC20 { 
5:     function approve(address, uint256) external returns (bool);
6:     function transfer(address, uint256) external returns (bool);

9: interface IStrategy { 
10:     function mint(uint256 amount) external returns (uint256 shares);
11:     function burn(uint256 shares) external returns (uint256 amount);
12:     function kill(uint256 shares, address to) external returns (bytes memory);

15: contract InvestorStrategyProxy { 
16:     IERC20 public asset;

19:     event File(bytes32 indexed what, address data); 
20: 
21:     error InvalidFile();

27:     } 
28: 
29:     modifier auth() {

32:     } 
33: 
34:     function file(bytes32 what, address data) public auth {

41:     } 
42: 
43:     function mint(address strategy, uint256 amount) public auth returns (uint256) {

46:     } 
47: 
48:     function burn(address strategy, uint256 shares) public auth returns (uint256) {

52:     } 
53: 
54:     function kill(address strategy, uint256 shares, address target) public auth returns (bytes memory) {

56:     } 
57: 
58:     function call(address strategy, uint256 value, bytes calldata data) public auth {

66:     } 
```


```solidity
📁 File: PositionManager.sol

7: interface IERC20 { 
8:     function decimals() external view returns (uint8);
9:     function balanceOf(address) external view returns (uint256);
10:     function approve(address, uint256) external returns (bool);
11:     function transfer(address, uint256) external returns (bool);
12:     function transferFrom(address, address, uint256) external returns (bool);

15: interface IOracle { 
16:     function latestAnswer() external view returns (int256);
17:     function decimals() external view returns (uint8);

20: interface IPool { 
21:     function asset() external view returns (address);
22:     function oracle() external view returns (address);
23:     function getUpdatedIndex() external view returns (uint256);

26: interface IStrategy { 
27:     function name() external view returns (string memory);
28:     function rate(uint256 shares) external view returns (uint256);

31: interface IInvestor { 
32:     struct Strategy {

47:     function getPool() external view returns (address); 
48:     function getStrategy(uint256 id) external view returns (Strategy memory);
49:     function getPosition(uint256 id) external view returns (Position memory);
50:     function life(uint256 id) external view returns (uint256);
51:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external returns (uint256);
52:     function edit(uint256 id, int256 borrow, int256 collateral) external;

55: interface IWhitelist { 
56:     function check(address) external view returns (bool);

59: interface ERC721TokenReceiver { 
60:     function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4);

64: contract PositionManager { 
65:     string public constant name = "Rodeo V2 Position";

89:     } 
90: 
91:     constructor(address _investor) {

94:     } 
95: 
96:     modifier admin() {

99:     } 
100: 
101:     function file(bytes32 what, address data) external admin {

112:     } 
113: 
114:     function ownerOf(uint256 id) public view returns (address owner) {

116:     } 
117: 
118:     function balanceOf(address owner) public view returns (uint256) {

121:     } 
122: 
123:     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) {

125:     } 
126: 
127:     function tokensOfOwner(address owner, uint256 start, uint256 end) external view returns (uint256[] memory v) {

132:     } 
133: 
134:     modifier auth(uint256 id) {

141:     } 
142: 
143:     function approve(address spender, uint256 id) public {

148:     } 
149: 
150:     function setApprovalForAll(address operator, bool approved) public {

153:     } 
154: 
155:     function moveId(address from, address to, uint256 id) internal {

180:     } 
181: 
182:     function transferFrom(address from, address to, uint256 id) public auth(id) {

186:     } 
187: 
188:     function safeTransferFrom(address from, address to, uint256 id) public {

196:     } 
197: 
198:     function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public {

212:     } 
213: 
214:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow, address to) public returns (uint256) {

231:     } 
232: 
233:     function edit(uint256 id, int256 borrow, int256 collateral) public auth(id) {

242:     } 
243: 
244:     function burn(uint256 id) public auth(id) {

250:     } 
251: 
252:     function forceBurn(uint256 id) public auth(id) {

256:     } 
257: 
258:     function rely(address ast, uint256 amt) internal {

260:     } 
261: 
262:     function pull(address ast, address usr, uint256 amt) internal {

264:     } 
265: 
266:     function push(address ast, address usr) internal {

270:     } 
271: 
272:     function tokenURI(uint256 id) public view returns (string memory) {

291:     } 
292: 
293:     function generateImage(uint256 id) private view returns (string memory) {

307:     } 
308: 
309:     function generateHeader(uint256 id) private view returns (string memory) {

321:     } 
322: 
323:     function generateLabelVal(uint256 id) private view returns (string memory) {

337:     } 
338: 
339:     function generateLabelBor(uint256 id) private view returns (string memory) {

357:     } 
358: 
359:     function generateLabelLif(uint256 id) private view returns (string memory) {

382:     } 
```


```solidity
📁 File: Store.sol

4: contract Store { 
5:     mapping(address => bool) public exec;

18:     } 
19: 
20:     event File(bytes32 indexed what, address data);
21: 
22:     error InvalidFile();

28:     } 
29: 
30:     modifier auth() {

33:     } 
34: 
35:     function file(bytes32 what, address data) external auth {

42:     } 
43: 
44:     function getUint(bytes32 key) external view returns (uint256) {

46:     } 
47:     function setUint(bytes32 key, uint256 value) external auth returns (uint256) {

50:     } 
51:     function setUintDelta(bytes32 key, int256 value) external auth returns (uint256) {

58:     } 
59:     function removeUint(bytes32 key) external auth {

61:     } 
62:     function getInt(bytes32 key) external view returns (int256) {

64:     } 
65:     function setInt(bytes32 key, int256 value) external auth returns (int256) {

68:     } 
69:     function setIntDelta(bytes32 key, int256 value) external auth returns (int256) {

73:     } 
74:     function removeInt(bytes32 key) external auth {

76:     } 
77:     function getAddress(bytes32 key) external view returns (address) {

79:     } 
80:     function setAddress(bytes32 key, address value) external auth returns (address) {

83:     } 
84:     function removeAddress(bytes32 key) external auth {

86:     } 
87:     function getBool(bytes32 key) external view returns (bool) {

89:     } 
90:     function setBool(bytes32 key, bool value) external auth returns (bool) {

93:     } 
94:     function removeBool(bytes32 key) external auth {

96:     } 
97:     function getString(bytes32 key) external view returns (string memory) {

99:     } 
100:     function setString(bytes32 key, string memory value) external auth returns (string memory) {

103:     } 
104:     function removeString(bytes32 key) external auth {

106:     } 
107:     function getBytes32(bytes32 key) external view returns (bytes32) {

109:     } 
110:     function setBytes32(bytes32 key, bytes32 value) external auth returns (bytes32) {

113:     } 
114:     function removeBytes32(bytes32 key) external auth {

116:     } 
117: 
118:     function getBytes32Array(bytes32 key) external view returns (bytes32[] memory) {

120:     } 
121:     function setBytes32Array(bytes32 key, bytes32[] memory value) external auth {

123:     } 
124:     function removeBytes32Array(bytes32 key) external auth {

126:     } 
127: 
128:     function containsBytes32(bytes32 key, bytes32 value) external view returns (bool) {

130:     } 
131:     function getBytes32Count(bytes32 key) external view returns (uint256) {

133:     } 
134:     function getBytes32ValuesAt(bytes32 key, uint256 start, uint256 end) external view returns (bytes32[] memory v) {

139:     } 
140:     function addBytes32(bytes32 key, bytes32 value) external auth {

146:     } 
147:     function removeBytes32(bytes32 key, bytes32 value) external auth {

161:     } 
```


```solidity
📁 File: StrategyCamelotV3.sol

7: contract StrategyCamelotV3 { 
8:     string public name;

76:     } 
77: 
78:     modifier loop() {

105:     } 
106: 
107:     function file(bytes32 what, uint256 data) external auth {

117:     } 
118: 
119:     function setPathToLp(bytes calldata newPathToLp) external auth {

121:     } 
122: 
123:     function setNitroPool(address _nitroPool) external auth {

131:     } 
132: 
133:     function xgrailRedeem(uint256 amount, uint256 duration) external auth {

135:     } 
136: 
137:     function xgrailFinalizeRedeem(uint256 index) external auth {

139:     } 
140: 
141:     function mint(uint256 amount) external auth loop returns (uint256) {

168:     } 
169: 
170:     function burn(uint256 shares) external auth loop returns (uint256) {

204:     } 
205: 
206:     function stake(uint256 amount) internal {

216:     } 
217: 
218:     function unstake(uint256 amount) internal {

226:     } 
227: 
228:     function earn() external payable loop {

274:     } 
275: 
276:     function exit(address strategy) external auth {

282:     } 
283: 
284:     function move(address old) external auth {

295:     } 
296: 
297:     function quoteAddLiquidity(uint256 amt, address trgtAst, bytes memory path) private returns (uint256, uint256) {

318:     } 
319: 
320:     function quoteAndSwap(address trgtAst, uint256 amt, uint256 slp) private returns (uint256 amt0, uint256 amt1) {

342:     } 
343: 
344:     function valueLiquidity() private view returns (uint256) {

368:     } 
369: 
370:     function totalManagedAssets() private view returns (uint256) {

374:     } 
375: 
376:     function getPosition(uint160 midX96, int24 minTick, int24 maxTick) private view returns (uint256, uint256) {

388:     } 
389: 
390:     function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external returns (bytes4) {

395:     } 
396: 
397:     function onNFTHarvest(address, address, uint256, uint256, uint256) public pure returns (bool) {

399:     } 
400: 
401:     function onNFTAddToPosition(address, uint256, uint256) public pure returns (bool) {

403:     } 
404: 
405:     function onNFTWithdraw(address, uint256, uint256) public pure returns (bool) {

407:     } 
408: 
409:     function min(uint256 a, uint256 b) internal pure returns (uint256) {

411:     } 

414: interface IERC20 { 
415:     function symbol() external view returns (string memory);
416:     function balanceOf(address) external view returns (uint256);
417:     function approve(address, uint256) external;
418:     function transfer(address, uint256) external;
419:     function transferFrom(address, address, uint256) external;

422: interface IStrategyHelper { 
423:     function value(address, uint256) external view returns (uint256);
424:     function convert(address, address, uint256) external view returns (uint256);
425:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

428: interface IStrategyHelperUniswapV3 { 
429:     function swap(address ast, bytes calldata path, uint256 amt, uint256 min, address to) external;

432: interface IUniProxy { 
433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares);
434:     function getDepositAmount(address pos, address token, uint256 deposit) external view returns (uint256 amountStart, uint256 amountEnd);

437: interface IQuoter { 
438:     function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);

441: interface IHypervisor is IERC20 { 
442:     function withdraw(uint256 shares, address to, address from, uint256[4] memory minAmounts) external returns (uint256 amount0, uint256 amount1);
443:     function pool() external view returns (IAlgebraPool);
444:     function token0() external view returns (IERC20);
445:     function token1() external view returns (IERC20);
446:     function totalSupply() external view returns (uint256);
447:     function baseLower() external view returns (int24);
448:     function baseUpper() external view returns (int24);
449:     function limitLower() external view returns (int24);
450:     function limitUpper() external view returns (int24);

453: interface INFTPool { 
454:     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;
455:     function createPosition(uint256 amount, uint256 lockDuration) external;
456:     function addToPosition(uint256 tokenId, uint256 amountToAdd) external;
457:     function withdrawFromPosition(uint256 tokenId, uint256 amountToWithdraw) external;
458:     function harvestPosition(uint256 tokenId) external;
459:     function getStakingPosition(uint256 tokenId) external view returns (

466: interface INitroPool { 
467:     function harvest() external;
468:     function withdraw(uint256 tokenId) external;

471: interface IAlgebraPool { 
472:     function token0() external view returns (address);
473:     function token1() external view returns (address);
474:     function getTimepoints(uint32[] calldata secondsAgos) external view returns (

479:     ); 
480:     function positions(bytes32 key) external view returns (

490: interface IXGrail { 
491:   function redeem(uint256 xGrailAmount, uint256 duration) external;
492:   function finalizeRedeem(uint256 redeemIndex) external;
```


```solidity
📁 File: StrategyGMXGM.sol

4: contract StrategyGMXGM { 
5:     string public name;

78:     } 
79: 
80:     receive() external payable {}
81: 
82:     modifier loop() {

113:     } 
114: 
115:     function file(bytes32 what, uint256 data) external auth {

131:     } 
132: 
133:     function withdrawEth() external auth {

136:     } 
137: 
138:     function withdrawAirdrop(address token) external auth {

141:     } 
142: 
143:     function mint(uint256 amount) external auth loop returns (uint256) {

157:     } 
158: 
159:     function burn(uint256 shares) external auth loop returns (uint256) {

169:     } 
170: 
171:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) {

182:     } 
183: 
184:     function earn() external payable loop {

281:     } 
282: 
283:     function exit(address strategy) external auth {

290:     } 
291: 
292:     function move(address old) external auth {}
293: 
294:     function rate(uint256 shares) public view returns (uint256) {

302:     } 
303: 
304:     function marketTokenPrice(bool isDeposit) public view returns (uint256) {

320:     } 
321: 
322:     bytes32 constant MAX_PNL_FACTOR_FOR_DEPOSITS = keccak256(abi.encode("MAX_PNL_FACTOR_FOR_DEPOSITS"));

333:     } 
334: 
335:     function afterDepositExecution(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external {

338:     } 
339: 
340:     function afterDepositCancellation(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external {

343:     } 
344: 
345:     function afterWithdrawalExecution(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external {

351:     } 
352: 
353:     function afterWithdrawalCancellation(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external {

356:     } 
357: 
358:     function min(uint256 a, uint256 b) internal pure returns (uint256) {

360:     } 

363: interface IERC20 { 
364:     function symbol() external view returns (string memory);
365:     function decimals() external view returns (uint8);
366:     function balanceOf(address) external view returns (uint256);
367:     function approve(address, uint256) external;
368:     function transfer(address, uint256) external;
369:     function transferFrom(address, address, uint256) external;

372: interface IStrategyHelper { 
373:     function price(address) external view returns (uint256);
374:     function value(address, uint256) external view returns (uint256);
375:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

378: interface IHandler { 
379:     function depositVault() external view returns (address);
380:     function withdrawalVault() external view returns (address);

383: interface IPriceFeed { 
384:     function latestRoundData() external view returns (

393: interface IDataStore { 
394:     function getUint(bytes32 key) external view returns (uint256);
395:     function getAddress(bytes32 key) external view returns (address);
396:     function getBytes32(bytes32 key) external view returns (bytes32);

399: interface IExchangeRouter { 
400:     struct CreateDepositParams {

429:     function sendWnt(address receiver, uint256 amount) external payable; 
430:     function sendTokens(address token, address receiver, uint256 amount) external payable;
431:     function createDeposit(CreateDepositParams calldata params) external payable returns (bytes32);
432:     function createWithdrawal(CreateWithdrawalParams calldata params) external payable returns (bytes32);
433:     function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);
434:     function router() external returns (address);

437: interface IMarket { 
438:     struct Prices {

454: interface IPrice { 
455:     struct Props {

461: interface IMarketPoolValueInfo { 
462:     struct Props {

477: interface IReader { 
478:     function getMarket(address dataStore, address key) external view returns (IMarket.Props memory);
479:     function getMarketTokenPrice(

487:     ) external view returns (int256, IMarketPoolValueInfo.Props memory); 
488:     function getWithdrawalAmountOut(

497: interface IDeposit { 
498:     struct Props {

530: interface IWithdrawal { 
531:     struct Props {

561: interface IEventUtils { 
562:     struct EventLogData {
```


```solidity
📁 File: StrategySushiswap.sol

4: contract StrategySushiswap { 
5:     string public name;

38:     } 
39: 
40:     modifier loop() {

61:     } 
62: 
63:     function file(bytes32 what, uint256 data) external auth {

70:     } 
71: 
72:     function rate(uint256 sha) public view returns (uint256) {

88:     } 
89: 
90:     function mint(uint256 amount) public auth loop returns (uint256) { 

115:     } 
116: 
117:     function burn(uint256 shares) public auth loop returns (uint256) {

151:     } 
152: 
153:     function earn() public payable loop {

175:     } 
176: 
177:     function totalManagedAssets() public view returns (uint256) {

180:     } 
181: 
182:     function exit(address strategy) public auth {

184:     } 
185: 
186:     function move(address old) public auth {

194:     } 
195: 
196:     function min(uint256 a, uint256 b) internal pure returns (uint256) {

214:     } 
215: 
216:     function log2(uint256 value) internal pure returns (uint256) {

250:     } 

253: interface IERC20 { 
254:     function symbol() external view returns (string memory);
255:     function decimals() external view returns (uint8);
256:     function balanceOf(address) external view returns (uint256);
257:     function approve(address, uint256) external returns (bool);
258:     function transfer(address, uint256) external returns (bool);
259:     function transferFrom(address, address, uint256) external returns (bool);

262: interface IStrategyHelper { 
263:     function price(address) external view returns (uint256);
264:     function value(address, uint256) external view returns (uint256);
265:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

268: interface IUniswapV2Pair { 
269:     function token0() external view returns (address);
270:     function token1() external view returns (address);
271:     function totalSupply() external view returns (uint256);
272:     function getReserves() external view returns (uint112, uint112, uint32);
273:     function price0CumulativeLast() external view returns (uint256);
274:     function price1CumulativeLast() external view returns (uint256);
275:     function mint(address) external returns (uint256 liquidity);
276:     function burn(address) external returns (uint256 amount0, uint256 amount1);
277:     function swap(uint256, uint256, address, bytes calldata) external;
278:     function skim(address to) external;

281: interface ISushiswapMiniChefV2 { 
282:     function SUSHI() external view returns (address);
283:     function lpToken(uint256) external view returns (address);
284:     function pendingSushi(uint256, address) external view returns (uint256);
285:     function userInfo(uint256, address) external view returns (uint256, int256);
286:     function deposit(uint256, uint256, address) external;
287:     function withdraw(uint256, uint256, address) external;
288:     function harvest(uint256, address) external;
```


```solidity
📁 File: UtilFarmingBalances.sol

4: interface IInvestor { 
5:     function nextPosition() external view returns (uint256);
6:     function positions(uint256) external view returns (address, address, uint256, uint256, uint256, uint256, uint256);

9: interface IPositionManager { 
10:     function ownerOf(uint256) external view returns (address);

13: contract UtilFarmingBalances { 
14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) {
```


```solidity
📁 File: Whitelist.sol

4: contract Whitelist { 
5:     mapping(address => bool) public exec;

16:     } 
17: 
18:     modifier auth() {

21:     } 
22: 
23:     function file(bytes32 what, address data) external auth {

32:     } 
33: 
34:     function batchWhitelist(address[] memory addresses, bool status) external auth {

40:     } 
41: 
42:     function check(address user) external view returns (bool) {

44:     } 
```


</details>


---
### [NC&#x2011;111] Typos
<details>
<summary><i>There are 5 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

/// @audit dont -> font
343:                     // If we don't have enough USDC from shares, sell some collateral 

/// @audit topup -> popup
375:             // as topup for the repayment of the debt 

/// @audit liquidatable -> liquidate
422:                 // could be liquidatable if "expired/forced to exit" 

/// @audit dont -> font
430:             // profit position, we don't want to use all shares 
```


```solidity
📁 File: PositionManager.sol

/// @audit Solmate -> Sol mate
63: /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol) 
```


</details>


---
### [NC&#x2011;112] Unnecessary cast
The variable is being cast to its own type

<details>
<summary><i>There are 8 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

/// @audit amt
377:             collateralAdjusted = -int256(amt); 
```


```solidity
📁 File: Store.sol

/// @audit prev
53:         uint256 next = uint256(int256(prev) + value); 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit twapPeriod
112:             twapPeriod = uint32(twapPeriod); 

/// @audit period
352:         uint160 midX96 = TickMath.getSqrtRatioAtTick(int24((tickCumulatives[1] - tickCumulatives[0]) / int32(period))); 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit msg.sender
134:         (bool success,) = address(msg.sender).call{value: address(this).balance}(""); 

/// @audit market
139:       if (token == address(market) || token == tokenShort || token == tokenLong) revert BadToken(); 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit tok0
102:             IERC20(tok0).transfer(address(pair), tok0.balanceOf(address(this))); 
/// @audit tok1
103:             IERC20(tok1).transfer(address(pair), tok1.balanceOf(address(this)));
```


</details>


---
### [NC&#x2011;113] Unnecessary struct attribute prefix
Attributes within a struct are redundantly prefixed, which is unnecessary as they are inherently associated with the struct. Consider simplifying the attribute names by removing the redundant prefix.

By removing the repetitive prefix, the code maintains its contextual clarity while becoming more concise and easy to read.


<i>There are 21 instaces of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

/// @audit items
572:     struct AddressItems { 
573:         AddressKeyValue[] items;
574:         AddressArrayKeyValue[] arrayItems;
575:     }

/// @audit items
577:     struct UintItems { 
578:         UintKeyValue[] items;
579:         UintArrayKeyValue[] arrayItems;
580:     }

/// @audit items
582:     struct IntItems { 
583:         IntKeyValue[] items;
584:         IntArrayKeyValue[] arrayItems;
585:     }

/// @audit items
587:     struct BoolItems { 
588:         BoolKeyValue[] items;
589:         BoolArrayKeyValue[] arrayItems;
590:     }

/// @audit items
592:     struct Bytes32Items { 
593:         Bytes32KeyValue[] items;
594:         Bytes32ArrayKeyValue[] arrayItems;
595:     }

/// @audit items
597:     struct BytesItems { 
598:         BytesKeyValue[] items;
599:         BytesArrayKeyValue[] arrayItems;
600:     }

/// @audit items
602:     struct StringItems { 
603:         StringKeyValue[] items;
604:         StringArrayKeyValue[] arrayItems;
605:     }

/// @audit value
607:     struct AddressKeyValue { 
608:         string key;
609:         address value;
610:     }

/// @audit value
612:     struct AddressArrayKeyValue { 
613:         string key;
614:         address[] value;
615:     }

/// @audit value
617:     struct UintKeyValue { 
618:         string key;
619:         uint256 value;
620:     }

/// @audit value
622:     struct UintArrayKeyValue { 
623:         string key;
624:         uint256[] value;
625:     }

/// @audit value
627:     struct IntKeyValue { 
628:         string key;
629:         int256 value;
630:     }

/// @audit value
632:     struct IntArrayKeyValue { 
633:         string key;
634:         int256[] value;
635:     }

/// @audit value
637:     struct BoolKeyValue { 
638:         string key;
639:         bool value;
640:     }

/// @audit value
642:     struct BoolArrayKeyValue { 
643:         string key;
644:         bool[] value;
645:     }

/// @audit value
647:     struct Bytes32KeyValue { 
648:         string key;
649:         bytes32 value;
650:     }

/// @audit value
652:     struct Bytes32ArrayKeyValue { 
653:         string key;
654:         bytes32[] value;
655:     }

/// @audit value
657:     struct BytesKeyValue { 
658:         string key;
659:         bytes value;
660:     }

/// @audit value
662:     struct BytesArrayKeyValue { 
663:         string key;
664:         bytes[] value;
665:     }

/// @audit value
667:     struct StringKeyValue { 
668:         string key;
669:         string value;
670:     }

/// @audit value
672:     struct StringArrayKeyValue { 
673:         string key;
674:         string[] value;
675:     }
```



---
### [NC&#x2011;114] Unsafe ERC20 operation(s)
Use the safe versions of these functions:
 - `transfer` --> `safeTransfer`
 - `transferFrom` --> `safeTransferFrom`

> ❗ Issue is removed from: (pech)

<details>
<summary><i>There are 27 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

43:         if (!IERC20(token).transfer(to, amount)) revert TransferFailed(); 
```


```solidity
📁 File: Helper.sol

65:             IERC20(a).transfer(a, IERC20(a).balanceOf(address(this))); 

72:         asset.transfer(msg.sender, asset.balanceOf(address(this)) - amount - premium); 
```


```solidity
📁 File: Investor.sol

252:         IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))); 

347:                     bank.transfer(p.token, address(this), cAmount); 

379:             bank.transfer(p.token, msg.sender, amt); 

410:         IERC20(poolAsset).transferFrom(msg.sender, address(this), borrow + fee); 

425:                 bank.transfer(p.token, msg.sender, collat); 

501:         if (!IERC20(asset).transfer(user, amount)) { 

508:         if (!IERC20(asset).transferFrom(user, store.getAddress(BANK), amount)) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

50:         asset.transfer(msg.sender, amount); 
```


```solidity
📁 File: PositionManager.sol

263:         if (!IERC20(ast).transferFrom(usr, address(this), amt)) revert TransferFailed(); 

269:         if (bal > 0 && !asset.transfer(usr, bal)) revert TransferFailed(); 
```


```solidity
📁 File: StrategyCamelotV3.sol

142:         asset.transferFrom(msg.sender, address(this), amount); 

196:         hypervisor.transfer(to, amount); 

340:         IERC20(trgtAst).transfer(address(strategyHelperUniswapV3), toLp); 
```


```solidity
📁 File: StrategyGMXGM.sol

140:       IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))); 

148:         asset.transferFrom(msg.sender, address(this), amount); 

174:         IERC20(tokenShort).transfer(to, amount); 

287:         IERC20(market).transfer(strategy, IERC20(market).balanceOf(address(this))); 
288:         IERC20(tokenLong).transfer(strategy, IERC20(tokenLong).balanceOf(address(this)));
289:         IERC20(tokenShort).transfer(strategy, IERC20(tokenShort).balanceOf(address(this)));
```


```solidity
📁 File: StrategySushiswap.sol

91:         asset.transferFrom(msg.sender, address(this), amount); 

102:             IERC20(tok0).transfer(address(pair), tok0.balanceOf(address(this))); 
103:             IERC20(tok1).transfer(address(pair), tok1.balanceOf(address(this)));

166:         IERC20(pair.token0()).transfer(address(pair), IERC20(pair.token0()).balanceOf(address(this))); 
167:         IERC20(pair.token1()).transfer(address(pair), IERC20(pair.token1()).balanceOf(address(this)));
```


</details>


---
### [NC&#x2011;115] Unspecific compiler version pragma
Some files use `>=`, some use `^`. The instances below are examples of the method that has the fewest instances for a specific version. Note that using `>=` without also specifying `<=` will lead to failures to compile, or external project incompatability, when the major version changes and there are breaking-changes, so `^` should be preferred regardless of the instance counts

<details>
<summary><i>There are 7 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Deploy.s.sol

2: pragma solidity ^0.8.17; 
```


```solidity
📁 File: Helper.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Investor.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Store.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: UtilFarmingBalances.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Whitelist.sol

2: pragma solidity ^0.8.0; 
```


</details>


---
### [NC&#x2011;116] Unused function parameter
Comment out the variable name to suppress compiler warnings


<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

/// @audit old is unused
292:     function move(address old) external auth {} 
```



---
### [NC&#x2011;117] Unused `struct` definition
Note that there may be cases where a struct superficially appears to be used, but this is only because there are multiple definitions of the struct in different files. In such cases, the struct definition should be moved into a separate file. The instances below are the unused definitions.


<i>There are 7 instaces of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

438:     struct Prices { 
439:         IPrice.Props indexTokenPrice;
440:         IPrice.Props longTokenPrice;
441:         IPrice.Props shortTokenPrice;
442:     }

444:     struct Props { 
445:         address marketToken;
446:         address indexToken;
447:         address longToken;
448:         address shortToken;
449:     }

455:     struct Props { 
456:         uint256 min;
457:         uint256 max;
458:     }

462:     struct Props { 
463:         int256 poolValue;
464:         int256 longPnl;
465:         int256 shortPnl;
466:         int256 netPnl;
467:         uint256 longTokenAmount;
468:         uint256 shortTokenAmount;
469:         uint256 longTokenUsd;
470:         uint256 shortTokenUsd;
471:         uint256 totalBorrowingFees;
472:         uint256 borrowingFeePoolFactor;
473:         uint256 impactPoolAmount;
474:     }

498:     struct Props { 
499:         Addresses addresses;
500:         Numbers numbers;
501:         Flags flags;
502:     }

531:     struct Props { 
532:         Addresses addresses;
533:         Numbers numbers;
534:         Flags flags;
535:     }

562:     struct EventLogData { 
563:         AddressItems addressItems;
564:         UintItems uintItems;
565:         IntItems intItems;
566:         BoolItems boolItems;
567:         Bytes32Items bytes32Items;
568:         BytesItems bytesItems;
569:         StringItems stringItems;
570:     }
```



---
### [NC&#x2011;118] Unusual loop variable
The normal name for loop variables is `i`, and when there is a nested loop, to use `j`. Not following this convention may lead to some reviewer confusion


<i>There is one instance of this issue:</i>

```solidity
📁 File: UtilFarmingBalances.sol

20:         for (uint256 y = start; y < max; y++) { 
```



---
### [NC&#x2011;119] Use a single file for system wide constants
Consider grouping all the system constants under a single file. This finding shows only the first constant for each file, for brevity.

<details>
<summary><i>There are 25 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

78:     uint256 public constant STATUS_LIVE = 4; 
79:     uint256 public constant STATUS_WITHDRAW = 3;
80:     uint256 public constant STATUS_LIQUIDATE = 2;
81:     uint256 public constant STATUS_PAUSED = 1;
82:     bytes32 constant STATUS = keccak256(abi.encode("STATUS"));
83:     bytes32 constant BANK = keccak256(abi.encode("BANK"));
84:     bytes32 constant POOL = keccak256(abi.encode("POOL"));
85:     bytes32 constant STRATEGIES_ADDRESS = keccak256(abi.encode("STRATEGIES_ADDRESS"));
86:     bytes32 constant STRATEGIES_CAP = keccak256(abi.encode("STRATEGIES_CAP"));
87:     bytes32 constant STRATEGIES_STATUS = keccak256(abi.encode("STRATEGIES_STATUS"));
88:     bytes32 constant COLLATERAL_FACTOR = keccak256(abi.encode("COLLATERAL_FACTOR"));
89:     bytes32 constant COLLATERAL_CAP = keccak256(abi.encode("COLLATERAL_CAP"));
90:     bytes32 constant POSITIONS = keccak256(abi.encode("POSITIONS"));
91:     bytes32 constant POSITIONS_OWNER = keccak256(abi.encode("POSITIONS_OWNER"));
92:     bytes32 constant POSITIONS_START = keccak256(abi.encode("POSITIONS_START"));
93:     bytes32 constant POSITIONS_STRATEGY = keccak256(abi.encode("POSITIONS_STRATEGY"));
94:     bytes32 constant POSITIONS_TOKEN = keccak256(abi.encode("POSITIONS_TOKEN"));
95:     bytes32 constant POSITIONS_COLLATERAL = keccak256(abi.encode("POSITIONS_COLLATERAL"));
96:     bytes32 constant POSITIONS_BASIS = keccak256(abi.encode("POSITIONS_BASIS"));
97:     bytes32 constant POSITIONS_SHARES = keccak256(abi.encode("POSITIONS_SHARES"));
98:     bytes32 constant POSITIONS_BORROW = keccak256(abi.encode("POSITIONS_BORROW"));
```


```solidity
📁 File: PositionManager.sol

65:     string public constant name = "Rodeo V2 Position"; 
66:     string public constant symbol = "RP2";
```


```solidity
📁 File: StrategyGMXGM.sol

322:     bytes32 constant MAX_PNL_FACTOR_FOR_DEPOSITS = keccak256(abi.encode("MAX_PNL_FACTOR_FOR_DEPOSITS")); 
323:     bytes32 constant MAX_PNL_FACTOR_FOR_WITHDRAWALS = keccak256(abi.encode("MAX_PNL_FACTOR_FOR_WITHDRAWALS"));
```


</details>


---
### [NC&#x2011;120] Use a struct to encapsulate multiple function parameters
If a function has too many parameters, replacing them with a struct can improve code readability and maintainability, increase reusability, and reduce the likelihood of errors when passing the parameters.

<details>
<summary><i>There are 12 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

16:     function flashLoanSimple(address receiver, address asset, uint256 amount, bytes calldata params, uint16 referrer) external; 

20:     function swap(address, address, uint256, uint256, address) external returns (uint256); 

48:     function executeOperation( 
49:       address,
50:       uint256 amount,
51:       uint256 premium,
52:       address initiator,
53:       bytes calldata params
54:     ) external returns (bool) {
```


```solidity
📁 File: Investor.sol

44:     function swap(address, address, uint256, uint256, address) external returns (uint256); 
```


```solidity
📁 File: PositionManager.sol

214:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow, address to) public returns (uint256) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

338:     function swap(address trgtAst, address ast, bytes memory path, uint256 toLp, uint256 slp) private { 

397:     function onNFTHarvest(address, address, uint256, uint256, uint256) public pure returns (bool) { 

425:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256); 

429:     function swap(address ast, bytes calldata path, uint256 amt, uint256 min, address to) external; 

433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares); 
```


```solidity
📁 File: StrategyGMXGM.sol

375:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256); 
```


```solidity
📁 File: StrategySushiswap.sol

265:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256); 
```


</details>


---
### [NC&#x2011;121] Use `abi.encodeCall()` instead of `abi.encodeSignature()`/`abi.encodeSelector()`
`abi.encodeCall()` has compiler [type safety](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3693), whereas the other two functions do not

<details>
<summary><i>There are 8 instances of this issue:</i></summary>

```solidity
📁 File: StrategyGMXGM.sol

235:             data[0] = abi.encodeWithSelector(IExchangeRouter.sendWnt.selector, vault, params.executionFee); 
236:             data[1] = abi.encodeWithSelector(IExchangeRouter.sendTokens.selector, marketInfo.longToken, vault, out);

238:                 abi.encodeWithSelector(IExchangeRouter.sendTokens.selector, marketInfo.shortToken, vault, amt - haf); 
239:             data[3] = abi.encodeWithSelector(IExchangeRouter.createDeposit.selector, params);

273:             data[0] = abi.encodeWithSelector(IExchangeRouter.sendWnt.selector, withdrawalVault, params.executionFee); 
274:             data[1] = abi.encodeWithSelector(IExchangeRouter.sendTokens.selector, market, withdrawalVault, amt);
275:             data[2] = abi.encodeWithSelector(IExchangeRouter.createWithdrawal.selector, params);
```


```solidity
📁 File: UtilFarmingBalances.sol

22:             (bool ok, bytes memory data) = address(pm).staticcall(abi.encodeWithSelector(IPositionManager.ownerOf.selector, y)); 
```


</details>


---
### [NC&#x2011;122] Use `bytes.concat()` on bytes instead of `abi.encodePacked()` for clearer semantic meaning
Starting with version 0.8.4, Solidity has the `bytes.concat()` function, which allows one to concatenate a list of bytes/strings, without extra padding. Using this function rather than `abi.encodePacked()` makes the intended operation more clear, leading to less reviewer confusion.

<details>
<summary><i>There are 12 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

275:             abi.encodePacked( 
276:                 "data:application/json;base64,",
277:                 Base64.encode(
278:                     bytes(
279:                         abi.encodePacked(
280:                             '{"name":"#',
281:                             Strings.toString(id),
282:                             '","description":"This NFT represents a leveraged farming position on Rodeo Finance. The owner of this NFT can modify or redeem the position.","image":"',
283:                             "data:image/svg+xml;base64,",
284:                             image,
285:                             '"}'
286:                         )
287:                     )
288:                 )
289:             )

295:             abi.encodePacked( 
296:                 '<svg width="290" height="290" viewBox="0 0 290 290" xmlns="http://www.w3.org/2000/svg"',
297:                 " xmlns:xlink='http://www.w3.org/1999/xlink'>",
298:                 '<defs><clipPath id="corners"><rect width="290" height="290" rx="42" ry="42" /></clipPath><linearGradient id="0" x1="0.5" y1="0" x2="0.5" y2="1"><stop offset="0%" stop-color="#f3a526"/><stop offset="100%" stop-color="#e7940b"/></linearGradient><radialGradient id="1" gradientTransform="translate(-1 -0.5) scale(2, 2)"><stop offset="10%" stop-color="#f3a526"/><stop offset="100%" stop-color="#ffca74"/></radialGradient></defs>',
299:                 '<g clip-path="url(#corners)"><rect fill="url(#0)" x="0px" y="0px" width="290px" height="290px" /><rect fill="url(#1)" x="0px" y="0px" width="290px" height="290px" /><ellipse cx="50%" cy="32px" rx="220px" ry="120px" fill="rgba(255,255,255,0.2)" opacity="0.85" /><rect x="16" y="16" width="258" height="258" rx="26" ry="26" fill="rgba(0,0,0,0)" stroke="rgba(255,255,255,0.4)" />',
300:                 generateHeader(id),
301:                 generateLabelVal(id),
302:                 generateLabelBor(id),
303:                 generateLabelLif(id),
304:                 "</g></svg>"
305:             )

313:             abi.encodePacked( 
314:                 '<text y="64px" x="32px" fill="white" font-family="\'Courier New\', monospace" font-weight="600" font-size="32px">#',
315:                 Strings.toString(id),
316:                 '</text><text y="111px" x="32px" fill="white" font-family="\'Courier New\', monospace" font-weight="200" font-size="24px">',
317:                 IStrategy(s.implementation).name(),
318:                 "</text>"
319:             )

329:             abi.encodePacked( 
330:                 '<g style="transform:translate(29px, 175px)"><rect width="',
331:                 Strings.toString(7 * (len + 4)),
332:                 'px" height="26px" rx="8px" ry="8px" fill="rgba(0,0,0,0.4)" /><text x="12px" y="17px" font-family="\'Courier New\', monospace" font-size="12px" fill="white"><tspan fill="rgba(255,255,255,0.6)">Value: </tspan>',
333:                 str,
334:                 "</text></g>"
335:             )

349:             abi.encodePacked( 
350:                 '<g style="transform:translate(29px, 205px)"><rect width="',
351:                 Strings.toString(7 * (len + 4)),
352:                 'px" height="26px" rx="8px" ry="8px" fill="rgba(0,0,0,0.4)" /><text x="12px" y="17px" font-family="\'Courier New\', monospace" font-size="12px" fill="white"><tspan fill="rgba(255,255,255,0.6)">Borrow: </tspan>',
353:                 str,
354:                 "</text></g>"
355:             )

364:             abi.encodePacked( 
365:                 '<g style="transform:translate(29px, 235px)"><rect width="',
366:                 Strings.toString(7 * (len + 4)),
367:                 'px" height="26px" rx="8px" ry="8px" fill="rgba(0,0,0,0.4)" /><text x="12px" y="17px" font-family="\'Courier New\', monospace" font-size="12px" fill="white"><tspan fill="rgba(255,255,255,0.6)">Life: </tspan>',
368:                 str,
369:                 "</text></g>"
370:             )

379:             sr = abi.encodePacked("0", sr); 

381:         return string(abi.encodePacked(Strings.toString(n / x), ".", sr)); 
```


```solidity
📁 File: StrategyCamelotV3.sol

71:         name = string(abi.encodePacked("Camelot V3 ", hypervisor.token0().symbol(), "/", hypervisor.token1().symbol())); 
```


```solidity
📁 File: StrategyGMXGM.sol

74:             abi.encodePacked( 
75:                 "GMX GM ", IERC20(marketInfo.longToken).symbol(), "/", IERC20(marketInfo.shortToken).symbol()
76:             )
```


```solidity
📁 File: StrategySushiswap.sol

37:             string(abi.encodePacked("SushiSwap ", IERC20(pool.token0()).symbol(), "/", IERC20(pool.token1()).symbol())); 
```


</details>


---
### [NC&#x2011;123] Use CamelCase for contract and library names
According to the Solidity [style guide](https://docs.soliditylang.org/en/latest/style-guide.html#contract-and-library-names) contracts and library names should be in `CapWords style` (CamelCase).


<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

4: contract StrategyGMXGM { 
```



---
### [NC&#x2011;124] Use delete instead of assigning values to `false`
The `delete` keyword more closely matches the semantics of what is being done, and draws more attention to the changing of state, which may lead to a more thorough audit of its associated logic.

<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

159:         entered = false; 
```


```solidity
📁 File: StrategyCamelotV3.sol

82:         entered = false; 
```


```solidity
📁 File: StrategyGMXGM.sol

86:         entered = false; 
```


```solidity
📁 File: StrategySushiswap.sol

44:         entered = false; 
```


</details>


---
### [NC&#x2011;125] Use `string.concat()` on strings instead of `abi.encodePacked()` for clearer semantic meaning
Starting with version 0.8.12, Solidity has the `string.concat()` function, which allows one to concatenate a list of strings, without extra padding. Using this function rather than `abi.encodePacked()` makes the intended operation more clear, leading to less reviewer confusion.

<details>
<summary><i>There are 12 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

275:             abi.encodePacked( 

279:                         abi.encodePacked( 

295:             abi.encodePacked( 

313:             abi.encodePacked( 

329:             abi.encodePacked( 

349:             abi.encodePacked( 

364:             abi.encodePacked( 

379:             sr = abi.encodePacked("0", sr); 

381:         return string(abi.encodePacked(Strings.toString(n / x), ".", sr)); 
```


```solidity
📁 File: StrategyCamelotV3.sol

71:         name = string(abi.encodePacked("Camelot V3 ", hypervisor.token0().symbol(), "/", hypervisor.token1().symbol())); 
```


```solidity
📁 File: StrategyGMXGM.sol

74:             abi.encodePacked( 
```


```solidity
📁 File: StrategySushiswap.sol

37:             string(abi.encodePacked("SushiSwap ", IERC20(pool.token0()).symbol(), "/", IERC20(pool.token1()).symbol())); 
```


</details>


---
### [NC&#x2011;126] Use UPPER_CASE for `constant`
Constants should be in CONSTANT_CASE as stated [Solidity style guide](https://docs.soliditylang.org/en/latest/style-guide.html#constants).


<i>There are 2 instaces of this issue:</i>

```solidity
📁 File: PositionManager.sol

65:     string public constant name = "Rodeo V2 Position"; 
66:     string public constant symbol = "RP2";
```



---
### [NC&#x2011;127] Use UPPER_CASE for `immutable`
Immutables should be in uppercase as stated [Solidity style guide](https://docs.soliditylang.org/en/latest/style-guide.html#constants).

<details>
<summary><i>There are 9 instances of this issue:</i></summary>

```solidity
📁 File: StrategyCamelotV3.sol

17:     IXGrail public immutable xgrail; 
18:     IStrategyHelperUniswapV3 public immutable strategyHelperUniswapV3;
19:     IUniProxy public immutable uniProxy;
20:     IQuoter public immutable quoter;
21:     IHypervisor public immutable hypervisor;
```


```solidity
📁 File: StrategyGMXGM.sol

20:     address public immutable dataStore; 
21:     address public immutable market;
22:     address public immutable tokenLong; // Volatile
23:     address public immutable tokenShort; // Stable
```


</details>


---
### [NC&#x2011;128] `variable`/`struct`/`contract` names should be descriptive rather than cryptic
<details>
<summary><i>There are 97 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @note Confidence: 100.00%
/// @audit s
37:         (bool s,) = to.call{value: amount}(""); 
```


```solidity
📁 File: Helper.sol

/// @note Confidence: 100.00%
64:             address a = assets[0]; 
```


```solidity
📁 File: Investor.sol

/// @note Confidence: 100.00%
220:         Strategy memory s = getStrategy(index); 

/// @note Confidence: 100.00%
228:         Strategy memory s = getStrategy(index); 

/// @note Confidence: 100.00%
234:         Strategy memory s = getStrategy(index); 

/// @note Confidence: 66.67%
240:         uint256 cap = store.getUint(keccak256(abi.encode(token, COLLATERAL_CAP))); 

/// @note Confidence: 100.00%
261:         Strategy memory s = getStrategy(strategy); 
/// @note Confidence: 100.00%
262:         IStrategy si = IStrategy(s.implementation);

/// @note Confidence: 100.00%
270:         Position memory p; 

/// @note Confidence: 100.00%
300:         Position memory p = getPosition(id); 
/// @note Confidence: 100.00%
301:         Strategy memory s = getStrategy(p.strategy); 
/// @note Confidence: 100.00%
302:         IStrategy si = IStrategy(s.implementation);

/// @note Confidence: 66.67%
373:             uint256 amt = uint256(-collateral); 

/// @note Confidence: 100.00%
390:         Position memory p = getPosition(id); 

/// @note Confidence: 100.00%
399:         Position memory p = getPosition(id); 
/// @note Confidence: 100.00%
400:         Strategy memory s = getStrategy(p.strategy); 

/// @note Confidence: 100.00%
447:         Position memory p = getPosition(id); 

/// @note Confidence: 100.00%
453:         IStrategy s = IStrategy(store.getAddress(keccak256(abi.encode(p.strategy, STRATEGIES_ADDRESS)))); 
```


```solidity
📁 File: PositionManager.sol

/// @note Confidence: 66.67%
86:     struct Ids { 
87:         uint256[] values;
88:         mapping(uint256 => uint256) positions;
89:     }

/// @note Confidence: 100.00%
234:         IInvestor.Position memory p = investor.getPosition(id); 

/// @note Confidence: 100.00%
245:         IInvestor.Position memory p = investor.getPosition(id); 

/// @note Confidence: 66.67%
268:         uint256 bal = asset.balanceOf(address(this)); 

/// @note Confidence: 100.00%
310:         IInvestor.Position memory p = investor.getPosition(id); 
/// @note Confidence: 100.00%
311:         IInvestor.Strategy memory s = investor.getStrategy(p.strategy);

/// @note Confidence: 100.00%
324:         IInvestor.Position memory p = investor.getPosition(id); 
/// @note Confidence: 100.00%
325:         IInvestor.Strategy memory s = investor.getStrategy(p.strategy);

/// @note Confidence: 66.67%
327:         uint256 len = bytes(str).length + 7; 

/// @note Confidence: 100.00%
340:         IInvestor.Position memory p = investor.getPosition(id); 

/// @note Confidence: 66.67%
343:         uint256 amt = ( 
344:             (p.borrow * IPool(pool).getUpdatedIndex() / 1e18) * 1e18 / (10 ** IERC20(IPool(pool).asset()).decimals())
345:         ) * uint256(oracle.latestAnswer()) / (10 ** oracle.decimals());

/// @note Confidence: 66.67%
347:         uint256 len = bytes(str).length + 8; 

/// @note Confidence: 66.67%
360:         uint256 amt = investor.life(id); 

/// @note Confidence: 66.67%
362:         uint256 len = bytes(str).length + 6; 

/// @note Confidence: 100.00%
375:         uint256 x = 10 ** d; 
/// @note Confidence: 100.00%
376:         uint256 r = n / (10 ** (d - f)) % (10 ** f);
/// @note Confidence: 100.00%
377:         bytes memory sr = bytes(Strings.toString(r));
```


```solidity
📁 File: Store.sol

/// @note Confidence: 100.00%
141:         Bytes32Set storage s = bytes32Sets[key]; 

/// @note Confidence: 100.00%
148:         Bytes32Set storage s = bytes32Sets[key]; 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @note Confidence: 66.67%
144:         uint256 slp = slippage; 
/// @note Confidence: 66.67%
145:         uint256 tma = totalManagedAssets();

/// @note Confidence: 66.67%
150:         uint256 liq; 

/// @note Confidence: 66.67%
154:             address hyp = address(hypervisor); 

/// @note Confidence: 66.67%
161:         uint256 val = valueLiquidity() * liq / totalManagedAssets(); 

/// @note Confidence: 66.67%
171:         uint256 tma = totalManagedAssets(); 
/// @note Confidence: 66.67%
172:         uint256 amt = (shares * tma) / totalShares;
/// @note Confidence: 66.67%
173:         uint256 val = valueLiquidity() * amt / tma;

/// @note Confidence: 66.67%
181:         uint256 bal; 
/// @note Confidence: 66.67%
182:         uint256 slp = slippage;

/// @note Confidence: 66.67%
233:         uint256 slp = slippage; 

/// @note Confidence: 66.67%
264:         uint256 amt = IERC20(tgtAsset).balanceOf(address(this)); 

/// @note Confidence: 100.00%
267:         address h = address(hypervisor); 

/// @note Confidence: 66.67%
/// @audit end
312:         (uint256 start, uint256 end) = 
313:             uniProxy.getDepositAmount(address(hypervisor), address(hypervisor.token0()), out0);

/// @note Confidence: 66.67%
361:         uint256 bal = totalManagedAssets(); 
/// @note Confidence: 66.67%
362:         uint256 spl = hypervisor.totalSupply();

/// @note Confidence: 66.67%
377:         bytes32 key; 

/// @note Confidence: 66.67%
/// @audit liq
382:         (uint128 liq,,,, uint128 owed0, uint128 owed1) = IAlgebraPool(address(hypervisor.pool())).positions(key); 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @note Confidence: 66.67%
144:         uint256 slp = slippage; 
/// @note Confidence: 66.67%
145:         uint256 tot = totalShares;
/// @note Confidence: 66.67%
146:         uint256 tma = rate(tot);

/// @note Confidence: 66.67%
150:         uint256 bal = strategyHelper.swap(address(asset), tokenShort, amount, slp, address(this)); 
/// @note Confidence: 66.67%
151:         uint256 val = strategyHelper.value(tokenShort, bal);

/// @note Confidence: 66.67%
160:         uint256 slp = slippage; 
/// @note Confidence: 66.67%
161:         uint256 val = rate(shares);
/// @note Confidence: 66.67%
162:         uint256 amt = (val * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort);

/// @note Confidence: 66.67%
164:         uint256 bal = strategyHelper.swap(tokenShort, address(asset), amt, slp, msg.sender); 

/// @note Confidence: 66.67%
192:         uint256 slp = slippage; 
/// @note Confidence: 66.67%
193:         uint256 bal = IERC20(tokenLong).balanceOf(address(this));

/// @note Confidence: 66.67%
204:             uint256 amt = (have - need) * bal / have; 
/// @note Confidence: 66.67%
205:             uint256 haf = amt / 2;

/// @note Confidence: 66.67%
207:             uint256 out = strategyHelper.swap(tokenShort, tokenLong, haf, slp, address(this)); 

/// @note Confidence: 66.67%
242:             uint256 amt = (need - have) * 1e18 / marketTokenPrice(true); 

/// @note Confidence: 66.67%
295:         uint256 val = strategyHelper.value(tokenLong, IERC20(tokenLong).balanceOf(address(this))); 

/// @note Confidence: 66.67%
298:         uint256 bal = IERC20(market).balanceOf(address(this)) + amountPendingDeposit + amountPendingWithdraw; 

/// @note Confidence: 100.00%
305:         IReader r = reader; 

/// @note Confidence: 66.67%
348:         uint256 bal = IERC20(tokenLong).balanceOf(address(this)); 
```


```solidity
📁 File: StrategySushiswap.sol

/// @note Confidence: 66.67%
75:         uint256 tot = pair.totalSupply(); 
/// @note Confidence: 66.67%
76:         uint256 amt = totalManagedAssets();

/// @note Confidence: 100.00%
/// @audit r0
/// @note Confidence: 100.00%
/// @audit r1
80:             (uint112 r0, uint112 r1,) = pair.getReserves(); 

/// @note Confidence: 66.67%
86:         uint256 val = 2 * ((sqrt(reserve0 * reserve1) * sqrt(price0 * price1)) / tot); 

/// @note Confidence: 66.67%
95:         uint256 slp = slippage; 
/// @note Confidence: 66.67%
96:         uint256 tma = totalManagedAssets();

/// @note Confidence: 66.67%
98:             uint256 haf = amount / 2; 

/// @note Confidence: 66.67%
107:         uint256 liq = IERC20(address(pair)).balanceOf(address(this)); 

/// @note Confidence: 66.67%
119:         uint256 slp = slippage; 

/// @note Confidence: 66.67%
121:             uint256 tma = totalManagedAssets(); 
/// @note Confidence: 66.67%
122:             uint256 amt = shares * tma / totalShares;

/// @note Confidence: 66.67%
158:         IERC20 rew = IERC20(rewarder.SUSHI()); 

/// @note Confidence: 66.67%
160:         uint256 amt = rew.balanceOf(address(this)); 
/// @note Confidence: 66.67%
161:         uint256 haf = amt / 2;

/// @note Confidence: 66.67%
170:         uint256 liq = IERC20(address(pair)).balanceOf(address(this)); 

/// @note Confidence: 66.67%
/// @audit amt
178:         (uint256 amt,) = rewarder.userInfo(poolId, address(this)); 

/// @note Confidence: 100.00%
189:         IERC20 lp = IERC20(address(pool)); 
/// @note Confidence: 66.67%
190:         uint256 bal = lp.balanceOf(address(this));
```


```solidity
📁 File: UtilFarmingBalances.sol

/// @note Confidence: 100.00%
16:         IPositionManager pm = IPositionManager(0x5e4d7F61cC608485A2E4F105713D26D58a9D0cF6); 
/// @note Confidence: 66.67%
17:         uint256 max = i.nextPosition();

/// @note Confidence: 100.00%
/// @audit ok
22:             (bool ok, bytes memory data) = address(pm).staticcall(abi.encodeWithSelector(IPositionManager.ownerOf.selector, y)); 
```


```solidity
📁 File: Whitelist.sol

/// @note Confidence: 100.00%
35:         uint256 l = addresses.length; 
```


</details>


---
### [NC&#x2011;129] Variables need not be initialized to zero
The default value for variables is zero, so initializing them to zero is superfluous.

<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: StrategySushiswap.sol

217:         uint256 result = 0; 
```


```solidity
📁 File: Whitelist.sol

36:         for (uint256 i = 0; i < l; i++) { 
```


</details>


---
### [NC&#x2011;130] Variables should be named in mixedCase style
As the [Solidity Style Guide](https://docs.soliditylang.org/en/latest/style-guide.html#naming-styles) suggests: arguments, local variables and mutable state variables should be named in mixedCase style.

Rule exceptions
- Allow constant variable name/symbol/decimals to be lowercase (ERC20).
- Allow `_` at the beginning of the mixedCase match for `private variables` and `unused parameters`.

<details>
<summary><i>There are 33 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @audit _investor
/// @audit _asset
/// @audit _lender
/// @audit _sh
36:     constructor(address _investor, address _asset, address _lender, address _sh) { 

/// @audit _fromAsset
76:     function swap(address _fromAsset) internal { 
```


```solidity
📁 File: Investor.sol

/// @audit _store
/// @audit _helper
144:     constructor(address _store, address _helper) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit _asset
24:     constructor(address _asset) { 
```


```solidity
📁 File: PositionManager.sol

/// @audit _investor
91:     constructor(address _investor) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit _asset
49:         address _asset, 
/// @audit _strategyHelper
50:         address _strategyHelper,
/// @audit _xgrail
51:         address _xgrail,
/// @audit _strategyHelperUniswapV3
52:         address _strategyHelperUniswapV3,
/// @audit _uniProxy
53:         address _uniProxy,
/// @audit _quoter
54:         address _quoter,
/// @audit _hypervisor
55:         address _hypervisor,
/// @audit _nftPool
56:         address _nftPool,
/// @audit _targetAsset
57:         address _targetAsset,
/// @audit _pathToLp
58:         bytes memory _pathToLp

/// @audit _nitroPool
123:     function setNitroPool(address _nitroPool) external auth { 

/// @audit _tokenId
390:     function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external returns (bytes4) { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit _asset
49:         address _asset, 
/// @audit _strategyHelper
50:         address _strategyHelper,
/// @audit _exchangeRouter
51:         address _exchangeRouter,
/// @audit _reader
52:         address _reader,
/// @audit _depositHandler
53:         address _depositHandler,
/// @audit _withdrawalHandler
54:         address _withdrawalHandler,
/// @audit _dataStore
55:         address _dataStore,
/// @audit _market
56:         address _market
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit _asset
/// @audit _strategyHelper
/// @audit _rewarder
/// @audit _poolId
29:     constructor(address _asset, address _strategyHelper, address _rewarder, uint256 _poolId) { 
```


</details>


---
### [NC&#x2011;131] Zero as a function argument should have a descriptive meaning
Consider using descriptive constants or an enum instead of passing zero directly on function calls, as that might be error-prone, to fully describe the caller's intention.

<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

45:         lender.flashLoanSimple(address(this), address(asset), repay, abi.encodePacked(id), 0); 
```


```solidity
📁 File: Investor.sol

216:         emit StrategyUpdate(index, implementation, 4, 0); 
```


```solidity
📁 File: PositionManager.sol

379:             sr = abi.encodePacked("0", sr); 
```


```solidity
📁 File: StrategyCamelotV3.sol

214:             nftPool.createPosition(amount, 0); 
```


```solidity
📁 File: StrategyGMXGM.sol

219:                 longTokenSwapPath: new address[](0), 

261:                 longTokenSwapPath: new address[](0), 
```


</details>


## Gas


---
### [GAS&#x2011;1] `++i` costs less gas than `i++`/`i += 1` (same for `--i` vs `i--`/`i -+ 1`)

Gas saved per Instance: ~6 *(Total: ~48)*
<details>
<summary><i>There are 8 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

129:         for (uint256 i = start; i < end; i++) { 

157:             unchecked { _balanceOf[from]--; } 

171:             unchecked { _balanceOf[to]++; } 

378:         for (uint256 i = sr.length; i < f; i++) { 
```


```solidity
📁 File: Store.sol

136:         for (uint256 i = start; i < end; i++) { 
```


```solidity
📁 File: StrategySushiswap.sol

247:             if (value >> 1 > 0) result += 1; 
```


```solidity
📁 File: UtilFarmingBalances.sol

20:         for (uint256 y = start; y < max; y++) { 
```


```solidity
📁 File: Whitelist.sol

36:         for (uint256 i = 0; i < l; i++) { 
```


</details>


---
### [GAS&#x2011;2] `++i`/`i++` should be `unchecked` when it is not possible for them to overflow
The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**


Gas saved per Instance: ~60 *(Total: ~240)*
<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

129:         for (uint256 i = start; i < end; i++) { 

378:         for (uint256 i = sr.length; i < f; i++) { 
```


```solidity
📁 File: Store.sol

136:         for (uint256 i = start; i < end; i++) { 
```


```solidity
📁 File: Whitelist.sol

36:         for (uint256 i = 0; i < l; i++) { 
```


</details>


---
### [GAS&#x2011;3] `--i` costs less gas than `i--`

Gas saved per Instance: ~5 

<i>There is one instance of this issue:</i>

```solidity
📁 File: PositionManager.sol

157:             unchecked { _balanceOf[from]--; } 
```



---
### [GAS&#x2011;4] `>=`/`<=` costs less gas than `>`/`<`
The compiler uses opcodes `GT` and `ISZERO` for code that uses `>`, but only requires `LT` for `>=`. A similar behaviour applies for `>`, which uses opcodes `LT` and `ISZERO`, but only requires `GT` for `<=`.


Gas saved per Instance: ~3 *(Total: ~228)*
<details>
<summary><i>There are 76 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

190:             if (data > 1e18) revert InvalidFile(); 

193:             if (data > 5000) revert InvalidFile(); 

196:             if (data > 1e18) revert InvalidFile(); 

199:             if (data > 1e18) revert InvalidFile(); 

202:             if (data == 0 || data > 4) revert InvalidFile(); 

263:         if (store.getUint(STATUS) < STATUS_LIVE || s.status < STATUS_LIVE) revert WrongStatus(); 

266:         if (IERC20(token).balanceOf(store.getAddress(BANK)) + collateral > collateralCap) { 

288:         if (_life(p) < 1e18) revert Undercollateralized(); 
289:         if (si.rate(si.totalShares()) > s.cap) revert StrategyOverCap();

304:         if (borrow < 0 && uint256(-borrow) > p.shares) revert InvalidParameters(); 
305:         if (borrow > 0 && p.shares == 0) revert InvalidParameters();
306:         if (collateral < 0 && uint256(-collateral) > p.collateral) revert InvalidParameters();

311:             if (borrow > 0 && (status < STATUS_LIVE || s.status < STATUS_LIVE)) { 

314:             if (borrow <= 0 && (status < STATUS_WITHDRAW || s.status < STATUS_WITHDRAW)) { 

320:         if (collateral > 0) { 

324:             if (IERC20(p.token).balanceOf(store.getAddress(BANK)) > collateralCap) { 

330:         if (borrow < 0) { 

336:             if (repaying > p.borrow) repaying = p.borrow; 

342:                 if (needed > amount) { 

346:                     if (cAmount > p.collateral) cAmount = p.collateral; 

361:         if (borrow > 0) { 

372:         if (collateral < 0) { 

376:             if (amt > p.collateral) amt = p.collateral; 

382:         if (_life(p) < 1e18) revert Undercollateralized(); 
383:         if (borrow > 0 && si.rate(si.totalShares()) > s.cap) revert StrategyOverCap();

403:         if (store.getUint(STATUS) < STATUS_LIQUIDATE || s.status < STATUS_LIQUIDATE) revert WrongStatus(); 

420:             if (amount < target) { 

424:                 if (collat > p.collateral) collat = p.collateral; 

432:             if (shares > p.shares) shares = p.shares; 

514:         return a < b ? a : b; 
```


```solidity
📁 File: PositionManager.sol

129:         for (uint256 i = start; i < end; i++) { 

235:         if (collateral > 0) { 

269:         if (bal > 0 && !asset.transfer(usr, bal)) revert TransferFailed(); 

378:         for (uint256 i = sr.length; i < f; i++) { 
```


```solidity
📁 File: Store.sol

54:         if (value > 0 && next < prev) revert OverOrUnderflow(); 
55:         if (value < 0 && next > prev) revert OverOrUnderflow();

136:         for (uint256 i = start; i < end; i++) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

111:             if (data > uint256(int256(type(int32).max))) revert TwapPeriodTooLong(); 

162:         if (val < strategyHelper.value(address(asset), amount) * (10000 - slp) / 10000) revert PriceSlipped(); 

186:         if (strategyHelper.value(address(asset), bal) < val * (10000 - slp) / 10000) revert PriceSlipped(); 

208:         if (tokenId != 0 && totalManagedAssets() > 0) { 

242:             if (strategyHelper.value(rewardToken1, balance) > 1e18) { 

250:             if (strategyHelper.value(rewardToken2, balance) > 1e18) { 

258:             if (strategyHelper.value(rewardToken3, balance) > 1e18) { 

265:         if (strategyHelper.value(tgtAsset, amt) < 1e18) return; 

305:         if (path0.length > 0) { 

308:         if (path1.length > 0) { 

410:         return a < b ? a : b; 
```


```solidity
📁 File: StrategyGMXGM.sol

121:             if (data > 10000) revert WrongReserveRatio(); 

194:         if (bal > 0) { 

203:         if (have > need) { 

241:         } else if (have < need) { 

319:         return price < 0 ? 0 : uint256(price) / 1e12; 

359:         return a < b ? a : b; 
```


```solidity
📁 File: StrategySushiswap.sol

162:         if (strategyHelper.value(address(rew), amt) < 0.5e18) return; 

197:         return a < b ? a : b; 

219:             if (value >> 128 > 0) { 

223:             if (value >> 64 > 0) { 

227:             if (value >> 32 > 0) { 

231:             if (value >> 16 > 0) { 

235:             if (value >> 8 > 0) { 

239:             if (value >> 4 > 0) { 

243:             if (value >> 2 > 0) { 

247:             if (value >> 1 > 0) result += 1; 
```


```solidity
📁 File: UtilFarmingBalances.sol

20:         for (uint256 y = start; y < max; y++) { 
```


```solidity
📁 File: Whitelist.sol

36:         for (uint256 i = 0; i < l; i++) { 
```


</details>


---
### [GAS&#x2011;5] `abi.encode()` is less efficient than `abi.encodePacked()` for non-address arguments
See for more information: https://github.com/ConnorBlockchain/Solidity-Encode-Gas-Comparison

<details>
<summary><i>There are 45 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

82:     bytes32 constant STATUS = keccak256(abi.encode("STATUS")); 
83:     bytes32 constant BANK = keccak256(abi.encode("BANK"));
84:     bytes32 constant POOL = keccak256(abi.encode("POOL"));
85:     bytes32 constant STRATEGIES_ADDRESS = keccak256(abi.encode("STRATEGIES_ADDRESS"));
86:     bytes32 constant STRATEGIES_CAP = keccak256(abi.encode("STRATEGIES_CAP"));
87:     bytes32 constant STRATEGIES_STATUS = keccak256(abi.encode("STRATEGIES_STATUS"));
88:     bytes32 constant COLLATERAL_FACTOR = keccak256(abi.encode("COLLATERAL_FACTOR"));
89:     bytes32 constant COLLATERAL_CAP = keccak256(abi.encode("COLLATERAL_CAP"));
90:     bytes32 constant POSITIONS = keccak256(abi.encode("POSITIONS"));
91:     bytes32 constant POSITIONS_OWNER = keccak256(abi.encode("POSITIONS_OWNER"));
92:     bytes32 constant POSITIONS_START = keccak256(abi.encode("POSITIONS_START"));
93:     bytes32 constant POSITIONS_STRATEGY = keccak256(abi.encode("POSITIONS_STRATEGY"));
94:     bytes32 constant POSITIONS_TOKEN = keccak256(abi.encode("POSITIONS_TOKEN"));
95:     bytes32 constant POSITIONS_COLLATERAL = keccak256(abi.encode("POSITIONS_COLLATERAL"));
96:     bytes32 constant POSITIONS_BASIS = keccak256(abi.encode("POSITIONS_BASIS"));
97:     bytes32 constant POSITIONS_SHARES = keccak256(abi.encode("POSITIONS_SHARES"));
98:     bytes32 constant POSITIONS_BORROW = keccak256(abi.encode("POSITIONS_BORROW"));

211:         if (store.getAddress(keccak256(abi.encode(index, STRATEGIES_ADDRESS))) != address(0)) { 

214:         store.setAddress(keccak256(abi.encode(index, STRATEGIES_ADDRESS)), implementation); 
215:         store.setUint(keccak256(abi.encode(index, STRATEGIES_STATUS)), 4);

223:         store.setAddress(keccak256(abi.encode(index, STRATEGIES_ADDRESS)), implementation); 

229:         store.setUint(keccak256(abi.encode(index, STRATEGIES_STATUS)), status); 

235:         store.setUint(keccak256(abi.encode(index, STRATEGIES_CAP)), cap); 

453:         IStrategy s = IStrategy(store.getAddress(keccak256(abi.encode(p.strategy, STRATEGIES_ADDRESS)))); 

467:         p.owner = store.getAddress(keccak256(abi.encode(id, POSITIONS_OWNER))); 
468:         p.start = store.getUint(keccak256(abi.encode(id, POSITIONS_START)));
469:         p.strategy = store.getUint(keccak256(abi.encode(id, POSITIONS_STRATEGY)));
470:         p.token = store.getAddress(keccak256(abi.encode(id, POSITIONS_TOKEN)));
471:         p.collateral = store.getUint(keccak256(abi.encode(id, POSITIONS_COLLATERAL)));
472:         p.borrow = store.getUint(keccak256(abi.encode(id, POSITIONS_BORROW)));
473:         p.shares = store.getUint(keccak256(abi.encode(id, POSITIONS_SHARES)));
474:         p.basis = store.getUint(keccak256(abi.encode(id, POSITIONS_BASIS)));

478:         store.setAddress(keccak256(abi.encode(id, POSITIONS_OWNER)), p.owner); 
479:         store.setUint(keccak256(abi.encode(id, POSITIONS_START)), p.start);
480:         store.setUint(keccak256(abi.encode(id, POSITIONS_STRATEGY)), p.strategy);
481:         store.setAddress(keccak256(abi.encode(id, POSITIONS_TOKEN)), p.token);
482:         store.setUint(keccak256(abi.encode(id, POSITIONS_COLLATERAL)), p.collateral);
483:         store.setUint(keccak256(abi.encode(id, POSITIONS_BORROW)), p.borrow);
484:         store.setUint(keccak256(abi.encode(id, POSITIONS_SHARES)), p.shares);
485:         store.setUint(keccak256(abi.encode(id, POSITIONS_BASIS)), p.basis);

489:         s.implementation = store.getAddress(keccak256(abi.encode(id, STRATEGIES_ADDRESS))); 
490:         s.cap = store.getUint(keccak256(abi.encode(id, STRATEGIES_CAP)));
491:         s.status = store.getUint(keccak256(abi.encode(id, STRATEGIES_STATUS)));
```


```solidity
📁 File: StrategyGMXGM.sol

322:     bytes32 constant MAX_PNL_FACTOR_FOR_DEPOSITS = keccak256(abi.encode("MAX_PNL_FACTOR_FOR_DEPOSITS")); 
323:     bytes32 constant MAX_PNL_FACTOR_FOR_WITHDRAWALS = keccak256(abi.encode("MAX_PNL_FACTOR_FOR_WITHDRAWALS"));
```


</details>


---
### [GAS&#x2011;6] `address(this)` should be cached when used multiple times
<details>
<summary><i>There are 11 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @audit 'address(this)' used 4 times
48:     function executeOperation( 
49:       address,
50:       uint256 amount,
51:       uint256 premium,
52:       address initiator,
53:       bytes calldata params
54:     ) external returns (bool) {
```


```solidity
📁 File: Investor.sol

/// @audit 'address(this)' used 3 times
162:     function file(bytes32 what, address data) external auth { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit 'address(this)' used 4 times
141:     function mint(uint256 amount) external auth loop returns (uint256) { 

/// @audit 'address(this)' used 8 times
228:     function earn() external payable loop { 

/// @audit 'address(this)' used 4 times
320:     function quoteAndSwap(address trgtAst, uint256 amt, uint256 slp) private returns (uint256 amt0, uint256 amt1) { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit 'address(this)' used 8 times
184:     function earn() external payable loop { 

/// @audit 'address(this)' used 3 times
283:     function exit(address strategy) external auth { 

/// @audit 'address(this)' used 3 times
294:     function rate(uint256 shares) public view returns (uint256) { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit 'address(this)' used 9 times
90:     function mint(uint256 amount) public auth loop returns (uint256) {  

/// @audit 'address(this)' used 3 times
117:     function burn(uint256 shares) public auth loop returns (uint256) { 

/// @audit 'address(this)' used 10 times
153:     function earn() public payable loop { 
```


</details>


---
### [GAS&#x2011;7] Assigning state variables directly with named struct constructors wastes gas
Using named arguments for struct means that the compiler needs to organize the fields in memory before doing the assignment, which wastes gas. Set each field directly in storage (use dot-notation), or use the unnamed version of the constructor.


Gas saved per Instance: ~28 *(Total: ~56)*

<i>There are 2 instaces of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

212:             IExchangeRouter.CreateDepositParams memory params = IExchangeRouter.CreateDepositParams({ 
213:                 receiver: address(this),
214:                 callbackContract: address(this),
215:                 uiFeeReceiver: address(0),
216:                 market: market,
217:                 initialLongToken: tokenLong,
218:                 initialShortToken: tokenShort,
219:                 longTokenSwapPath: new address[](0),
220:                 shortTokenSwapPath: new address[](0),
221:                 minMarketTokens: minOut,
222:                 shouldUnwrapNativeToken: false,
223:                 executionFee: earnActionValue,
224:                 callbackGasLimit: callbackGasLimit
225:             });

256:             IExchangeRouter.CreateWithdrawalParams memory params = IExchangeRouter.CreateWithdrawalParams({ 
257:                 receiver: address(this),
258:                 callbackContract: address(this),
259:                 uiFeeReceiver: address(0),
260:                 market: market,
261:                 longTokenSwapPath: new address[](0),
262:                 shortTokenSwapPath: new address[](0),
263:                 minLongTokenAmount: longOut * (10000 - slp) / 10000,
264:                 minShortTokenAmount: shortOut * (10000 - slp) / 10000,
265:                 shouldUnwrapNativeToken: false,
266:                 executionFee: earnActionValue,
267:                 callbackGasLimit: callbackGasLimit
268:             });
```



---
### [GAS&#x2011;8] Avoid contract existence checks by using low-level calls
Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low-level calls never check for contract existence


Gas saved per Instance: ~100 *(Total: ~9,800)*
<details>
<summary><i>There are 98 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

43:         if (!IERC20(token).transfer(to, amount)) revert TransferFailed(); 
```


```solidity
📁 File: Helper.sol

65:             IERC20(a).transfer(a, IERC20(a).balanceOf(address(this))); 
66:             ISushi(a).burn(address(this));
67:             swap(ISushi(a).token0());
68:             swap(ISushi(a).token1());
```


```solidity
📁 File: Investor.sol

177:             if (!IBank(data).exec(address(this))) revert InvalidFile(); 

180:             if (!IPool(data).exec(address(this))) revert InvalidFile(); 
181:             if (IPool(data).asset() == address(0)) revert InvalidFile();

221:         IStrategy(s.implementation).exit(implementation); 
222:         IStrategy(implementation).move(s.implementation);

252:         IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))); 

266:         if (IERC20(token).balanceOf(store.getAddress(BANK)) + collateral > collateralCap) { 

324:             if (IERC20(p.token).balanceOf(store.getAddress(BANK)) > collateralCap) { 

348:                     IERC20(p.token).approve(address(helper), cAmount); 

354:             IERC20(poolAsset).approve(address(pool), amount); 

410:         IERC20(poolAsset).transferFrom(msg.sender, address(this), borrow + fee); 
411:         IERC20(poolAsset).approve(address(pool), borrow);

414:         uint256 amount = IStrategy(s.implementation).rate(p.shares); 

461:         uint256 scaled = (p.borrow * 1e18) / (10 ** IERC20(pool.asset()).decimals()); 

501:         if (!IERC20(asset).transfer(user, amount)) { 

508:         if (!IERC20(asset).transferFrom(user, store.getAddress(BANK), amount)) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

45:         return IStrategy(strategy).mint(amount); 

49:         uint256 amount = IStrategy(strategy).burn(shares); 

55:         return IStrategy(strategy).kill(shares, target); 
```


```solidity
📁 File: PositionManager.sol

192:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") 

202:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) 

226:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") 

241:         push(IPool(investor.getPool()).asset(), msg.sender); 

259:         if (!IERC20(ast).approve(address(investor), amt)) revert TransferFailed(); 

263:         if (!IERC20(ast).transferFrom(usr, address(this), amt)) revert TransferFailed(); 

317:                 IStrategy(s.implementation).name(), 

326:         string memory str = formatNumber(IStrategy(s.implementation).rate(p.shares), 18, 2); 

342:         IOracle oracle = IOracle(IPool(pool).oracle()); 

344:             (p.borrow * IPool(pool).getUpdatedIndex() / 1e18) * 1e18 / (10 ** IERC20(IPool(pool).asset()).decimals()) 
```


```solidity
📁 File: StrategyCamelotV3.sol

152:             uint256 tgtAmt = IERC20(tgtAst).balanceOf(address(this)); 

207:         IERC20(address(hypervisor)).approve(address(nftPool), amount); 

241:             uint256 balance = IERC20(rewardToken1).balanceOf(address(this)); 

243:                 IERC20(rewardToken1).approve(address(strategyHelper), balance); 

249:             uint256 balance = IERC20(rewardToken2).balanceOf(address(this)); 

251:                 IERC20(rewardToken2).approve(address(strategyHelper), balance); 

257:             uint256 balance = IERC20(rewardToken3).balanceOf(address(this)); 

259:                 IERC20(rewardToken3).approve(address(strategyHelper), balance); 

264:         uint256 amt = IERC20(tgtAsset).balanceOf(address(this)); 

268:         IHypervisor(h).token0().approve(h, amt0); 
269:         IHypervisor(h).token1().approve(h, amt1);

285:         nftPool = StrategyCamelotV3(old).nftPool(); 
286:         nitroPool = StrategyCamelotV3(old).nitroPool();
287:         tokenId = StrategyCamelotV3(old).tokenId();

340:         IERC20(trgtAst).transfer(address(strategyHelperUniswapV3), toLp); 

382:         (uint128 liq,,,, uint128 owed0, uint128 owed1) = IAlgebraPool(address(hypervisor.pool())).positions(key); 
```


```solidity
📁 File: StrategyGMXGM.sol

65:         depositVault = IHandler(_depositHandler).depositVault(); 
66:         withdrawalVault = IHandler(_withdrawalHandler).withdrawalVault();

75:                 "GMX GM ", IERC20(marketInfo.longToken).symbol(), "/", IERC20(marketInfo.shortToken).symbol() 

105:             depositVault = IHandler(data).depositVault(); 

108:             withdrawalVault = IHandler(data).withdrawalVault(); 

140:       IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))); 

162:         uint256 amt = (val * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort); 
163:         IERC20(tokenShort).approve(address(strategyHelper), amt);

173:         uint256 amount = (value * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort); 
174:         IERC20(tokenShort).transfer(to, amount);

193:         uint256 bal = IERC20(tokenLong).balanceOf(address(this)); 

195:             IERC20(tokenLong).approve(address(strategyHelper), bal); 

199:         bal = IERC20(tokenShort).balanceOf(address(this)); 

206:             IERC20(tokenShort).approve(address(strategyHelper), haf); 

232:             IERC20(marketInfo.longToken).approve(router, out); 
233:             IERC20(marketInfo.shortToken).approve(router, amt - haf);

272:             IERC20(market).approve(exchangeRouter.router(), amt); 

287:         IERC20(market).transfer(strategy, IERC20(market).balanceOf(address(this))); 
288:         IERC20(tokenLong).transfer(strategy, IERC20(tokenLong).balanceOf(address(this)));
289:         IERC20(tokenShort).transfer(strategy, IERC20(tokenShort).balanceOf(address(this)));

295:         uint256 val = strategyHelper.value(tokenLong, IERC20(tokenLong).balanceOf(address(this))); 
296:         val += strategyHelper.value(tokenShort, IERC20(tokenShort).balanceOf(address(this)));

298:         uint256 bal = IERC20(market).balanceOf(address(this)) + amountPendingDeposit + amountPendingWithdraw; 

328:             decimals = IERC20(token).decimals(); 

348:         uint256 bal = IERC20(tokenLong).balanceOf(address(this)); 
349:         IERC20(tokenLong).approve(address(strategyHelper), bal);
```


```solidity
📁 File: StrategySushiswap.sol

37:             string(abi.encodePacked("SushiSwap ", IERC20(pool.token0()).symbol(), "/", IERC20(pool.token1()).symbol())); 

81:             reserve0 = uint256(r0) * 1e18 / (10 ** IERC20(pair.token0()).decimals()); 
82:             reserve1 = uint256(r1) * 1e18 / (10 ** IERC20(pair.token1()).decimals());

107:         uint256 liq = IERC20(address(pair)).balanceOf(address(this)); 
108:         IERC20(address(pair)).approve(address(rewarder), liq);

166:         IERC20(pair.token0()).transfer(address(pair), IERC20(pair.token0()).balanceOf(address(this))); 
167:         IERC20(pair.token1()).transfer(address(pair), IERC20(pair.token1()).balanceOf(address(this)));

170:         uint256 liq = IERC20(address(pair)).balanceOf(address(this)); 
171:         IERC20(address(pair)).approve(address(rewarder), liq);

188:         totalShares = StrategySushiswap(old).totalShares(); 
```


</details>


---
### [GAS&#x2011;9] Avoid fetching a low-level call's return data by using assembly
Even if you don't assign the call's second return value, it still gets copied to memory. Use assembly instead to prevent this and save 159 [gas](https://gist.github.com/IllIllI000/0e18a40f3afb0b83f9a347b10ee89ad2):


Gas saved per Instance: ~159 *(Total: ~477)*
<details>
<summary><i>There are 3 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

37:         (bool s,) = to.call{value: amount}(""); 
```


```solidity
📁 File: InvestorStrategyProxy.sol

59:         (bool success,) = strategy.call{value: value}(data); 
```


```solidity
📁 File: StrategyGMXGM.sol

134:         (bool success,) = address(msg.sender).call{value: address(this).balance}(""); 
```


</details>


---
### [GAS&#x2011;10] Avoid unnecessary `public` variables
Public state variables in Solidity automatically generate getter functions, increasing contract size and potentially leading to higher deployment and interaction costs. To optimize gas usage and contract efficiency, minimize the use of public variables unless external access is necessary. Instead, use internal or private visibility combined with explicit getter functions when required. This practice not only reduces contract size but also provides better control over data access and manipulation, enhancing security and readability. Prioritize lean, efficient contracts to ensure cost-effectiveness and better performance on the blockchain.


Gas saved per Instance: ~22,000 *(Total: ~1,342,000)*
<details>
<summary><i>There are 61 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

30:     IInvestor public investor; 
31:     IERC20 public asset;
32:     IAavePool public lender; // 0x794a61358D6845594F94dc1DB02A252b5b4814aD
33:     IStrategyHelper public sh;
34:     uint256 public slippage = 2500;
```


```solidity
📁 File: Investor.sol

66:     IStore public store; 
67:     IHelper public helper;
68:     IWhitelist public whitelist;
69:     IStrategyProxy public strategyProxy;
70:     uint256 public slippage = 200;
71:     uint256 public performanceFee = 2000;
72:     uint256 public killCollateralPadding = 500;
73:     uint256 public closeCollateralPadding = 400;
```


```solidity
📁 File: InvestorStrategyProxy.sol

16:     IERC20 public asset; 
```


```solidity
📁 File: PositionManager.sol

67:     IInvestor public investor; 
68:     IWhitelist public whitelist;
```


```solidity
📁 File: StrategyCamelotV3.sol

8:     string public name; 
9:     uint256 public totalShares = 1_000_000;
10:     uint256 public slippage = 500;

12:     IERC20 public asset; 
13:     IStrategyHelper public strategyHelper;

17:     IXGrail public immutable xgrail; 
18:     IStrategyHelperUniswapV3 public immutable strategyHelperUniswapV3;
19:     IUniProxy public immutable uniProxy;
20:     IQuoter public immutable quoter;
21:     IHypervisor public immutable hypervisor;
22:     bytes public pathToLp; // UniV3 path from targetAsset to other asset
23:     address public targetAsset;

25:     INitroPool public nitroPool; 

27:     uint32 public twapPeriod = 43200; 
28:     address public rewardToken1;
29:     address public rewardToken2;
30:     address public rewardToken3;
```


```solidity
📁 File: StrategyGMXGM.sol

5:     string public name; 
6:     uint256 public totalShares = 1_000_000;
7:     uint256 public slippage = 500;

9:     IERC20 public asset; 
10:     IStrategyHelper public strategyHelper;

14:     IExchangeRouter public exchangeRouter; 
15:     IReader public reader;
16:     address public depositHandler;
17:     address public withdrawalHandler;
18:     address public depositVault;
19:     address public withdrawalVault;
20:     address public immutable dataStore;
21:     address public immutable market;
22:     address public immutable tokenLong; // Volatile
23:     address public immutable tokenShort; // Stable
24:     uint256 public indexTokenDecimals; // Optional, used to set sythetic index token decimals
25:     uint256 public amountPendingDeposit;
26:     uint256 public amountPendingWithdraw;
27:     uint256 public reserveRatio = 1000; // 10%
28:     uint256 public earnActionValue = 0.0015675e18;
29:     uint256 public callbackGasLimit = 500_000;
```


```solidity
📁 File: StrategySushiswap.sol

5:     string public name; 

7:     uint256 public slippage = 500; 

9:     IERC20 public asset; 
10:     IStrategyHelper public strategyHelper;
11:     ISushiswapMiniChefV2 public rewarder;
12:     IUniswapV2Pair public pool;
13:     uint256 public poolId;
```


</details>


---
### [GAS&#x2011;11] Avoid updating storage when the value hasn't changed
If the old value is equal to the new value, not re-storing the value will avoid a Gsreset (2900 gas), potentially at the expense of a Gcoldsload (2100 gas) or a Gwarmaccess (100 gas)


Gas saved per Instance: ~1,700 *(Total: ~11,900)*
<details>
<summary><i>There are 7 instances of this issue:</i></summary>

```solidity
📁 File: StrategyCamelotV3.sol

119:     function setPathToLp(bytes calldata newPathToLp) external auth { 
120:         pathToLp = newPathToLp;
121:     }

170:     function burn(uint256 shares) external auth loop returns (uint256) { 
171:         uint256 tma = totalManagedAssets();
172:         uint256 amt = (shares * tma) / totalShares;
173:         uint256 val = valueLiquidity() * amt / tma;
174:         unstake(amt);
175:         (uint256 amt0, uint256 amt1) = hypervisor.withdraw(amt, address(this), address(this), [uint256(0), 0, 0, 0]);
176: 
177:         address strategyHelperAddress = address(strategyHelper);
178:         hypervisor.token0().approve(strategyHelperAddress, amt0);
179:         hypervisor.token1().approve(strategyHelperAddress, amt1);
180: 
181:         uint256 bal;
182:         uint256 slp = slippage;
183:         bal += strategyHelper.swap(address(hypervisor.token0()), address(asset), amt0, slp, msg.sender);
184:         bal += strategyHelper.swap(address(hypervisor.token1()), address(asset), amt1, slp, msg.sender);
185: 
186:         if (strategyHelper.value(address(asset), bal) < val * (10000 - slp) / 10000) revert PriceSlipped();
187: 
188:         totalShares -= shares;
189:         emit Burn(bal, shares);
190:         return bal;
191:     }

193:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 
194:         uint256 amount = shares * totalManagedAssets() / totalShares;
195:         unstake(amount);
196:         hypervisor.transfer(to, amount);
197: 
198:         totalShares -= shares;
199:         emit Kill(amount, shares);
200: 
201:         address[] memory assets = new address[](1);
202:         assets[0] = address(hypervisor);
203:         return abi.encode(bytes32("camelotv3"), assets);
204:     }
```


```solidity
📁 File: StrategyGMXGM.sol

159:     function burn(uint256 shares) external auth loop returns (uint256) { 
160:         uint256 slp = slippage;
161:         uint256 val = rate(shares);
162:         uint256 amt = (val * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort);
163:         IERC20(tokenShort).approve(address(strategyHelper), amt);
164:         uint256 bal = strategyHelper.swap(tokenShort, address(asset), amt, slp, msg.sender);
165: 
166:         totalShares -= shares;
167:         emit Burn(bal, shares);
168:         return bal;
169:     }

171:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 
172:         uint256 value = rate(shares);
173:         uint256 amount = (value * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort);
174:         IERC20(tokenShort).transfer(to, amount);
175: 
176:         totalShares -= shares;
177:         emit Kill(amount, shares);
178: 
179:         address[] memory assets = new address[](1);
180:         assets[0] = tokenShort;
181:         return abi.encode(bytes32("gmxgm"), assets);
182:     }
```


```solidity
📁 File: StrategySushiswap.sol

117:     function burn(uint256 shares) public auth loop returns (uint256) { 
118:         IUniswapV2Pair pair = pool;
119:         uint256 slp = slippage;
120:         {
121:             uint256 tma = totalManagedAssets();
122:             uint256 amt = shares * tma / totalShares;
123:             rewarder.withdraw(poolId, amt, address(pair));
124:             pair.burn(address(this));
125:         }
126:         IERC20 tok0 = IERC20(pair.token0());
127:         IERC20 tok1 = IERC20(pair.token1());
128:         uint256 bal0 = tok0.balanceOf(address(this));
129:         uint256 bal1 = tok1.balanceOf(address(this));
130:         tok0.approve(address(strategyHelper), bal0);
131:         tok1.approve(address(strategyHelper), bal1);
132:         uint256 amt0 = strategyHelper.swap(address(tok0), address(asset), bal0, slp, msg.sender);
133:         uint256 amt1 = strategyHelper.swap(address(tok1), address(asset), bal1, slp, msg.sender);
134:         uint256 amount =  amt0 + amt1;
135: 
136:         totalShares -= shares;
137:         emit Burn(amount, shares);
138:         return amount;
139:     }

141:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 
142:         uint256 amount = shares * totalManagedAssets() / totalShares;
143:         rewarder.withdraw(poolId, amount, to);
144: 
145:         totalShares -= shares;
146:         emit Kill(amount, shares);
147: 
148:         address[] memory assets = new address[](1);
149:         assets[0] = address(pool);
150:         return abi.encode(bytes32("sushi"), assets);
151:     }
```


</details>


---
### [GAS&#x2011;12] Avoid zero to non-zero storage writes where possible
Changing a storage variable from zero to non-zero costs **22,100 gas** in total. (20,000 gas for a zero to non-zero write and 2,100 for a cold storage access)

Consider using non-zero architecture to avoid high gas costs for zero to non-zero storage writes.


Gas saved per Instance: ~22,100 *(Total: ~773,500)*
<details>
<summary><i>There are 35 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

191:             slippage = data; 

194:             performanceFee = data; 

197:             killCollateralPadding = data; 

200:             closeCollateralPadding = data; 

431:             shares = p.shares * target / amount; 
432:             if (shares > p.shares) shares = p.shares;
```


```solidity
📁 File: StrategyCamelotV3.sol

109:             slippage = data; 

112:             twapPeriod = uint32(twapPeriod); 

165:         totalShares += shares; 

188:         totalShares -= shares; 

198:         totalShares -= shares; 

213:             if (tokenId != 0) tokenId = 0; 

287:         tokenId = StrategyCamelotV3(old).tokenId(); 

392:             tokenId = _tokenId; 
```


```solidity
📁 File: StrategyGMXGM.sol

117:             slippage = data; 

119:             indexTokenDecimals = data; 

122:             reserveRatio = data; 

124:             callbackGasLimit = data; 

126:             earnActionValue = data; 

154:         totalShares += shares; 

166:         totalShares -= shares; 

176:         totalShares -= shares; 

209:             amountPendingDeposit = minOut; 

270:             amountPendingWithdraw = amt; 

337:         amountPendingDeposit = 0; 

342:         amountPendingDeposit = 0; 

347:         amountPendingWithdraw = 0; 

355:         amountPendingWithdraw = 0; 
```


```solidity
📁 File: StrategySushiswap.sol

34:         poolId = _poolId; 

65:             slippage = data; 

112:         totalShares += shares; 

136:         totalShares -= shares; 

145:         totalShares -= shares; 

188:         totalShares = StrategySushiswap(old).totalShares(); 

191:         totalShares = bal; 
```


</details>


---
### [GAS&#x2011;13] `bytes.concat()` can be used in place of `abi.encodePacked`
Given concatenation is not going to be used for hashing `bytes.concat` is the preferred method to use as its more gas efficient

<details>
<summary><i>There are 12 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

275:             abi.encodePacked( 
276:                 "data:application/json;base64,",
277:                 Base64.encode(
278:                     bytes(
279:                         abi.encodePacked(
280:                             '{"name":"#',
281:                             Strings.toString(id),
282:                             '","description":"This NFT represents a leveraged farming position on Rodeo Finance. The owner of this NFT can modify or redeem the position.","image":"',
283:                             "data:image/svg+xml;base64,",
284:                             image,
285:                             '"}'
286:                         )
287:                     )
288:                 )
289:             )

295:             abi.encodePacked( 
296:                 '<svg width="290" height="290" viewBox="0 0 290 290" xmlns="http://www.w3.org/2000/svg"',
297:                 " xmlns:xlink='http://www.w3.org/1999/xlink'>",
298:                 '<defs><clipPath id="corners"><rect width="290" height="290" rx="42" ry="42" /></clipPath><linearGradient id="0" x1="0.5" y1="0" x2="0.5" y2="1"><stop offset="0%" stop-color="#f3a526"/><stop offset="100%" stop-color="#e7940b"/></linearGradient><radialGradient id="1" gradientTransform="translate(-1 -0.5) scale(2, 2)"><stop offset="10%" stop-color="#f3a526"/><stop offset="100%" stop-color="#ffca74"/></radialGradient></defs>',
299:                 '<g clip-path="url(#corners)"><rect fill="url(#0)" x="0px" y="0px" width="290px" height="290px" /><rect fill="url(#1)" x="0px" y="0px" width="290px" height="290px" /><ellipse cx="50%" cy="32px" rx="220px" ry="120px" fill="rgba(255,255,255,0.2)" opacity="0.85" /><rect x="16" y="16" width="258" height="258" rx="26" ry="26" fill="rgba(0,0,0,0)" stroke="rgba(255,255,255,0.4)" />',
300:                 generateHeader(id),
301:                 generateLabelVal(id),
302:                 generateLabelBor(id),
303:                 generateLabelLif(id),
304:                 "</g></svg>"
305:             )

313:             abi.encodePacked( 
314:                 '<text y="64px" x="32px" fill="white" font-family="\'Courier New\', monospace" font-weight="600" font-size="32px">#',
315:                 Strings.toString(id),
316:                 '</text><text y="111px" x="32px" fill="white" font-family="\'Courier New\', monospace" font-weight="200" font-size="24px">',
317:                 IStrategy(s.implementation).name(),
318:                 "</text>"
319:             )

329:             abi.encodePacked( 
330:                 '<g style="transform:translate(29px, 175px)"><rect width="',
331:                 Strings.toString(7 * (len + 4)),
332:                 'px" height="26px" rx="8px" ry="8px" fill="rgba(0,0,0,0.4)" /><text x="12px" y="17px" font-family="\'Courier New\', monospace" font-size="12px" fill="white"><tspan fill="rgba(255,255,255,0.6)">Value: </tspan>',
333:                 str,
334:                 "</text></g>"
335:             )

349:             abi.encodePacked( 
350:                 '<g style="transform:translate(29px, 205px)"><rect width="',
351:                 Strings.toString(7 * (len + 4)),
352:                 'px" height="26px" rx="8px" ry="8px" fill="rgba(0,0,0,0.4)" /><text x="12px" y="17px" font-family="\'Courier New\', monospace" font-size="12px" fill="white"><tspan fill="rgba(255,255,255,0.6)">Borrow: </tspan>',
353:                 str,
354:                 "</text></g>"
355:             )

364:             abi.encodePacked( 
365:                 '<g style="transform:translate(29px, 235px)"><rect width="',
366:                 Strings.toString(7 * (len + 4)),
367:                 'px" height="26px" rx="8px" ry="8px" fill="rgba(0,0,0,0.4)" /><text x="12px" y="17px" font-family="\'Courier New\', monospace" font-size="12px" fill="white"><tspan fill="rgba(255,255,255,0.6)">Life: </tspan>',
368:                 str,
369:                 "</text></g>"
370:             )

379:             sr = abi.encodePacked("0", sr); 

381:         return string(abi.encodePacked(Strings.toString(n / x), ".", sr)); 
```


```solidity
📁 File: StrategyCamelotV3.sol

71:         name = string(abi.encodePacked("Camelot V3 ", hypervisor.token0().symbol(), "/", hypervisor.token1().symbol())); 
```


```solidity
📁 File: StrategyGMXGM.sol

74:             abi.encodePacked( 
75:                 "GMX GM ", IERC20(marketInfo.longToken).symbol(), "/", IERC20(marketInfo.shortToken).symbol()
76:             )
```


```solidity
📁 File: StrategySushiswap.sol

37:             string(abi.encodePacked("SushiSwap ", IERC20(pool.token0()).symbol(), "/", IERC20(pool.token1()).symbol())); 
```


</details>


---
### [GAS&#x2011;14] Cache array length outside of loop
If not cached, the solidity compiler will always read the length of the array during each iteration. That is, if it is a storage array, this is an extra sload operation (100 additional extra gas for each iteration except for the first) and if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first).


Gas saved per Instance: ~4 *(Total: ~8)*
<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: Deploy.s.sol

218:         for (uint256 i = 0; i < salariesAddress.length; i++) { 
```


```solidity
📁 File: PositionManager.sol

378:         for (uint256 i = sr.length; i < f; i++) { 
```


</details>


---
### [GAS&#x2011;15] Cache contracts when making multiple external calls
When function makes multiple calls to the same external contract, it is more gas-efficient to use a local copy of the contract. This is because the EVM will cache the contract in memory, and subsequent calls will be cheaper. It's especially true for contracts that are large and/or have many functions.
> ❗ Issue is removed from: (sxima, sme6en)


Gas saved per Instance: ~168 *(Total: ~6,720)*
<details>
<summary><i>There are 40 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @audit 4 calls to 'asset' contract
/// @audit lines: 58, 71, 72, 72
48:     function executeOperation( 
49:       address,
50:       uint256 amount,
51:       uint256 premium,
52:       address initiator,
53:       bytes calldata params
54:     ) external returns (bool) {
```


```solidity
📁 File: Investor.sol

/// @audit 3 calls to 'store' contract
/// @audit lines: 169, 176, 179
162:     function file(bytes32 what, address data) external auth { 

/// @audit 3 calls to 'store' contract
/// @audit lines: 214, 215, 211
210:     function strategyNew(uint256 index, address implementation) external auth { 

/// @audit 2 calls to 'store' contract
/// @audit lines: 240, 241
239:     function collateralSetFactor(address token, uint256 factor) external auth { 

/// @audit 2 calls to 'store' contract
/// @audit lines: 246, 247
245:     function collateralSetCap(address token, uint256 cap) external auth { 

/// @audit 5 calls to 'store' contract
/// @audit lines: 259, 264, 263, 279, 266
255:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external loop returns (uint256) { 

/// @audit 5 calls to 'store' contract
/// @audit lines: 296, 297, 310, 323, 324
/// @audit 2 calls to 'strategyProxy' contract
/// @audit lines: 332, 366
/// @audit 2 calls to 'helper' contract
/// @audit lines: 344, 349
295:     function edit(uint256 id, int256 borrow, int256 collateral) external loop { 

/// @audit 3 calls to 'store' contract
/// @audit lines: 397, 398, 403
/// @audit 2 calls to 'helper' contract
/// @audit lines: 419, 423
396:     function kill(uint256 id) external loop returns (address, bytes memory) { 

/// @audit 3 calls to 'store' contract
/// @audit lines: 456, 453, 454
451:     function _life(Position memory p) internal view returns (uint256) { 

/// @audit 8 calls to 'store' contract
/// @audit lines: 467, 468, 469, 470, 471, 472, 473, 474
466:     function getPosition(uint256 id) public view returns (Position memory p) { 

/// @audit 8 calls to 'store' contract
/// @audit lines: 478, 479, 480, 481, 482, 483, 484, 485
477:     function setPosition(uint256 id, Position memory p) internal { 

/// @audit 3 calls to 'store' contract
/// @audit lines: 489, 490, 491
488:     function getStrategy(uint256 id) public view returns (Strategy memory s) { 
```


```solidity
📁 File: PositionManager.sol

/// @audit 3 calls to 'investor' contract
/// @audit lines: 234, 239, 241
233:     function edit(uint256 id, int256 borrow, int256 collateral) public auth(id) { 

/// @audit 2 calls to 'investor' contract
/// @audit lines: 310, 311
309:     function generateHeader(uint256 id) private view returns (string memory) { 

/// @audit 2 calls to 'investor' contract
/// @audit lines: 324, 325
323:     function generateLabelVal(uint256 id) private view returns (string memory) { 

/// @audit 2 calls to 'investor' contract
/// @audit lines: 340, 341
339:     function generateLabelBor(uint256 id) private view returns (string memory) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit 2 calls to 'asset' contract
/// @audit lines: 142, 147
/// @audit 2 calls to 'strategyHelper' contract
/// @audit lines: 148, 162
141:     function mint(uint256 amount) external auth loop returns (uint256) { 

/// @audit 3 calls to 'strategyHelper' contract
/// @audit lines: 183, 184, 186
170:     function burn(uint256 shares) external auth loop returns (uint256) { 

/// @audit 2 calls to 'nftPool' contract
/// @audit lines: 214, 209
206:     function stake(uint256 amount) internal { 

/// @audit 2 calls to 'nftPool' contract
/// @audit lines: 222, 224
218:     function unstake(uint256 amount) internal { 

/// @audit 7 calls to 'strategyHelper' contract
/// @audit lines: 265, 242, 250, 258, 244, 252, 260
228:     function earn() external payable loop { 

/// @audit 2 calls to 'strategyHelper' contract
/// @audit lines: 355, 358
344:     function valueLiquidity() private view returns (uint256) { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit 2 calls to 'asset' contract
/// @audit lines: 148, 149
/// @audit 2 calls to 'strategyHelper' contract
/// @audit lines: 150, 151
143:     function mint(uint256 amount) external auth loop returns (uint256) { 

/// @audit 2 calls to 'strategyHelper' contract
/// @audit lines: 164, 162
159:     function burn(uint256 shares) external auth loop returns (uint256) { 

/// @audit 3 calls to 'strategyHelper' contract
/// @audit lines: 200, 196, 207
/// @audit 3 calls to 'reader' contract
/// @audit lines: 227, 244, 245
/// @audit 2 calls to 'exchangeRouter' contract
/// @audit lines: 229, 272
184:     function earn() external payable loop { 

/// @audit 2 calls to 'strategyHelper' contract
/// @audit lines: 295, 296
294:     function rate(uint256 shares) public view returns (uint256) { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit 2 calls to 'pool' contract
/// @audit lines: 37, 37
29:     constructor(address _asset, address _strategyHelper, address _rewarder, uint256 _poolId) { 

/// @audit 2 calls to 'strategyHelper' contract
/// @audit lines: 84, 85
72:     function rate(uint256 sha) public view returns (uint256) { 

/// @audit 2 calls to 'asset' contract
/// @audit lines: 91, 99
/// @audit 2 calls to 'strategyHelper' contract
/// @audit lines: 100, 101
90:     function mint(uint256 amount) public auth loop returns (uint256) {  

/// @audit 2 calls to 'strategyHelper' contract
/// @audit lines: 132, 133
117:     function burn(uint256 shares) public auth loop returns (uint256) { 

/// @audit 3 calls to 'rewarder' contract
/// @audit lines: 159, 172, 158
/// @audit 3 calls to 'strategyHelper' contract
/// @audit lines: 164, 165, 162
153:     function earn() public payable loop { 
```


</details>


---
### [GAS&#x2011;16] Consider activating `via-ir` for deploying
The IR-based code generator was introduced with an aim to not only allow code generation to be more transparent and auditable but also to enable more powerful optimization passes that span across functions.You can enable it on the command line using `--via-ir` or with the option `{"viaIR": true}`.This will take longer to compile, but you can just simple test it before deploying and if you got a better benchmark then you can add --via-ir to your deploy commandMore on: https://docs.soliditylang.org/en/v0.8.17/ir-breaking-changes.html


---
### [GAS&#x2011;17] Consider caching repeated computations
The result of repeated computations can be cached to avoid calculating it multiple times and wasting gas.


Gas saved per Instance: ~60 *(Total: ~240)*
<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: StrategyGMXGM.sol

/// @audit '10000 - slp' is seen 3 times
184:     function earn() external payable loop { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit '(result + a / result) >> 1' is seen 7 times
/// @audit 'result + a / result' is seen 7 times
/// @audit 'a / result' is seen 8 times
201:     function sqrt(uint256 a) internal pure returns (uint256) { 
```


</details>


---
### [GAS&#x2011;18] Consider pre-calculating the address of `address(this)`
It can be more gas-efficient to use a hardcoded address instead of the `address(this)` expression, especially if you need to use the same address multiple times in your contract.

The reason for this, is that using `address(this)` requires an additional `EXTCODESIZE` operation to retrieve the contract’s address from its bytecode, which can increase the gas cost of your contract. By pre-calculating and using a hardcoded address, you can avoid this additional operation and reduce the overall gas cost of your contract.

<details>
<summary><i>There are 84 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

45:         lender.flashLoanSimple(address(this), address(asset), repay, abi.encodePacked(id), 0); 

56:         require(initiator == address(this), "!me"); 

65:             IERC20(a).transfer(a, IERC20(a).balanceOf(address(this))); 
66:             ISushi(a).burn(address(this));

72:         asset.transfer(msg.sender, asset.balanceOf(address(this)) - amount - premium); 

78:         uint256 amount = fromAsset.balanceOf(address(this)); 

80:         sh.swap(_fromAsset, address(asset), amount, slippage, address(this)); 
```


```solidity
📁 File: Investor.sol

174:             if (!strategyProxy.exec(address(this))) revert InvalidFile(); 

177:             if (!IBank(data).exec(address(this))) revert InvalidFile(); 

180:             if (!IPool(data).exec(address(this))) revert InvalidFile(); 

252:         IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))); 

347:                     bank.transfer(p.token, address(this), cAmount); 

349:                     uint256 topup = helper.swap(p.token, poolAsset, cAmount, slippage, address(this)); 

410:         IERC20(poolAsset).transferFrom(msg.sender, address(this), borrow + fee); 
```


```solidity
📁 File: PositionManager.sol

263:         if (!IERC20(ast).transferFrom(usr, address(this), amt)) revert TransferFailed(); 

268:         uint256 bal = asset.balanceOf(address(this)); 
```


```solidity
📁 File: StrategyCamelotV3.sol

128:             nftPool.safeTransferFrom(address(this), _nitroPool, tokenId, ""); 

142:         asset.transferFrom(msg.sender, address(this), amount); 

148:         strategyHelper.swap(address(asset), tgtAst, amount, slp, address(this)); 

152:             uint256 tgtAmt = IERC20(tgtAst).balanceOf(address(this)); 

157:             liq = uniProxy.deposit(amt0, amt1, address(this), hyp, [uint256(0), 0, 0, 0]); 

175:         (uint256 amt0, uint256 amt1) = hypervisor.withdraw(amt, address(this), address(this), [uint256(0), 0, 0, 0]); 

224:             nftPool.safeTransferFrom(address(this), address(nitroPool), tokenId, ""); 

241:             uint256 balance = IERC20(rewardToken1).balanceOf(address(this)); 

244:                 strategyHelper.swap(rewardToken1, tgtAsset, balance, slp, address(this)); 

249:             uint256 balance = IERC20(rewardToken2).balanceOf(address(this)); 

252:                 strategyHelper.swap(rewardToken2, tgtAsset, balance, slp, address(this)); 

257:             uint256 balance = IERC20(rewardToken3).balanceOf(address(this)); 

260:                 strategyHelper.swap(rewardToken3, tgtAsset, balance, slp, address(this)); 

264:         uint256 amt = IERC20(tgtAsset).balanceOf(address(this)); 

270:         stake(uniProxy.deposit(amt0, amt1, address(this), h, [uint256(0), 0, 0, 0])); 

281:         nftPool.safeTransferFrom(address(this), strategy, tokenId, ""); 

289:             nftPool.safeTransferFrom(address(this), address(nitroPool), tokenId, ""); 

326:             uint256 before = hypervisor.token1().balanceOf(address(this)); 

329:             amt1 = hypervisor.token1().balanceOf(address(this)) - before; 

331:             uint256 before = hypervisor.token0().balanceOf(address(this)); 

333:             amt0 = hypervisor.token0().balanceOf(address(this)) - before; 

341:         strategyHelperUniswapV3.swap(trgtAst, path, toLp, minOut, address(this)); 
```


```solidity
📁 File: StrategyGMXGM.sol

134:         (bool success,) = address(msg.sender).call{value: address(this).balance}(""); 

140:       IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))); 

148:         asset.transferFrom(msg.sender, address(this), amount); 

150:         uint256 bal = strategyHelper.swap(address(asset), tokenShort, amount, slp, address(this)); 

193:         uint256 bal = IERC20(tokenLong).balanceOf(address(this)); 

196:             strategyHelper.swap(tokenLong, tokenShort, bal, slp, address(this)); 

199:         bal = IERC20(tokenShort).balanceOf(address(this)); 

207:             uint256 out = strategyHelper.swap(tokenShort, tokenLong, haf, slp, address(this)); 

213:                 receiver: address(this), 
214:                 callbackContract: address(this),

257:                 receiver: address(this), 
258:                 callbackContract: address(this),

287:         IERC20(market).transfer(strategy, IERC20(market).balanceOf(address(this))); 
288:         IERC20(tokenLong).transfer(strategy, IERC20(tokenLong).balanceOf(address(this)));
289:         IERC20(tokenShort).transfer(strategy, IERC20(tokenShort).balanceOf(address(this)));

295:         uint256 val = strategyHelper.value(tokenLong, IERC20(tokenLong).balanceOf(address(this))); 
296:         val += strategyHelper.value(tokenShort, IERC20(tokenShort).balanceOf(address(this)));

298:         uint256 bal = IERC20(market).balanceOf(address(this)) + amountPendingDeposit + amountPendingWithdraw; 

348:         uint256 bal = IERC20(tokenLong).balanceOf(address(this)); 

350:         try strategyHelper.swap(tokenLong, tokenShort, bal, slippage, address(this)) {} catch {} 
```


```solidity
📁 File: StrategySushiswap.sol

91:         asset.transferFrom(msg.sender, address(this), amount); 

100:             strategyHelper.swap(address(asset), address(tok0), haf, slp, address(this)); 
101:             strategyHelper.swap(address(asset), address(tok1), amount - haf, slp, address(this));
102:             IERC20(tok0).transfer(address(pair), tok0.balanceOf(address(this)));
103:             IERC20(tok1).transfer(address(pair), tok1.balanceOf(address(this)));

105:         pair.mint(address(this)); 
106:         pair.skim(address(this));
107:         uint256 liq = IERC20(address(pair)).balanceOf(address(this));

109:         rewarder.deposit(poolId, liq, address(this)); 

124:             pair.burn(address(this)); 

128:         uint256 bal0 = tok0.balanceOf(address(this)); 
129:         uint256 bal1 = tok1.balanceOf(address(this));

159:         rewarder.harvest(poolId, address(this)); 
160:         uint256 amt = rew.balanceOf(address(this));

164:         strategyHelper.swap(address(rew), pair.token0(), haf, slippage, address(this)); 
165:         strategyHelper.swap(address(rew), pair.token1(), amt - haf, slippage, address(this));
166:         IERC20(pair.token0()).transfer(address(pair), IERC20(pair.token0()).balanceOf(address(this)));
167:         IERC20(pair.token1()).transfer(address(pair), IERC20(pair.token1()).balanceOf(address(this)));
168:         pair.mint(address(this));
169:         pair.skim(address(this));
170:         uint256 liq = IERC20(address(pair)).balanceOf(address(this));

172:         rewarder.deposit(poolId, liq, address(this)); 

178:         (uint256 amt,) = rewarder.userInfo(poolId, address(this)); 

190:         uint256 bal = lp.balanceOf(address(this)); 

193:         rewarder.deposit(poolId, bal, address(this)); 
```


</details>


---
### [GAS&#x2011;19] Consider using `bytes32` rather than a `string`
Using the `bytes32` type for fixed-length strings is more efficient than having the EVM have to incur the overhead of string processing. Consider whether the value needs to be a `string`. A good reason to keep it as a `string` would be if the variable is defined in an interface that this project does not own.


Gas saved per Instance: ~378 *(Total: ~756)*

<i>There are 2 instaces of this issue:</i>

```solidity
📁 File: PositionManager.sol

65:     string public constant name = "Rodeo V2 Position"; 
66:     string public constant symbol = "RP2";
```



---
### [GAS&#x2011;20] Consider using OpenZeppelin's `EnumerateSet` instead of nested mappings
Nested mappings and multi-dimensional arrays in Solidity operate through a process of double hashing, wherein the original storage slot and the first key are concatenated and hashed, and then this hash is again concatenated with the second key and hashed. This process can be quite gas expensive due to the double-hashing operation and subsequent storage operation (sstore).

OpenZeppelin's `EnumerableSet` provides a potential solution to this problem. It creates a data structure that combines the benefits of set operations with the ability to enumerate stored elements, which is not natively available in Solidity. EnumerableSet handles the element uniqueness internally and can therefore provide a more gas-efficient and collision-resistant alternative to nested mappings or multi-dimensional arrays in certain scenarios.


Gas saved per Instance: ~1,000 

<i>There is one instance of this issue:</i>

```solidity
📁 File: PositionManager.sol

74:     mapping(address => mapping(address => bool)) public isApprovedForAll; 
```



---
### [GAS&#x2011;21] Consider using Solady's gas optimized lib for Math
Utilizing gas-optimized math functions from libraries like [Solady](https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol) can lead to more efficient smart contracts.
This is particularly beneficial in contracts where these operations are frequently used.

<details>
<summary><i>There are 66 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

72:         asset.transfer(msg.sender, asset.balanceOf(address(this)) - amount - premium); 
```


```solidity
📁 File: Investor.sol

335:             uint256 repaying = amount * 1e18 / index; 

341:                 uint256 needed = p.borrow * index / 1e18; 

345:                     cAmount = cAmount * (10000 + closeCollateralPadding) / 10000; 

357:             push(poolAsset, msg.sender, (amount - used) * (10000 - performanceFee) / 10000); 

391:         uint256 borrow = p.borrow * pool.getUpdatedIndex() / 1e18; 
392:         uint256 fee = borrow * killCollateralPadding / 10000 / 2;

408:         uint256 borrow = p.borrow * pool.getUpdatedIndex() / 1e18; 
409:         uint256 fee = borrow * killCollateralPadding / 10000 / 2;

419:             uint256 target = helper.value(poolAsset, borrow + (fee * 2)); 

423:                 collat = (target - amount) * 1e18 / helper.price(p.token); 

431:             shares = p.shares * target / amount; 

459:         uint256 value = (sharesValue + collateralValue) * factor / 1e18; 
460:         uint256 price = (uint256(oracle.latestAnswer()) * 1e18) / (10 ** oracle.decimals());
461:         uint256 scaled = (p.borrow * 1e18) / (10 ** IERC20(pool.asset()).decimals());
462:         uint256 borrow = (scaled * pool.getUpdatedIndex() / 1e18) * price / 1e18;
463:         return value * 1e18 / borrow;
```


```solidity
📁 File: PositionManager.sol

331:                 Strings.toString(7 * (len + 4)), 

343:         uint256 amt = ( 
344:             (p.borrow * IPool(pool).getUpdatedIndex() / 1e18) * 1e18 / (10 ** IERC20(IPool(pool).asset()).decimals())
345:         ) * uint256(oracle.latestAnswer()) / (10 ** oracle.decimals());

351:                 Strings.toString(7 * (len + 4)), 

366:                 Strings.toString(7 * (len + 4)), 

376:         uint256 r = n / (10 ** (d - f)) % (10 ** f); 
```


```solidity
📁 File: StrategyCamelotV3.sol

161:         uint256 val = valueLiquidity() * liq / totalManagedAssets(); 
162:         if (val < strategyHelper.value(address(asset), amount) * (10000 - slp) / 10000) revert PriceSlipped();
163:         uint256 shares = tma == 0 ? liq : liq * totalShares / tma;

172:         uint256 amt = (shares * tma) / totalShares; 
173:         uint256 val = valueLiquidity() * amt / tma;

186:         if (strategyHelper.value(address(asset), bal) < val * (10000 - slp) / 10000) revert PriceSlipped(); 

194:         uint256 amount = shares * totalManagedAssets() / totalShares; 

294:         return shares * valueLiquidity() / totalShares; 

314:         uint256 toLp0 = amt * 1e18 / ((((start + end) / 2) * 1e18 / out1) + 1e18); 

339:         uint256 minOut = strategyHelper.convert(trgtAst, ast, toLp) * (10000 - slp) / 10000; 

352:         uint160 midX96 = TickMath.getSqrtRatioAtTick(int24((tickCumulatives[1] - tickCumulatives[0]) / int32(period))); 

356:             address(hypervisor.token0()), bas0 + lim0 + hypervisor.token0().balanceOf(address(hypervisor)) 

359:             address(hypervisor.token1()), bas1 + lim1 + hypervisor.token1().balanceOf(address(hypervisor)) 

364:         val0 = val0 * bal / spl; 
365:         val1 = val1 * bal / spl;
```


```solidity
📁 File: StrategyGMXGM.sol

152:         uint256 shares = (tma == 0 || tot == 0) ? val : val * tot / tma; 

162:         uint256 amt = (val * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort); 

173:         uint256 amount = (value * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort); 

201:         uint256 need = rate(totalShares) * reserveRatio / 10000; 

204:             uint256 amt = (have - need) * bal / have; 

208:             uint256 minOut = (have - need) * 1e18 / marketTokenPrice(true); 

210:             minOut = minOut * (10000 - slp) / 10000; 

242:             uint256 amt = (need - have) * 1e18 / marketTokenPrice(true); 

263:                 minLongTokenAmount: longOut * (10000 - slp) / 10000, 
264:                 minShortTokenAmount: shortOut * (10000 - slp) / 10000,

298:         uint256 bal = IERC20(market).balanceOf(address(this)) + amountPendingDeposit + amountPendingWithdraw; 
299:         val += bal * marketTokenPrice(true) / 1e18;

301:         return shares * val / totalShares; 

331:         price = price * (10 ** (30 - decimals)) / 1e18; 
```


```solidity
📁 File: StrategySushiswap.sol

81:             reserve0 = uint256(r0) * 1e18 / (10 ** IERC20(pair.token0()).decimals()); 
82:             reserve1 = uint256(r1) * 1e18 / (10 ** IERC20(pair.token1()).decimals());

86:         uint256 val = 2 * ((sqrt(reserve0 * reserve1) * sqrt(price0 * price1)) / tot); 
87:         return sha * (val * amt / 1e18) / totalShares;

110:         uint256 shares = tma == 0 ? liq : liq * totalShares / tma; 

122:             uint256 amt = shares * tma / totalShares; 

142:         uint256 amount = shares * totalManagedAssets() / totalShares; 

203:         uint256 result = 1 << (log2(a) >> 1); 

205:             result = (result + a / result) >> 1; 
206:             result = (result + a / result) >> 1;
207:             result = (result + a / result) >> 1;
208:             result = (result + a / result) >> 1;
209:             result = (result + a / result) >> 1;
210:             result = (result + a / result) >> 1;
211:             result = (result + a / result) >> 1;
```


</details>


---
### [GAS&#x2011;22] Constructors can be marked `payable`
Payable functions cost less gas to execute, since the compiler does not have to add extra checks to ensure that a payment wasn't provided. A constructor can safely be marked as payable, since only the deployer would be able to pass funds, and the project itself would not pass any funds.


Gas saved per Instance: ~21 *(Total: ~210)*
<details>
<summary><i>There are 10 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

17:     constructor() { 
```


```solidity
📁 File: Helper.sol

36:     constructor(address _investor, address _asset, address _lender, address _sh) { 
```


```solidity
📁 File: Investor.sol

144:     constructor(address _store, address _helper) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

24:     constructor(address _asset) { 
```


```solidity
📁 File: PositionManager.sol

91:     constructor(address _investor) { 
```


```solidity
📁 File: Store.sol

26:     constructor() { 
```


```solidity
📁 File: StrategyCamelotV3.sol

48:     constructor( 
```


```solidity
📁 File: StrategyGMXGM.sol

48:     constructor( 
```


```solidity
📁 File: StrategySushiswap.sol

29:     constructor(address _asset, address _strategyHelper, address _rewarder, uint256 _poolId) { 
```


```solidity
📁 File: Whitelist.sol

14:     constructor() { 
```


</details>


---
### [GAS&#x2011;23] Counting down in `for` statements is more gas efficient
Counting down is more gas efficient than counting up because neither we are making zero variable to non-zero variable and also we will get gas refund in the last transaction when making non-zero to zero variable. [More info](https://solodit.xyz/issues/g-02-counting-down-in-for-statements-is-more-gas-efficient-code4rena-pooltogether-pooltogether-git)


Gas saved per Instance: ~16 *(Total: ~80)*
<details>
<summary><i>There are 5 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

129:         for (uint256 i = start; i < end; i++) { 

378:         for (uint256 i = sr.length; i < f; i++) { 
```


```solidity
📁 File: Store.sol

136:         for (uint256 i = start; i < end; i++) { 
```


```solidity
📁 File: UtilFarmingBalances.sol

20:         for (uint256 y = start; y < max; y++) { 
```


```solidity
📁 File: Whitelist.sol

36:         for (uint256 i = 0; i < l; i++) { 
```


</details>


---
### [GAS&#x2011;24] Do not cache state variables that are used only once
It's cheaper to access the state variable directly if it is accessed only once. This can save the **3 gas** cost of the extra stack allocation.


Gas saved per Instance: ~3 *(Total: ~6)*

<i>There are 2 instaces of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

144:         uint256 slp = slippage; 

160:         uint256 slp = slippage; 
```



---
### [GAS&#x2011;25] `do`-`while` is cheaper than `for`-loops when the initial check can be skipped
Using `do-while` loops instead of `for` loops can be more gas-efficient.
Even if you add an `if` condition to account for the case where the loop doesn't execute at all, a `do-while` loop can still be cheaper in terms of gas.


Gas saved per Instance: ~255 *(Total: ~1,275)*
<details>
<summary><i>There are 5 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

129:         for (uint256 i = start; i < end; i++) { 

378:         for (uint256 i = sr.length; i < f; i++) { 
```


```solidity
📁 File: Store.sol

136:         for (uint256 i = start; i < end; i++) { 
```


```solidity
📁 File: UtilFarmingBalances.sol

20:         for (uint256 y = start; y < max; y++) { 
```


```solidity
📁 File: Whitelist.sol

36:         for (uint256 i = 0; i < l; i++) { 
```


</details>


---
### [GAS&#x2011;26] Don't transfer with zero amount to save gas
In Solidity, unnecessary operations can waste gas. For example, a transfer function without a zero amount check uses gas even if called with a zero amount, since the contract state remains unchanged. Implementing a zero amount check avoids these unnecessary function calls, saving gas and improving efficiency.


Gas saved per Instance: ~20 *(Total: ~200)*
<details>
<summary><i>There are 10 instances of this issue:</i></summary>

```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit check for zero amount on the 'amount' variable
50:         asset.transfer(msg.sender, amount); 
```


```solidity
📁 File: PositionManager.sol

/// @audit check for zero amount on the 'id' variable
189:         transferFrom(from, to, id); 

/// @audit check for zero amount on the 'id' variable
199:         transferFrom(from, to, id); 

/// @audit check for zero amount on the 'amt' variable
263:         if (!IERC20(ast).transferFrom(usr, address(this), amt)) revert TransferFailed(); 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit check for zero amount on the 'amount' variable
142:         asset.transferFrom(msg.sender, address(this), amount); 

/// @audit check for zero amount on the 'amount' variable
196:         hypervisor.transfer(to, amount); 

/// @audit check for zero amount on the 'toLp' variable
340:         IERC20(trgtAst).transfer(address(strategyHelperUniswapV3), toLp); 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit check for zero amount on the 'amount' variable
148:         asset.transferFrom(msg.sender, address(this), amount); 

/// @audit check for zero amount on the 'amount' variable
174:         IERC20(tokenShort).transfer(to, amount); 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit check for zero amount on the 'amount' variable
91:         asset.transferFrom(msg.sender, address(this), amount); 
```


</details>


---
### [GAS&#x2011;27] Duplicated `require()/revert()` checks should be refactored to a modifier or function
Saves deployment costs


<i>There are 72 instaces of this issue:</i>

```solidity
📁 File: PositionManager.sol

136:         require( 

184:         require(to != address(0), "INVALID_RECIPIENT"); 

190:         require( 

200:         require( 

221:         require(to != address(0), "INVALID_RECIPIENT"); 

224:         require( 

248:         require(owner != address(0), "NOT_MINTED"); 

254:         require(owner != address(0), "NOT_MINTED"); 
```



---
### [GAS&#x2011;28] Emitting constants wastes gas
Every event parameter costs `Glogdata` (**8 gas**) per byte. You can avoid this extra cost, in cases where you're emitting a constant, by creating a second version of the event, which doesn't have the parameter (and have users look to the contract's variables for its value instead), and using the new event in the cases shown below.


Gas saved per Instance: ~8 

<i>There is one instance of this issue:</i>

```solidity
📁 File: Investor.sol

/// @audit 4, 0
216:         emit StrategyUpdate(index, implementation, 4, 0); 
```



---
### [GAS&#x2011;29] Empty blocks should be removed or emit something
Some functions don't have a body: consider commenting why, or add some logic. Otherwise, refactor the code and remove these functions.


<i>There are 2 instaces of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

80:     receive() external payable {} 

292:     function move(address old) external auth {} 
```



---
### [GAS&#x2011;30] Fixed-size arrays are cheaper than dynamic-size arrays
Using fixed-size arrays can result in large gas savings.
> ❗ Issue is removed from: (sme6en, pech)

<details>
<summary><i>There are 13 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

87:         uint256[] values; 
```


```solidity
📁 File: Store.sol

16:         bytes32[] values; 

121:     function setBytes32Array(bytes32 key, bytes32[] memory value) external auth { 
```


```solidity
📁 File: StrategyCamelotV3.sol

201:         address[] memory assets = new address[](1); 

346:         uint32[] memory secondsAgos = new uint32[](2); 
```


```solidity
📁 File: StrategyGMXGM.sol

179:         address[] memory assets = new address[](1); 

228:             bytes[] memory data = new bytes[](4); 

271:             bytes[] memory data = new bytes[](3); 
```


```solidity
📁 File: StrategySushiswap.sol

148:         address[] memory assets = new address[](1); 
```


```solidity
📁 File: UtilFarmingBalances.sol

18:         address[] memory users = new address[](max-start); 
19:         uint256[] memory balances = new uint256[](max-start);
```


```solidity
📁 File: Whitelist.sol

9:     event BatchWhitelist(address[] addresses, bool status); 

34:     function batchWhitelist(address[] memory addresses, bool status) external auth { 
```


</details>


---
### [GAS&#x2011;31] Function names can be optimized
Function that are `public`/`external` and `public` state variable names can be optimized to save gas.

Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, per sorted position shifted. [Reference](https://blog.emn178.cc/en/post/solidity-gas-optimization-function-name/)


Gas saved per Instance: ~128 *(Total: ~5,376)*
<details>
<summary><i>There are 42 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit optimized order: file(), transfer(), transferNative()
8: contract Bank { 
```


```solidity
📁 File: Helper.sol

/// @audit optimized order: transfer(), balanceOf(), approve()
4: interface IERC20 { 

/// @audit optimized order: kill(), killRepayment()
10: interface IInvestor { 

/// @audit optimized order: token1(), burn(), token0()
23: interface ISushi { 
```


```solidity
📁 File: Investor.sol

/// @audit optimized order: transfer(), balanceOf(), decimals(), transferFrom(), approve()
4: interface IERC20 { 

/// @audit optimized order: latestAnswer(), decimals()
12: interface IOracle { 

/// @audit optimized order: setUint(), setAddress(), getUint(), exec(), setUintDelta(), getAddress()
17: interface IStore { 

/// @audit optimized order: transfer(), exec()
26: interface IBank { 

/// @audit optimized order: borrow(), oracle(), exec(), getUpdatedIndex(), asset(), repay()
31: interface IPool { 

/// @audit optimized order: swap(), price(), convert(), value()
40: interface IHelper { 

/// @audit optimized order: rate(), exit(), totalShares(), move()
47: interface IStrategy { 

/// @audit optimized order: kill(), burn(), exec(), mint()
54: interface IStrategyProxy { 

/// @audit optimized order: getPosition(), file(), kill(), getStrategy(), strategySetStatus(), strategyUgrade(), collateralSetCap(), edit(), strategyNew(), killRepayment(), collateralSetFactor(), open(), file(), life(), strategySetCap(), collect(), _life(), setPosition(), getPool(), push(), pullToBank(), min()
65: contract Investor { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit optimized order: transfer(), approve()
4: interface IERC20 { 

/// @audit optimized order: kill(), mint(), burn()
9: interface IStrategy { 

/// @audit optimized order: kill(), file(), burn(), call(), mint()
15: contract InvestorStrategyProxy { 
```


```solidity
📁 File: PositionManager.sol

/// @audit optimized order: transfer(), balanceOf(), decimals(), transferFrom(), approve()
7: interface IERC20 { 

/// @audit optimized order: oracle(), getUpdatedIndex(), asset()
20: interface IPool { 

/// @audit optimized order: rate(), name()
26: interface IStrategy { 

/// @audit optimized order: getPosition(), getStrategy(), edit(), open(), life(), getPool()
31: interface IInvestor { 

/// @audit optimized order: open(), file(), tokenURI(), tokensOfOwner(), safeTransferFrom(), edit(), setApprovalForAll(), balanceOf(), ownerOf(), burn(), safeTransferFrom(), forceBurn(), tokenOfOwnerByIndex(), transferFrom(), approve(), moveId(), supportsInterface(), rely(), pull(), push(), generateImage(), generateHeader(), generateLabelVal(), generateLabelBor(), generateLabelLif(), formatNumber()
64: contract PositionManager { 
```


```solidity
📁 File: Store.sol

/// @audit optimized order: getBytes32Count(), getBytes32ValuesAt(), removeInt(), setUint(), getBytes32Array(), getInt(), file(), removeBytes32(), removeString(), setAddress(), addBytes32(), removeBytes32Array(), getUint(), setBool(), getBytes32(), removeBool(), removeAddress(), removeBytes32(), getString(), containsBytes32(), getBool(), setString(), setBytes32(), setUintDelta(), removeUint(), setInt(), setIntDelta(), setBytes32Array(), getAddress()
4: contract Store { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit optimized order: onNFTHarvest(), xgrailRedeem(), rate(), onNFTAddToPosition(), file(), earn(), setNitroPool(), kill(), exit(), mint(), setPathToLp(), burn(), onNFTWithdraw(), file(), move(), xgrailFinalizeRedeem(), stake(), unstake(), quoteAddLiquidity(), quoteAndSwap(), swap(), valueLiquidity(), totalManagedAssets(), getPosition(), onERC721Received(), min()
7: contract StrategyCamelotV3 { 

/// @audit optimized order: transfer(), symbol(), balanceOf(), transferFrom(), approve()
414: interface IERC20 { 

/// @audit optimized order: swap(), convert(), value()
422: interface IStrategyHelper { 

/// @audit optimized order: baseLower(), token1(), withdraw(), baseUpper(), limitLower(), totalSupply(), pool(), limitUpper(), token0()
441: interface IHypervisor is IERC20 { 

/// @audit optimized order: withdrawFromPosition(), createPosition(), safeTransferFrom(), addToPosition(), harvestPosition(), getStakingPosition()
453: interface INFTPool { 

/// @audit optimized order: token1(), getTimepoints(), positions(), token0()
471: interface IAlgebraPool { 

/// @audit optimized order: finalizeRedeem(), redeem()
490: interface IXGrail { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit optimized order: rate(), file(), earn(), afterWithdrawalCancellation(), kill(), exit(), marketTokenPrice(), afterWithdrawalExecution(), withdrawEth(), mint(), afterDepositExecution(), afterDepositCancellation(), burn(), withdrawAirdrop(), file(), move(), gmxPrice(), min()
4: contract StrategyGMXGM { 

/// @audit optimized order: transfer(), symbol(), balanceOf(), decimals(), transferFrom(), approve()
363: interface IERC20 { 

/// @audit optimized order: swap(), price(), value()
372: interface IStrategyHelper { 

/// @audit optimized order: getUint(), getBytes32(), getAddress()
393: interface IDataStore { 

/// @audit optimized order: router(), sendTokens(), createWithdrawal(), multicall(), sendWnt(), createDeposit()
399: interface IExchangeRouter { 

/// @audit optimized order: getWithdrawalAmountOut(), getMarket(), getMarketTokenPrice()
477: interface IReader { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit optimized order: rate(), file(), earn(), kill(), exit(), mint(), burn(), file(), move(), totalManagedAssets(), min(), sqrt(), log2()
4: contract StrategySushiswap { 

/// @audit optimized order: transfer(), symbol(), balanceOf(), decimals(), transferFrom(), approve()
253: interface IERC20 { 

/// @audit optimized order: swap(), price(), value()
262: interface IStrategyHelper { 

/// @audit optimized order: token1(), skim(), burn(), mint(), price1CumulativeLast(), price0CumulativeLast(), totalSupply(), token0(), getReserves(), swap()
268: interface IUniswapV2Pair { 

/// @audit optimized order: SUSHI(), userInfo(), deposit(), lpToken(), pendingSushi(), harvest(), withdraw()
281: interface ISushiswapMiniChefV2 { 
```


```solidity
📁 File: UtilFarmingBalances.sol

/// @audit optimized order: positions(), nextPosition()
4: interface IInvestor { 
```


```solidity
📁 File: Whitelist.sol

/// @audit optimized order: file(), check(), batchWhitelist()
4: contract Whitelist { 
```


</details>


---
### [GAS&#x2011;32] Integer increments by one can be unchecked
Using unchecked increments in Solidity can save on gas fees by bypassing built-in overflow checks, thus optimizing gas usage, but requires careful assessment of potential risks and edge cases to avoid unintended consequences.


Gas saved per Instance: ~60 *(Total: ~300)*
<details>
<summary><i>There are 5 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

129:         for (uint256 i = start; i < end; i++) { 

378:         for (uint256 i = sr.length; i < f; i++) { 
```


```solidity
📁 File: Store.sol

136:         for (uint256 i = start; i < end; i++) { 
```


```solidity
📁 File: UtilFarmingBalances.sol

20:         for (uint256 y = start; y < max; y++) { 
```


```solidity
📁 File: Whitelist.sol

36:         for (uint256 i = 0; i < l; i++) { 
```


</details>


---
### [GAS&#x2011;33] `internal` functions only used once can be inlined so save gas
If a internal function is only used once it doesn't make sense to modularise it unless the function which does call the function would be overly long and complex otherwise


Gas saved per Instance: ~30 *(Total: ~120)*
<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

513:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

409:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
```


```solidity
📁 File: StrategyGMXGM.sol

358:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
```


```solidity
📁 File: StrategySushiswap.sol

216:     function log2(uint256 value) internal pure returns (uint256) { 
```


</details>


---
### [GAS&#x2011;34] Low-level `call` can be optimized with assembly
`returnData` is copied to memory even if the variable is not utilized: the proper way to handle this is through a low level assembly call and save **159** [gas](https://gist.github.com/IllIllI000/0e18a40f3afb0b83f9a347b10ee89ad2).

```solidity
 // before (bool success,) = payable(receiver).call{gas: gas, value: value}("");
//after bool success; assembly { success := call(gas, receiver, value, 0, 0, 0, 0) }
```



Gas saved per Instance: ~159 *(Total: ~318)*
<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

37:         (bool s,) = to.call{value: amount}(""); 
```


```solidity
📁 File: InvestorStrategyProxy.sol

59:         (bool success,) = strategy.call{value: value}(data); 
```


</details>


---
### [GAS&#x2011;35] Mappings are cheaper to use than storage arrays
When using storage arrays, solidity adds an internal lookup of the array's length (a Gcoldsload **2100 gas**) to ensure you don't read past the array's end. You can avoid this lookup by using a `mapping` and storing the number of entries in a separate storage variable. In cases where you have sentinel values (e.g. 'zero' means invalid), you can avoid length checks


Gas saved per Instance: ~2,100 *(Total: ~67,200)*
<details>
<summary><i>There are 32 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

87:         uint256[] values; 
```


```solidity
📁 File: Store.sol

12:     mapping(bytes32 => bytes32[]) public bytes32ArrayValues; 

16:         bytes32[] values; 
```


```solidity
📁 File: StrategyGMXGM.sol

407:         address[] longTokenSwapPath; 
408:         address[] shortTokenSwapPath;

420:         address[] longTokenSwapPath; 
421:         address[] shortTokenSwapPath;

512:         address[] longTokenSwapPath; 
513:         address[] shortTokenSwapPath;

543:         address[] longTokenSwapPath; 
544:         address[] shortTokenSwapPath;

573:         AddressKeyValue[] items; 
574:         AddressArrayKeyValue[] arrayItems;

578:         UintKeyValue[] items; 
579:         UintArrayKeyValue[] arrayItems;

583:         IntKeyValue[] items; 
584:         IntArrayKeyValue[] arrayItems;

588:         BoolKeyValue[] items; 
589:         BoolArrayKeyValue[] arrayItems;

593:         Bytes32KeyValue[] items; 
594:         Bytes32ArrayKeyValue[] arrayItems;

598:         BytesKeyValue[] items; 
599:         BytesArrayKeyValue[] arrayItems;

603:         StringKeyValue[] items; 
604:         StringArrayKeyValue[] arrayItems;

614:         address[] value; 

624:         uint256[] value; 

634:         int256[] value; 

644:         bool[] value; 

654:         bytes32[] value; 

664:         bytes[] value; 

674:         string[] value; 
```


</details>


---
### [GAS&#x2011;36] Multiple accesses of the same mapping/array key/index should be cached
The instances below point to the second+ access of a value inside a mapping/array key/index, within a function. Caching a mapping's value in a local storage or calldata variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves ~42 gas per access due to not having to recalculate the key's keccak256 hash (Gkeccak256 - 30 gas) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata


Gas saved per Instance: ~42 *(Total: ~924)*
<details>
<summary><i>There are 22 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit exec[data] is also accessed on line 28
28:             exec[data] = !exec[data]; 
```


```solidity
📁 File: Investor.sol

/// @audit exec[data] is also accessed on line 164
164:             exec[data] = !exec[data]; 

/// @audit lastBlock[id] is also accessed on line 307
308:         lastBlock[id] = block.number; 

/// @audit lastBlock[id] is also accessed on line 404
405:         lastBlock[id] = block.number; 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit exec[data] is also accessed on line 36
36:           exec[data] = !exec[data]; 
```


```solidity
📁 File: PositionManager.sol

/// @audit exec[data] is also accessed on line 103
103:             exec[data] = !exec[data]; 

/// @audit i.positions[id] is also accessed on line 159
174:             i.positions[id] = i.values.length; 
```


```solidity
📁 File: Store.sol

/// @audit exec[data] is also accessed on line 37
37:             exec[data] = !exec[data]; 

/// @audit uintValues[key] is also accessed on line 52
56:         uintValues[key] = next; 

/// @audit intValues[key] is also accessed on line 70
71:         intValues[key] = next; 

/// @audit s.positions[value] is also accessed on line 142
144:             s.positions[value] = s.values.length; 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit exec[data] is also accessed on line 92
92:             exec[data] = !exec[data]; 

/// @audit keepers[data] is also accessed on line 94
94:             keepers[data] = !keepers[data]; 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit exec[data] is also accessed on line 96
96:             exec[data] = !exec[data]; 

/// @audit keepers[data] is also accessed on line 98
98:             keepers[data] = !keepers[data]; 

/// @audit data[0] is also accessed on line 235
273:             data[0] = abi.encodeWithSelector(IExchangeRouter.sendWnt.selector, withdrawalVault, params.executionFee); 
/// @audit data[1] is also accessed on line 236
274:             data[1] = abi.encodeWithSelector(IExchangeRouter.sendTokens.selector, market, withdrawalVault, amt);
/// @audit data[2] is also accessed on line 237
275:             data[2] = abi.encodeWithSelector(IExchangeRouter.createWithdrawal.selector, params);
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit exec[data] is also accessed on line 54
54:             exec[data] = !exec[data]; 

/// @audit keepers[data] is also accessed on line 56
56:             keepers[data] = !keepers[data]; 
```


```solidity
📁 File: Whitelist.sol

/// @audit exec[data] is also accessed on line 25
25:             exec[data] = !exec[data]; 

/// @audit whitelist[data] is also accessed on line 27
27:             whitelist[data] = !whitelist[data]; 
```


</details>


---
### [GAS&#x2011;37] Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`
Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - **30 gas**) and that calculation's associated stack operations.


Gas saved per Instance: ~20,000 *(Total: ~80,000)*

<i>There are 4 instaces of this issue:</i>

```solidity
📁 File: PositionManager.sol

70:     mapping(uint256 => address) internal _ownerOf; 
71:     mapping(address => uint256) internal _balanceOf;

73:     mapping(uint256 => address) public getApproved; 

88:         mapping(uint256 => uint256) positions; 
```



---
### [GAS&#x2011;38] Nesting `if`-statements is cheaper than using `&&`
Using a double if statement instead of logical AND (&&) can provide similar short-circuiting behavior whereas double if is slightly more efficient.


Gas saved per Instance: ~30 *(Total: ~360)*
<details>
<summary><i>There are 12 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

304:         if (borrow < 0 && uint256(-borrow) > p.shares) revert InvalidParameters(); 
305:         if (borrow > 0 && p.shares == 0) revert InvalidParameters();
306:         if (collateral < 0 && uint256(-collateral) > p.collateral) revert InvalidParameters();

311:             if (borrow > 0 && (status < STATUS_LIVE || s.status < STATUS_LIVE)) { 

314:             if (borrow <= 0 && (status < STATUS_WITHDRAW || s.status < STATUS_WITHDRAW)) { 

383:         if (borrow > 0 && si.rate(si.totalShares()) > s.cap) revert StrategyOverCap(); 
```


```solidity
📁 File: PositionManager.sol

269:         if (bal > 0 && !asset.transfer(usr, bal)) revert TransferFailed(); 
```


```solidity
📁 File: Store.sol

54:         if (value > 0 && next < prev) revert OverOrUnderflow(); 
55:         if (value < 0 && next > prev) revert OverOrUnderflow();
```


```solidity
📁 File: StrategyCamelotV3.sol

73:         if (_targetAsset != address(hypervisor.token0()) && _targetAsset != address(hypervisor.token1())) { 

208:         if (tokenId != 0 && totalManagedAssets() > 0) { 

391:         if (msg.sender == address(nftPool) && tokenId == 0) { 
```


</details>


---
### [GAS&#x2011;39] Newer versions of solidity are more gas efficient
The solidity language continues to pursue more efficient gas optimization schemes. Adopting a [newer version of solidity](https://github.com/ethereum/solc-js/tags) can be more gas efficient.

<details>
<summary><i>There are 11 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Helper.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Investor.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: InvestorStrategyProxy.sol

2: pragma solidity 0.8.17; 
```


```solidity
📁 File: PositionManager.sol

2: pragma solidity 0.8.17; 
```


```solidity
📁 File: Store.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: StrategyCamelotV3.sol

2: pragma solidity 0.8.17; 
```


```solidity
📁 File: StrategyGMXGM.sol

2: pragma solidity 0.8.17; 
```


```solidity
📁 File: StrategySushiswap.sol

2: pragma solidity 0.8.17; 
```


```solidity
📁 File: UtilFarmingBalances.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Whitelist.sol

2: pragma solidity ^0.8.0; 
```


</details>


---
### [GAS&#x2011;40] Not using the named return variables when a function returns, wastes deployment gas
The solidity compiler outputs more efficient code when the variable is declared in the return statement. There seem to be very few exceptions to this in practice, so if you see an anonymous return, you should test it with a named return instead to determine which case is most efficient.

<details>
<summary><i>There are 239 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit Parameter of type 'bool' at index '0'
5:     function transfer(address, uint256) external returns (bool); 
```


```solidity
📁 File: Helper.sol

/// @audit Parameter of type 'uint256' at index '0'
5:     function balanceOf(address) external view returns (uint256); 

/// @audit Parameter of type 'uint256' at index '0'
11:     function killRepayment(uint256) external returns (uint256); 
/// @audit Parameter of type 'address' at index '0'
/// @audit Parameter of type 'bytes' at index '1'
12:     function kill(uint256 id) external returns (address, bytes memory);

/// @audit Parameter of type 'uint256' at index '0'
20:     function swap(address, address, uint256, uint256, address) external returns (uint256); 

/// @audit Parameter of type 'address' at index '0'
24:     function token0() external view returns (address); 
/// @audit Parameter of type 'address' at index '0'
25:     function token1() external view returns (address);

48:     function executeOperation( 
```


```solidity
📁 File: Investor.sol

/// @audit Parameter of type 'uint8' at index '0'
5:     function decimals() external view returns (uint8); 
/// @audit Parameter of type 'uint256' at index '0'
6:     function balanceOf(address) external view returns (uint256);

/// @audit Parameter of type 'bool' at index '0'
8:     function transfer(address, uint256) external returns (bool); 
/// @audit Parameter of type 'bool' at index '0'
9:     function transferFrom(address, address, uint256) external returns (bool);

/// @audit Parameter of type 'uint8' at index '0'
13:     function decimals() external view returns (uint8); 
/// @audit Parameter of type 'int256' at index '0'
14:     function latestAnswer() external view returns (int256);

/// @audit Parameter of type 'bool' at index '0'
18:     function exec(address) external view returns (bool); 
/// @audit Parameter of type 'uint256' at index '0'
19:     function getUint(bytes32) external view returns (uint256);
/// @audit Parameter of type 'address' at index '0'
20:     function getAddress(bytes32) external view returns (address);

/// @audit Parameter of type 'uint256' at index '0'
22:     function setUintDelta(bytes32, int256) external returns (uint256); 
/// @audit Parameter of type 'address' at index '0'
23:     function setAddress(bytes32, address) external returns (address);

/// @audit Parameter of type 'bool' at index '0'
27:     function exec(address) external view returns (bool); 

/// @audit Parameter of type 'bool' at index '0'
32:     function exec(address) external view returns (bool); 
/// @audit Parameter of type 'address' at index '0'
33:     function asset() external view returns (address);
/// @audit Parameter of type 'address' at index '0'
34:     function oracle() external view returns (address);
/// @audit Parameter of type 'uint256' at index '0'
35:     function getUpdatedIndex() external view returns (uint256);
/// @audit Parameter of type 'uint256' at index '0'
36:     function borrow(uint256) external returns (uint256);
/// @audit Parameter of type 'uint256' at index '0'
37:     function repay(uint256) external returns (uint256);

/// @audit Parameter of type 'uint256' at index '0'
41:     function price(address) external view returns (uint256); 
/// @audit Parameter of type 'uint256' at index '0'
42:     function value(address, uint256) external view returns (uint256);
/// @audit Parameter of type 'uint256' at index '0'
43:     function convert(address, address, uint256) external view returns (uint256);
/// @audit Parameter of type 'uint256' at index '0'
44:     function swap(address, address, uint256, uint256, address) external returns (uint256);

/// @audit Parameter of type 'uint256' at index '0'
48:     function totalShares() external view returns (uint256); 
/// @audit Parameter of type 'uint256' at index '0'
49:     function rate(uint256) external view returns (uint256);

/// @audit Parameter of type 'bool' at index '0'
55:     function exec(address) external view returns (bool); 
/// @audit Parameter of type 'uint256' at index '0'
56:     function mint(address, uint256) external returns (uint256);
/// @audit Parameter of type 'uint256' at index '0'
57:     function burn(address, uint256) external returns (uint256);
/// @audit Parameter of type 'bytes' at index '0'
58:     function kill(address, uint256, address) external returns (bytes memory);

/// @audit Parameter of type 'bool' at index '0'
62:     function check(address) external view returns (bool); 

/// @audit Parameter of type 'uint256' at index '0'
255:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external loop returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
388:     function killRepayment(uint256 id) external view returns (uint256) { 

/// @audit Parameter of type 'address' at index '0'
/// @audit Parameter of type 'bytes' at index '1'
396:     function kill(uint256 id) external loop returns (address, bytes memory) { 

/// @audit Parameter of type 'uint256' at index '0'
446:     function life(uint256 id) external view returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
451:     function _life(Position memory p) internal view returns (uint256) { 

466:     function getPosition(uint256 id) public view returns (Position memory p) { 
467:         p.owner = store.getAddress(keccak256(abi.encode(id, POSITIONS_OWNER)));
468:         p.start = store.getUint(keccak256(abi.encode(id, POSITIONS_START)));
469:         p.strategy = store.getUint(keccak256(abi.encode(id, POSITIONS_STRATEGY)));
470:         p.token = store.getAddress(keccak256(abi.encode(id, POSITIONS_TOKEN)));
471:         p.collateral = store.getUint(keccak256(abi.encode(id, POSITIONS_COLLATERAL)));
472:         p.borrow = store.getUint(keccak256(abi.encode(id, POSITIONS_BORROW)));
473:         p.shares = store.getUint(keccak256(abi.encode(id, POSITIONS_SHARES)));
474:         p.basis = store.getUint(keccak256(abi.encode(id, POSITIONS_BASIS)));
475:     }

488:     function getStrategy(uint256 id) public view returns (Strategy memory s) { 
489:         s.implementation = store.getAddress(keccak256(abi.encode(id, STRATEGIES_ADDRESS)));
490:         s.cap = store.getUint(keccak256(abi.encode(id, STRATEGIES_CAP)));
491:         s.status = store.getUint(keccak256(abi.encode(id, STRATEGIES_STATUS)));
492:         if (s.implementation == address(0)) revert UnknownStrategy();
493:     }

/// @audit Parameter of type 'address' at index '0'
495:     function getPool() public view returns (address) { 

/// @audit Parameter of type 'uint256' at index '0'
513:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit Parameter of type 'bool' at index '0'
5:     function approve(address, uint256) external returns (bool); 
/// @audit Parameter of type 'bool' at index '0'
6:     function transfer(address, uint256) external returns (bool);

10:     function mint(uint256 amount) external returns (uint256 shares); 
11:     function burn(uint256 shares) external returns (uint256 amount);
/// @audit Parameter of type 'bytes' at index '0'
12:     function kill(uint256 shares, address to) external returns (bytes memory);

/// @audit Parameter of type 'uint256' at index '0'
43:     function mint(address strategy, uint256 amount) public auth returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
48:     function burn(address strategy, uint256 shares) public auth returns (uint256) { 

/// @audit Parameter of type 'bytes' at index '0'
54:     function kill(address strategy, uint256 shares, address target) public auth returns (bytes memory) { 
```


```solidity
📁 File: PositionManager.sol

/// @audit Parameter of type 'uint8' at index '0'
8:     function decimals() external view returns (uint8); 
/// @audit Parameter of type 'uint256' at index '0'
9:     function balanceOf(address) external view returns (uint256);
/// @audit Parameter of type 'bool' at index '0'
10:     function approve(address, uint256) external returns (bool);
/// @audit Parameter of type 'bool' at index '0'
11:     function transfer(address, uint256) external returns (bool);
/// @audit Parameter of type 'bool' at index '0'
12:     function transferFrom(address, address, uint256) external returns (bool);

/// @audit Parameter of type 'int256' at index '0'
16:     function latestAnswer() external view returns (int256); 
/// @audit Parameter of type 'uint8' at index '0'
17:     function decimals() external view returns (uint8);

/// @audit Parameter of type 'address' at index '0'
21:     function asset() external view returns (address); 
/// @audit Parameter of type 'address' at index '0'
22:     function oracle() external view returns (address);
/// @audit Parameter of type 'uint256' at index '0'
23:     function getUpdatedIndex() external view returns (uint256);

/// @audit Parameter of type 'string' at index '0'
27:     function name() external view returns (string memory); 
/// @audit Parameter of type 'uint256' at index '0'
28:     function rate(uint256 shares) external view returns (uint256);

/// @audit Parameter of type 'address' at index '0'
47:     function getPool() external view returns (address); 
/// @audit Parameter of type 'struct IInvestor.Strategy' at index '0'
48:     function getStrategy(uint256 id) external view returns (Strategy memory);
/// @audit Parameter of type 'struct IInvestor.Position' at index '0'
49:     function getPosition(uint256 id) external view returns (Position memory);
/// @audit Parameter of type 'uint256' at index '0'
50:     function life(uint256 id) external view returns (uint256);
/// @audit Parameter of type 'uint256' at index '0'
51:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external returns (uint256);

/// @audit Parameter of type 'bool' at index '0'
56:     function check(address) external view returns (bool); 

/// @audit Parameter of type 'bytes4' at index '0'
60:     function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4); 

114:     function ownerOf(uint256 id) public view returns (address owner) { 
115:         require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");
116:     }

/// @audit Parameter of type 'uint256' at index '0'
118:     function balanceOf(address owner) public view returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
123:     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) { 

127:     function tokensOfOwner(address owner, uint256 start, uint256 end) external view returns (uint256[] memory v) { 
128:         v = new uint256[](end-start);
129:         for (uint256 i = start; i < end; i++) {
130:             v[i - start] = _ownerIds[owner].values[i];
131:         }
132:     }

/// @audit Parameter of type 'bool' at index '0'
208:     function supportsInterface(bytes4 interfaceId) public pure returns (bool) { 

/// @audit Parameter of type 'uint256' at index '0'
214:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow, address to) public returns (uint256) { 

/// @audit Parameter of type 'string' at index '0'
272:     function tokenURI(uint256 id) public view returns (string memory) { 

/// @audit Parameter of type 'string' at index '0'
293:     function generateImage(uint256 id) private view returns (string memory) { 

/// @audit Parameter of type 'string' at index '0'
309:     function generateHeader(uint256 id) private view returns (string memory) { 

/// @audit Parameter of type 'string' at index '0'
323:     function generateLabelVal(uint256 id) private view returns (string memory) { 

/// @audit Parameter of type 'string' at index '0'
339:     function generateLabelBor(uint256 id) private view returns (string memory) { 

/// @audit Parameter of type 'string' at index '0'
359:     function generateLabelLif(uint256 id) private view returns (string memory) { 

/// @audit Parameter of type 'string' at index '0'
374:     function formatNumber(uint256 n, uint256 d, uint256 f) internal pure returns (string memory) { 
```


```solidity
📁 File: Store.sol

/// @audit Parameter of type 'uint256' at index '0'
44:     function getUint(bytes32 key) external view returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
47:     function setUint(bytes32 key, uint256 value) external auth returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
51:     function setUintDelta(bytes32 key, int256 value) external auth returns (uint256) { 

/// @audit Parameter of type 'int256' at index '0'
62:     function getInt(bytes32 key) external view returns (int256) { 

/// @audit Parameter of type 'int256' at index '0'
65:     function setInt(bytes32 key, int256 value) external auth returns (int256) { 

/// @audit Parameter of type 'int256' at index '0'
69:     function setIntDelta(bytes32 key, int256 value) external auth returns (int256) { 

/// @audit Parameter of type 'address' at index '0'
77:     function getAddress(bytes32 key) external view returns (address) { 

/// @audit Parameter of type 'address' at index '0'
80:     function setAddress(bytes32 key, address value) external auth returns (address) { 

/// @audit Parameter of type 'bool' at index '0'
87:     function getBool(bytes32 key) external view returns (bool) { 

/// @audit Parameter of type 'bool' at index '0'
90:     function setBool(bytes32 key, bool value) external auth returns (bool) { 

/// @audit Parameter of type 'string' at index '0'
97:     function getString(bytes32 key) external view returns (string memory) { 

/// @audit Parameter of type 'string' at index '0'
100:     function setString(bytes32 key, string memory value) external auth returns (string memory) { 

/// @audit Parameter of type 'bytes32' at index '0'
107:     function getBytes32(bytes32 key) external view returns (bytes32) { 

/// @audit Parameter of type 'bytes32' at index '0'
110:     function setBytes32(bytes32 key, bytes32 value) external auth returns (bytes32) { 

/// @audit Parameter of type 'bytes32[]' at index '0'
118:     function getBytes32Array(bytes32 key) external view returns (bytes32[] memory) { 

/// @audit Parameter of type 'bool' at index '0'
128:     function containsBytes32(bytes32 key, bytes32 value) external view returns (bool) { 

/// @audit Parameter of type 'uint256' at index '0'
131:     function getBytes32Count(bytes32 key) external view returns (uint256) { 

134:     function getBytes32ValuesAt(bytes32 key, uint256 start, uint256 end) external view returns (bytes32[] memory v) { 
135:         v = new bytes32[](end-start);
136:         for (uint256 i = start; i < end; i++) {
137:             v[i - start] = bytes32Sets[key].values[i];
138:         }
139:     }
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit Parameter of type 'uint256' at index '0'
141:     function mint(uint256 amount) external auth loop returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
170:     function burn(uint256 shares) external auth loop returns (uint256) { 

/// @audit Parameter of type 'bytes' at index '0'
193:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit Parameter of type 'uint256' at index '0'
293:     function rate(uint256 shares) public view returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
/// @audit Parameter of type 'uint256' at index '1'
297:     function quoteAddLiquidity(uint256 amt, address trgtAst, bytes memory path) private returns (uint256, uint256) { 

320:     function quoteAndSwap(address trgtAst, uint256 amt, uint256 slp) private returns (uint256 amt0, uint256 amt1) { 
321:         bytes memory path = pathToLp;
322:         (uint256 toLp0, uint256 toLp1) = quoteAddLiquidity(amt, trgtAst, path);
323:         address token0 = address(hypervisor.token0());
324: 
325:         if (trgtAst == token0) {
326:             uint256 before = hypervisor.token1().balanceOf(address(this));
327:             swap(trgtAst, address(hypervisor.token1()), path, toLp1, slp);
328:             amt0 = toLp0;
329:             amt1 = hypervisor.token1().balanceOf(address(this)) - before;
330:         } else {
331:             uint256 before = hypervisor.token0().balanceOf(address(this));
332:             swap(trgtAst, token0, path, toLp0, slp);
333:             amt0 = hypervisor.token0().balanceOf(address(this)) - before;
334:             amt1 = toLp1;
335:         }
336:     }

/// @audit Parameter of type 'uint256' at index '0'
344:     function valueLiquidity() private view returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
370:     function totalManagedAssets() private view returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
/// @audit Parameter of type 'uint256' at index '1'
376:     function getPosition(uint160 midX96, int24 minTick, int24 maxTick) private view returns (uint256, uint256) { 

/// @audit Parameter of type 'bytes4' at index '0'
390:     function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external returns (bytes4) { 

/// @audit Parameter of type 'bool' at index '0'
397:     function onNFTHarvest(address, address, uint256, uint256, uint256) public pure returns (bool) { 

/// @audit Parameter of type 'bool' at index '0'
401:     function onNFTAddToPosition(address, uint256, uint256) public pure returns (bool) { 

/// @audit Parameter of type 'bool' at index '0'
405:     function onNFTWithdraw(address, uint256, uint256) public pure returns (bool) { 

/// @audit Parameter of type 'uint256' at index '0'
409:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

/// @audit Parameter of type 'string' at index '0'
415:     function symbol() external view returns (string memory); 
/// @audit Parameter of type 'uint256' at index '0'
416:     function balanceOf(address) external view returns (uint256);

/// @audit Parameter of type 'uint256' at index '0'
423:     function value(address, uint256) external view returns (uint256); 
/// @audit Parameter of type 'uint256' at index '0'
424:     function convert(address, address, uint256) external view returns (uint256);
/// @audit Parameter of type 'uint256' at index '0'
425:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares); 
434:     function getDepositAmount(address pos, address token, uint256 deposit) external view returns (uint256 amountStart, uint256 amountEnd);

438:     function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut); 

442:     function withdraw(uint256 shares, address to, address from, uint256[4] memory minAmounts) external returns (uint256 amount0, uint256 amount1); 
/// @audit Parameter of type 'contract IAlgebraPool' at index '0'
443:     function pool() external view returns (IAlgebraPool);
/// @audit Parameter of type 'contract IERC20' at index '0'
444:     function token0() external view returns (IERC20);
/// @audit Parameter of type 'contract IERC20' at index '0'
445:     function token1() external view returns (IERC20);
/// @audit Parameter of type 'uint256' at index '0'
446:     function totalSupply() external view returns (uint256);
/// @audit Parameter of type 'int24' at index '0'
447:     function baseLower() external view returns (int24);
/// @audit Parameter of type 'int24' at index '0'
448:     function baseUpper() external view returns (int24);
/// @audit Parameter of type 'int24' at index '0'
449:     function limitLower() external view returns (int24);
/// @audit Parameter of type 'int24' at index '0'
450:     function limitUpper() external view returns (int24);

459:     function getStakingPosition(uint256 tokenId) external view returns ( 
460:         uint256 amount, uint256 amountWithMultiplier, uint256 startLockTime,
461:         uint256 lockDuration, uint256 lockMultiplier, uint256 rewardDebt,
462:         uint256 boostPoints, uint256 totalMultiplier
463:     );

/// @audit Parameter of type 'address' at index '0'
472:     function token0() external view returns (address); 
/// @audit Parameter of type 'address' at index '0'
473:     function token1() external view returns (address);
474:     function getTimepoints(uint32[] calldata secondsAgos) external view returns (
475:         int56[] memory tickCumulatives,
476:         uint160[] memory secondsPerLiquidityCumulatives,
477:         uint112[] memory volatilityCumulatives,
478:         uint256[] memory volumePerAvgLiquiditys
479:     );
480:     function positions(bytes32 key) external view returns (
481:         uint128 liquidityAmount,
482:         uint32 lastLiquidityAddTimestamp,
483:         uint256 innerFeeGrowth0Token,
484:         uint256 innerFeeGrowth1Token,
485:         uint128 fees0,
486:         uint128 fees1
487:     );
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit Parameter of type 'uint256' at index '0'
143:     function mint(uint256 amount) external auth loop returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
159:     function burn(uint256 shares) external auth loop returns (uint256) { 

/// @audit Parameter of type 'bytes' at index '0'
171:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit Parameter of type 'uint256' at index '0'
294:     function rate(uint256 shares) public view returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
304:     function marketTokenPrice(bool isDeposit) public view returns (uint256) { 

/// @audit Parameter of type 'struct IPrice.Props' at index '0'
325:     function gmxPrice(address token, bool isIndex) internal view returns (IPrice.Props memory) { 

/// @audit Parameter of type 'uint256' at index '0'
358:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

/// @audit Parameter of type 'string' at index '0'
364:     function symbol() external view returns (string memory); 
/// @audit Parameter of type 'uint8' at index '0'
365:     function decimals() external view returns (uint8);
/// @audit Parameter of type 'uint256' at index '0'
366:     function balanceOf(address) external view returns (uint256);

/// @audit Parameter of type 'uint256' at index '0'
373:     function price(address) external view returns (uint256); 
/// @audit Parameter of type 'uint256' at index '0'
374:     function value(address, uint256) external view returns (uint256);
/// @audit Parameter of type 'uint256' at index '0'
375:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

/// @audit Parameter of type 'address' at index '0'
379:     function depositVault() external view returns (address); 
/// @audit Parameter of type 'address' at index '0'
380:     function withdrawalVault() external view returns (address);

384:     function latestRoundData() external view returns ( 
385:         uint80 roundId,
386:         int256 answer,
387:         uint256 startedAt,
388:         uint256 updatedAt,
389:         uint80 answeredInRound
390:     );

/// @audit Parameter of type 'uint256' at index '0'
394:     function getUint(bytes32 key) external view returns (uint256); 
/// @audit Parameter of type 'address' at index '0'
395:     function getAddress(bytes32 key) external view returns (address);
/// @audit Parameter of type 'bytes32' at index '0'
396:     function getBytes32(bytes32 key) external view returns (bytes32);

/// @audit Parameter of type 'bytes32' at index '0'
431:     function createDeposit(CreateDepositParams calldata params) external payable returns (bytes32); 
/// @audit Parameter of type 'bytes32' at index '0'
432:     function createWithdrawal(CreateWithdrawalParams calldata params) external payable returns (bytes32);
433:     function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);
/// @audit Parameter of type 'address' at index '0'
434:     function router() external returns (address);

/// @audit Parameter of type 'struct IMarket.Props' at index '0'
478:     function getMarket(address dataStore, address key) external view returns (IMarket.Props memory); 
479:     function getMarketTokenPrice(

488:     function getWithdrawalAmountOut( 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit Parameter of type 'uint256' at index '0'
72:     function rate(uint256 sha) public view returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
90:     function mint(uint256 amount) public auth loop returns (uint256) {  

/// @audit Parameter of type 'uint256' at index '0'
117:     function burn(uint256 shares) public auth loop returns (uint256) { 

/// @audit Parameter of type 'bytes' at index '0'
141:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit Parameter of type 'uint256' at index '0'
177:     function totalManagedAssets() public view returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
196:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
201:     function sqrt(uint256 a) internal pure returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
216:     function log2(uint256 value) internal pure returns (uint256) { 

/// @audit Parameter of type 'string' at index '0'
254:     function symbol() external view returns (string memory); 
/// @audit Parameter of type 'uint8' at index '0'
255:     function decimals() external view returns (uint8);
/// @audit Parameter of type 'uint256' at index '0'
256:     function balanceOf(address) external view returns (uint256);
/// @audit Parameter of type 'bool' at index '0'
257:     function approve(address, uint256) external returns (bool);
/// @audit Parameter of type 'bool' at index '0'
258:     function transfer(address, uint256) external returns (bool);
/// @audit Parameter of type 'bool' at index '0'
259:     function transferFrom(address, address, uint256) external returns (bool);

/// @audit Parameter of type 'uint256' at index '0'
263:     function price(address) external view returns (uint256); 
/// @audit Parameter of type 'uint256' at index '0'
264:     function value(address, uint256) external view returns (uint256);
/// @audit Parameter of type 'uint256' at index '0'
265:     function swap(address ast0, address ast1, uint256 amt, uint256 slp, address to) external returns (uint256);

/// @audit Parameter of type 'address' at index '0'
269:     function token0() external view returns (address); 
/// @audit Parameter of type 'address' at index '0'
270:     function token1() external view returns (address);
/// @audit Parameter of type 'uint256' at index '0'
271:     function totalSupply() external view returns (uint256);
/// @audit Parameter of type 'uint112' at index '0'
/// @audit Parameter of type 'uint112' at index '1'
/// @audit Parameter of type 'uint32' at index '2'
272:     function getReserves() external view returns (uint112, uint112, uint32);
/// @audit Parameter of type 'uint256' at index '0'
273:     function price0CumulativeLast() external view returns (uint256);
/// @audit Parameter of type 'uint256' at index '0'
274:     function price1CumulativeLast() external view returns (uint256);
275:     function mint(address) external returns (uint256 liquidity);
276:     function burn(address) external returns (uint256 amount0, uint256 amount1);

/// @audit Parameter of type 'address' at index '0'
282:     function SUSHI() external view returns (address); 
/// @audit Parameter of type 'address' at index '0'
283:     function lpToken(uint256) external view returns (address);
/// @audit Parameter of type 'uint256' at index '0'
284:     function pendingSushi(uint256, address) external view returns (uint256);
/// @audit Parameter of type 'uint256' at index '0'
/// @audit Parameter of type 'int256' at index '1'
285:     function userInfo(uint256, address) external view returns (uint256, int256);
```


```solidity
📁 File: UtilFarmingBalances.sol

/// @audit Parameter of type 'uint256' at index '0'
5:     function nextPosition() external view returns (uint256); 
/// @audit Parameter of type 'address' at index '0'
/// @audit Parameter of type 'address' at index '1'
/// @audit Parameter of type 'uint256' at index '2'
/// @audit Parameter of type 'uint256' at index '3'
/// @audit Parameter of type 'uint256' at index '4'
/// @audit Parameter of type 'uint256' at index '5'
/// @audit Parameter of type 'uint256' at index '6'
6:     function positions(uint256) external view returns (address, address, uint256, uint256, uint256, uint256, uint256);

/// @audit Parameter of type 'address' at index '0'
10:     function ownerOf(uint256) external view returns (address); 

/// @audit Parameter of type 'address[]' at index '0'
/// @audit Parameter of type 'uint256[]' at index '1'
14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) { 
```


```solidity
📁 File: Whitelist.sol

/// @audit Parameter of type 'bool' at index '0'
42:     function check(address user) external view returns (bool) { 
```


</details>


---
### [GAS&#x2011;41] Optimize Deployment Size by Fine-tuning IPFS Hash
The Solidity compiler appends 53 bytes of metadata to the smart contract code, incurring an extra cost of 10,600 gas. This additional expense arises from 200 gas per bytecode, plus calldata cost, which amounts to 16 gas for non-zero bytes and 4 gas for zero bytes. This results in a maximum of 848 extra gas in calldata cost.

Reducing this cost is crucial for the following reasons:

The metadata's 53-byte addition leads to a deployment cost increase of 10,600 gas.
It can also result in an additional calldata cost of up to 848 gas.
Ways to Minimize Gas Consumption:

Employ the `--no-cbor-metadata` compiler option to exclude metadata. Be cautious as this might impact contract verification.
Search for code comments that yield an IPFS hash with more zeros, thereby reducing calldata costs.


Gas saved per Instance: ~10,600 *(Total: ~116,600)*
<details>
<summary><i>There are 11 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: Helper.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: Investor.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: InvestorStrategyProxy.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: PositionManager.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: AGPL-3.0-only 
```


```solidity
📁 File: Store.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: UtilFarmingBalances.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: Whitelist.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```


</details>


---
### [GAS&#x2011;42] Optimize Ether deposits using the `receive()` function
Consider using receive() function instead of a specific deposit() (or similar) function. If there are several functions in the contract that can receive Ether, it is recommended to use receive() for the most frequently used function. The receive() or fallback() function can handle incoming Ether transfers directly, providing more gas-efficient way to manage deposits.
> ❗ Issue is removed from: (sxima, sme6en)


Gas saved per Instance: ~45 *(Total: ~135)*
<details>
<summary><i>There are 3 instances of this issue:</i></summary>

```solidity
📁 File: StrategyCamelotV3.sol

228:     function earn() external payable loop { 
```


```solidity
📁 File: StrategyGMXGM.sol

184:     function earn() external payable loop { 
```


```solidity
📁 File: StrategySushiswap.sol

153:     function earn() public payable loop { 
```


</details>


---
### [GAS&#x2011;43] Order of checks in a function can be optimized
Some of the checks below involve expensive operations, such as SLOAD or external calls. Reorder them so that the validations with expensive operations are prevented from being executed if the initial checks fail.
> ❗ Issue is removed from: (sxima, sme6en)


Gas saved per Instance: ~2,100 *(Total: ~14,700)*
<details>
<summary><i>There are 7 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @audit Gas efficient order: 2,1
/// @audit  1
55:         require(msg.sender == address(lender), "!lender"); 
/// @audit  2
56:         require(initiator == address(this), "!me");
```


```solidity
📁 File: Investor.sol

/// @audit Gas efficient order: 4,1,2,3
/// @audit  1
265:         if (collateralCap == 0) revert UnknownCollateral(); 
/// @audit  2
266:         if (IERC20(token).balanceOf(store.getAddress(BANK)) + collateral > collateralCap) {
267:             revert CollateralOverCap();
268:         }
269: 
270:         Position memory p;
271:         p.owner = msg.sender;
272:         p.start = block.timestamp;
273:         p.strategy = strategy;
274:         p.token = token;
275:         p.collateral = collateral;
276: 
277:         {
278:             if (si.totalShares() == 0) revert StrategyUninitialized();
279:             IPool pool = IPool(store.getAddress(POOL));
280:             address poolAsset = pool.asset();
281:             pullToBank(token, msg.sender, collateral);
282:             p.borrow = pool.borrow(borrow);
283:             push(poolAsset, address(strategyProxy), borrow);
284:             p.shares = strategyProxy.mint(address(si), borrow);
285:             p.basis = si.rate(p.shares);
286:         }
287: 
/// @audit  3
288:         if (_life(p) < 1e18) revert Undercollateralized();
/// @audit  4
289:         if (si.rate(si.totalShares()) > s.cap) revert StrategyOverCap();

/// @audit Gas efficient order: 1,5,3,4,2
/// @audit  1
303:         if (p.owner != msg.sender) revert NotOwner(); 
/// @audit  2
304:         if (borrow < 0 && uint256(-borrow) > p.shares) revert InvalidParameters();
/// @audit  3
305:         if (borrow > 0 && p.shares == 0) revert InvalidParameters();
/// @audit  4
306:         if (collateral < 0 && uint256(-collateral) > p.collateral) revert InvalidParameters();
/// @audit  5
307:         if (lastBlock[id] == block.number) revert NoEditingInSameBlock();

/// @audit Gas efficient order: 2,1
/// @audit  1
382:         if (_life(p) < 1e18) revert Undercollateralized(); 
/// @audit  2
383:         if (borrow > 0 && si.rate(si.totalShares()) > s.cap) revert StrategyOverCap();

/// @audit Gas efficient order: 3,2,1
/// @audit  1
402:         if (_life(p) >= 1e18) revert PositionNotLiquidatable(); 
/// @audit  2
403:         if (store.getUint(STATUS) < STATUS_LIQUIDATE || s.status < STATUS_LIQUIDATE) revert WrongStatus();
/// @audit  3
404:         if (lastBlock[id] == block.number) revert NoEditingInSameBlock();
```


```solidity
📁 File: PositionManager.sol

/// @audit Gas efficient order: 3,1,2
/// @audit  1
221:         require(to != address(0), "INVALID_RECIPIENT"); 
/// @audit  2
222:         require(_ownerOf[id] == address(0), "ALREADY_MINTED");
223:         moveId(address(0), to, id);
/// @audit  3
224:         require(
225:             to.code.length == 0
226:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
227:                     == ERC721TokenReceiver.onERC721Received.selector,
228:             "UNSAFE_RECIPIENT"
229:         );
```


```solidity
📁 File: Store.sol

/// @audit Gas efficient order: 2,1
/// @audit  1
54:         if (value > 0 && next < prev) revert OverOrUnderflow(); 
/// @audit  2
55:         if (value < 0 && next > prev) revert OverOrUnderflow();
```


</details>


---
### [GAS&#x2011;44] Pre-increments/pre-decrements are cheaper than `+1`/`+=1` or `-1`/`-=1`

Gas saved per Instance: ~11 *(Total: ~33)*
<details>
<summary><i>There are 3 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

/// @audit prefer '--position'
160:             uint256 valueIndex = position-1; 
```


```solidity
📁 File: Store.sol

/// @audit prefer '--position'
151:             uint256 valueIndex = position-1; 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit prefer '++result'
247:             if (value >> 1 > 0) result += 1; 
```


</details>


---
### [GAS&#x2011;45] Prefer using `storage` instead of `memory` for state variables saves gas
When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declaring the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incurring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct


Gas saved per Instance: ~2,100 

<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyCamelotV3.sol

321:         bytes memory path = pathToLp; 
```



---
### [GAS&#x2011;46] `private` functions used once can be inlined

Gas saved per Instance: ~30 *(Total: ~180)*
<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

293:     function generateImage(uint256 id) private view returns (string memory) { 

309:     function generateHeader(uint256 id) private view returns (string memory) { 

323:     function generateLabelVal(uint256 id) private view returns (string memory) { 

339:     function generateLabelBor(uint256 id) private view returns (string memory) { 

359:     function generateLabelLif(uint256 id) private view returns (string memory) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

297:     function quoteAddLiquidity(uint256 amt, address trgtAst, bytes memory path) private returns (uint256, uint256) { 
```


</details>


---
### [GAS&#x2011;47] Refactor modifiers to call a local function
Modifiers code is copied in all instances where it's used, increasing bytecode size. By doing a refractor to the internal function, one can reduce bytecode size significantly at the cost of one `JUMP`.
> ❗ Issue is removed from: (sxima, sme6en)


Gas saved per Instance: ~600 *(Total: ~8,400)*
<details>
<summary><i>There are 14 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

21:     modifier auth() { 
```


```solidity
📁 File: Investor.sol

150:     modifier auth() { 

155:     modifier loop() { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

29:     modifier auth() { 
```


```solidity
📁 File: PositionManager.sol

96:     modifier admin() { 

134:     modifier auth(uint256 id) { 
```


```solidity
📁 File: Store.sol

30:     modifier auth() { 
```


```solidity
📁 File: StrategyCamelotV3.sol

78:     modifier loop() { 

85:     modifier auth() { 
```


```solidity
📁 File: StrategyGMXGM.sol

82:     modifier loop() { 

89:     modifier auth() { 
```


```solidity
📁 File: StrategySushiswap.sol

40:     modifier loop() { 

47:     modifier auth() { 
```


```solidity
📁 File: Whitelist.sol

18:     modifier auth() { 
```


</details>


---
### [GAS&#x2011;48] `require()` or `revert()` statements that check input arguments should be at the top of the function
Checks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (**2100 gas***) in a function that may ultimately revert in the unhappy case.

<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

56:         require(initiator == address(this), "!me"); 
```


```solidity
📁 File: PositionManager.sol

221:         require(to != address(0), "INVALID_RECIPIENT"); 
```


</details>


---
### [GAS&#x2011;49] Same cast is done multiple times
It's cheaper to do it once, and store the result to a variable. The examples below are the second+ instance of a given cast of the variable

<details>
<summary><i>There are 19 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @audit 'address(lender)' is done 2 times total in this same function
71:         asset.approve(address(lender), amount+premium); 
```


```solidity
📁 File: Investor.sol

/// @audit 'uint256(collateral)' is done 2 times total in this same function
321:             pullToBank(p.token, msg.sender, uint256(collateral)); 

/// @audit 'address(si)' is done 2 times total in this same function
332:             uint256 amount = strategyProxy.burn(address(si), uint256(-borrow)); 

/// @audit 'uint256(borrow)' is done 3 times total in this same function
365:             push(poolAsset, address(strategyProxy), uint256(borrow)); 
```


```solidity
📁 File: PositionManager.sol

/// @audit 'uint256(collateral)' is done 2 times total in this same function
236:             pull(p.token, msg.sender, uint256(collateral)); 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit 'address(asset)' is done 2 times total in this same function
148:         strategyHelper.swap(address(asset), tgtAst, amount, slp, address(this)); 

/// @audit 'address(asset)' is done 3 times total in this same function
183:         bal += strategyHelper.swap(address(hypervisor.token0()), address(asset), amt0, slp, msg.sender); 

/// @audit 'address(nitroPool)' is done 3 times total in this same function
219:         if (address(nitroPool) != address(0)) { 

/// @audit 'address(strategyHelper)' is done 3 times total in this same function
243:                 IERC20(rewardToken1).approve(address(strategyHelper), balance); 

/// @audit 'address(nitroPool)' is done 2 times total in this same function
288:         if (address(nitroPool) != address(0)) { 

/// @audit 'address(hypervisor.token0())' is done 2 times total in this same function
313:             uniProxy.getDepositAmount(address(hypervisor), address(hypervisor.token0()), out0); 

/// @audit 'address(hypervisor)' is done 2 times total in this same function
356:             address(hypervisor.token0()), bas0 + lim0 + hypervisor.token0().balanceOf(address(hypervisor)) 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit 'address(strategyHelper)' is done 2 times total in this same function
195:             IERC20(tokenLong).approve(address(strategyHelper), bal); 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit 'address(asset)' is done 2 times total in this same function
100:             strategyHelper.swap(address(asset), address(tok0), haf, slp, address(this)); 

/// @audit 'address(pair)' is done 4 times total in this same function
102:             IERC20(tok0).transfer(address(pair), tok0.balanceOf(address(this))); 

/// @audit 'address(strategyHelper)' is done 2 times total in this same function
130:         tok0.approve(address(strategyHelper), bal0); 

/// @audit 'address(asset)' is done 2 times total in this same function
132:         uint256 amt0 = strategyHelper.swap(address(tok0), address(asset), bal0, slp, msg.sender); 

/// @audit 'address(rew)' is done 3 times total in this same function
164:         strategyHelper.swap(address(rew), pair.token0(), haf, slippage, address(this)); 

/// @audit 'address(pair)' is done 4 times total in this same function
166:         IERC20(pair.token0()).transfer(address(pair), IERC20(pair.token0()).balanceOf(address(this))); 
```


</details>


---
### [GAS&#x2011;50] Shortcircuit rules can be be used to optimize some gas usage
Some conditions may be reordered to save an `SLOAD` (2100 gas), as we avoid reading state variables when the first part of the condition fails (with `&&`), or succeeds (with `||`).


Gas saved per Instance: ~2,100 *(Total: ~10,500)*
<details>
<summary><i>There are 5 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

304:         if (borrow < 0 && uint256(-borrow) > p.shares) revert InvalidParameters(); 
305:         if (borrow > 0 && p.shares == 0) revert InvalidParameters();
306:         if (collateral < 0 && uint256(-collateral) > p.collateral) revert InvalidParameters();

383:         if (borrow > 0 && si.rate(si.totalShares()) > s.cap) revert StrategyOverCap(); 
```


```solidity
📁 File: StrategyCamelotV3.sol

208:         if (tokenId != 0 && totalManagedAssets() > 0) { 
```


</details>


---
### [GAS&#x2011;51] Simple checks for zero can be done using assembly to save gas

Gas saved per Instance: ~6 *(Total: ~456)*
<details>
<summary><i>There are 76 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

36:         if (amount == 0) return; 

42:         if (amount == 0) return; 
```


```solidity
📁 File: Investor.sol

163:         if (what == "exec") { 

165:         } else if (what == "whitelist") { 

167:         } else if (what == "helper") { 

171:             if (helper.price(poolAsset) == 0) revert InvalidFile(); 
172:         } else if (what == "strategyProxy") {

175:         } else if (what == "bank") { 

178:         } else if (what == "pool") { 

181:             if (IPool(data).asset() == address(0)) revert InvalidFile(); 

189:         if (what == "slippage") { 

192:         } else if (what == "performanceFee") { 

195:         } else if (what == "killCollateralPadding") { 

198:         } else if (what == "closeCollateralPadding") { 

201:         } else if (what == "status") { 
202:             if (data == 0 || data > 4) revert InvalidFile();

211:         if (store.getAddress(keccak256(abi.encode(index, STRATEGIES_ADDRESS))) != address(0)) { 

256:         if (address(whitelist) != address(0)) { 

265:         if (collateralCap == 0) revert UnknownCollateral(); 

278:             if (si.totalShares() == 0) revert StrategyUninitialized(); 

305:         if (borrow > 0 && p.shares == 0) revert InvalidParameters(); 

330:         if (borrow < 0) { 

338:             if (p.shares == 0) { 

361:         if (borrow > 0) { 
362:             if (si.totalShares() == 0) revert StrategyUninitialized();
363:             if (p.shares == 0) revert StrategyClosed();

452:         if (p.borrow == 0) return 1e18; 

492:         if (s.implementation == address(0)) revert UnknownStrategy(); 

500:         if (amount == 0) return; 

507:         if (amount == 0) return; 
```


```solidity
📁 File: PositionManager.sol

115:         require((owner = _ownerOf[id]) != address(0), "NOT_MINTED"); 

119:         require(owner != address(0), "ZERO_ADDRESS"); 

156:         if (from != address(0)) { 

170:         if (to != address(0)) { 

184:         require(to != address(0), "INVALID_RECIPIENT"); 

190:         require( 
191:             to.code.length == 0
192:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "")
193:                     == ERC721TokenReceiver.onERC721Received.selector,
194:             "UNSAFE_RECIPIENT"
195:         );

200:         require( 
201:             to.code.length == 0
202:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)
203:                     == ERC721TokenReceiver.onERC721Received.selector,
204:             "UNSAFE_RECIPIENT"
205:         );

215:         if (address(whitelist) != address(0)) { 

221:         require(to != address(0), "INVALID_RECIPIENT"); 
222:         require(_ownerOf[id] == address(0), "ALREADY_MINTED");

224:         require( 
225:             to.code.length == 0
226:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
227:                     == ERC721TokenReceiver.onERC721Received.selector,
228:             "UNSAFE_RECIPIENT"
229:         );

246:         require(p.collateral == 0, "NOT_CLOSED"); 

248:         require(owner != address(0), "NOT_MINTED"); 

254:         require(owner != address(0), "NOT_MINTED"); 
```


```solidity
📁 File: Store.sol

142:         if (s.positions[value] == 0) { 

150:         if (position != 0) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

124:         if (tokenId == 0) revert TokenIdNeededFirst(); 
125:         if (_nitroPool == address(0)) {

208:         if (tokenId != 0 && totalManagedAssets() > 0) { 

213:             if (tokenId != 0) tokenId = 0; 

219:         if (address(nitroPool) != address(0)) { 

223:         if (address(nitroPool) != address(0)) { 

232:         if (tokenId == 0) return; 

236:         if (address(nitroPool) != address(0)) { 

240:         if (rewardToken1 != address(0)) { 

248:         if (rewardToken2 != address(0)) { 

256:         if (rewardToken3 != address(0)) { 

277:         if (tokenId == 0) return; 
278:         if (address(nitroPool) != address(0)) {

288:         if (address(nitroPool) != address(0)) { 

371:         if (tokenId == 0) return 0; 

391:         if (msg.sender == address(nftPool) && tokenId == 0) { 
```


```solidity
📁 File: StrategyGMXGM.sol

188:         if (amountPendingDeposit != 0 || amountPendingWithdraw != 0) { 

284:         if (amountPendingDeposit != 0 || amountPendingWithdraw != 0) { 

327:         if (decimals == 0) { 
```


```solidity
📁 File: StrategySushiswap.sol

73:         if (sha == 0 || totalShares == 0) return 0; 

187:         require(totalShares == 0, "ts=0"); 

202:         if (a == 0) return 0; 
```


</details>


---
### [GAS&#x2011;52] Sort Solidity operations using short-circuit mode
In Solidity, boolean expressions utilize short-circuiting. For || (logical OR) operations, the second expression is evaluated only if the first one is false. Similarly, for && (logical AND) operations, the second expression is evaluated only if the first one is true. This optimization saves gas by avoiding unnecessary evaluations. For instance, in require(msg.sender == owner || msg.sender == manager), if msg.sender == owner evaluates to true, msg.sender == manager isn't checked. It's recommended to place the less expensive expression first to optimize gas usage.

<details>
<summary><i>There are 35 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

/// @audit Lines: 202 
188:     function file(bytes32 what, uint256 data) external auth { 
189:         if (what == "slippage") {
190:             if (data > 1e18) revert InvalidFile();
191:             slippage = data;
192:         } else if (what == "performanceFee") {
193:             if (data > 5000) revert InvalidFile();
194:             performanceFee = data;
195:         } else if (what == "killCollateralPadding") {
196:             if (data > 1e18) revert InvalidFile();
197:             killCollateralPadding = data;
198:         } else if (what == "closeCollateralPadding") {
199:             if (data > 1e18) revert InvalidFile();
200:             closeCollateralPadding = data;
201:         } else if (what == "status") {
202:             if (data == 0 || data > 4) revert InvalidFile();
203:             store.setUint(STATUS, data);
204:         } else {
205:             revert InvalidFile();
206:         }
207:         emit File(what, data);
208:     }

/// @audit Lines: 263 to 266
255:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external loop returns (uint256) { 
256:         if (address(whitelist) != address(0)) {
257:             if (!whitelist.check(msg.sender)) revert NotWhitelisted();
258:         }
259:         uint256 id = store.setUintDelta(POSITIONS, 1);
260:         lastBlock[id] = block.number;
261:         Strategy memory s = getStrategy(strategy);
262:         IStrategy si = IStrategy(s.implementation);
263:         if (store.getUint(STATUS) < STATUS_LIVE || s.status < STATUS_LIVE) revert WrongStatus();
264:         uint256 collateralCap = store.getUint(keccak256(abi.encode(token, COLLATERAL_CAP)));
265:         if (collateralCap == 0) revert UnknownCollateral();
266:         if (IERC20(token).balanceOf(store.getAddress(BANK)) + collateral > collateralCap) {
267:             revert CollateralOverCap();
268:         }
269: 
270:         Position memory p;
271:         p.owner = msg.sender;
272:         p.start = block.timestamp;
273:         p.strategy = strategy;
274:         p.token = token;
275:         p.collateral = collateral;
276: 
277:         {
278:             if (si.totalShares() == 0) revert StrategyUninitialized();
279:             IPool pool = IPool(store.getAddress(POOL));
280:             address poolAsset = pool.asset();
281:             pullToBank(token, msg.sender, collateral);
282:             p.borrow = pool.borrow(borrow);
283:             push(poolAsset, address(strategyProxy), borrow);
284:             p.shares = strategyProxy.mint(address(si), borrow);
285:             p.basis = si.rate(p.shares);
286:         }
287: 
288:         if (_life(p) < 1e18) revert Undercollateralized();
289:         if (si.rate(si.totalShares()) > s.cap) revert StrategyOverCap();
290:         setPosition(id, p);
291:         emit Open(id, borrow, collateral, strategy, token);
292:         return id;
293:     }

/// @audit Lines: 304 to 306
/// @audit Lines: 305 to 307
/// @audit Lines: 306 to 309
/// @audit Lines: 383 to 386
/// @audit Lines: 311 to 314
/// @audit Lines: 311 to 314
/// @audit Lines: 314 to 317
/// @audit Lines: 314 to 317
295:     function edit(uint256 id, int256 borrow, int256 collateral) external loop { 
296:         IBank bank = IBank(store.getAddress(BANK));
297:         IPool pool = IPool(store.getAddress(POOL));
298:         int256 collateralAdjusted = collateral;
299:         address poolAsset = pool.asset();
300:         Position memory p = getPosition(id);
301:         Strategy memory s = getStrategy(p.strategy); 
302:         IStrategy si = IStrategy(s.implementation);
303:         if (p.owner != msg.sender) revert NotOwner();
304:         if (borrow < 0 && uint256(-borrow) > p.shares) revert InvalidParameters();
305:         if (borrow > 0 && p.shares == 0) revert InvalidParameters();
306:         if (collateral < 0 && uint256(-collateral) > p.collateral) revert InvalidParameters();
307:         if (lastBlock[id] == block.number) revert NoEditingInSameBlock();
308:         lastBlock[id] = block.number;
309:         {
310:             uint256 status = store.getUint(STATUS);
311:             if (borrow > 0 && (status < STATUS_LIVE || s.status < STATUS_LIVE)) {
312:                 revert WrongStatus();
313:             }
314:             if (borrow <= 0 && (status < STATUS_WITHDRAW || s.status < STATUS_WITHDRAW)) {
315:                 revert WrongStatus();
316:             }
317:         }
318: 
319:         // 1. Adjust collateral
320:         if (collateral > 0) {
321:             pullToBank(p.token, msg.sender, uint256(collateral));
322:             p.collateral = p.collateral + uint256(collateral);
323:             uint256 collateralCap = store.getUint(keccak256(abi.encode(p.token, COLLATERAL_CAP)));
324:             if (IERC20(p.token).balanceOf(store.getAddress(BANK)) > collateralCap) {
325:                 revert CollateralOverCap();
326:             }
327:         }
328: 
329:         // 2. Sell strategy shares to repay loan
330:         if (borrow < 0) {
331:             p.basis = p.basis - min(p.basis, si.rate(uint256(-borrow)));
332:             uint256 amount = strategyProxy.burn(address(si), uint256(-borrow));
333:             p.shares = p.shares - uint256(-borrow);
334:             uint256 index = pool.getUpdatedIndex();
335:             uint256 repaying = amount * 1e18 / index;
336:             if (repaying > p.borrow) repaying = p.borrow;
337:             // If closing the position, make sure we repay the whole borrow
338:             if (p.shares == 0) {
339:                 p.basis = 0;
340:                 repaying = p.borrow;
341:                 uint256 needed = p.borrow * index / 1e18;
342:                 if (needed > amount) {
343:                     // If we don't have enough USDC from shares, sell some collateral
344:                     uint256 cAmount = helper.convert(poolAsset, p.token, needed - amount);
345:                     cAmount = cAmount * (10000 + closeCollateralPadding) / 10000;
346:                     if (cAmount > p.collateral) cAmount = p.collateral;
347:                     bank.transfer(p.token, address(this), cAmount);
348:                     IERC20(p.token).approve(address(helper), cAmount);
349:                     uint256 topup = helper.swap(p.token, poolAsset, cAmount, slippage, address(this));
350:                     amount = amount + topup;
351:                     p.collateral = p.collateral - cAmount;
352:                 }
353:             }
354:             IERC20(poolAsset).approve(address(pool), amount);
355:             uint256 used = pool.repay(repaying);
356:             p.borrow = p.borrow - repaying;
357:             push(poolAsset, msg.sender, (amount - used) * (10000 - performanceFee) / 10000);
358:         }
359: 
360:         // 3. Borrow more from pool and mint strategy shares
361:         if (borrow > 0) {
362:             if (si.totalShares() == 0) revert StrategyUninitialized();
363:             if (p.shares == 0) revert StrategyClosed();
364:             p.borrow = p.borrow + pool.borrow(uint256(borrow));
365:             push(poolAsset, address(strategyProxy), uint256(borrow));
366:             uint256 shares = strategyProxy.mint(address(si), uint256(borrow));
367:             p.shares = p.shares + shares;
368:             p.basis = p.basis + si.rate(shares);
369:         }
370: 
371:         // 4. Withdraw collateral asked for
372:         if (collateral < 0) {
373:             uint256 amt = uint256(-collateral);
374:             // Allow a user to ask for all it's collateral but support some being taken away
375:             // as topup for the repayment of the debt
376:             if (amt > p.collateral) amt = p.collateral;
377:             collateralAdjusted = -int256(amt);
378:             p.collateral = p.collateral - amt;
379:             bank.transfer(p.token, msg.sender, amt);
380:         }
381: 
382:         if (_life(p) < 1e18) revert Undercollateralized();
383:         if (borrow > 0 && si.rate(si.totalShares()) > s.cap) revert StrategyOverCap();
384:         setPosition(id, p);
385:         emit Edit(id, borrow, collateralAdjusted);
386:     }

/// @audit Lines: 403 to 406
396:     function kill(uint256 id) external loop returns (address, bytes memory) { 
397:         IBank bank = IBank(store.getAddress(BANK));
398:         IPool pool = IPool(store.getAddress(POOL));
399:         Position memory p = getPosition(id);
400:         Strategy memory s = getStrategy(p.strategy); 
401:         address poolAsset = pool.asset();
402:         if (_life(p) >= 1e18) revert PositionNotLiquidatable();
403:         if (store.getUint(STATUS) < STATUS_LIQUIDATE || s.status < STATUS_LIQUIDATE) revert WrongStatus();
404:         if (lastBlock[id] == block.number) revert NoEditingInSameBlock();
405:         lastBlock[id] = block.number;
406: 
407:         // Repay borrow using liquidator funds
408:         uint256 borrow = p.borrow * pool.getUpdatedIndex() / 1e18;
409:         uint256 fee = borrow * killCollateralPadding / 10000 / 2;
410:         IERC20(poolAsset).transferFrom(msg.sender, address(this), borrow + fee);
411:         IERC20(poolAsset).approve(address(pool), borrow);
412:         pool.repay(p.borrow);
413: 
414:         uint256 amount = IStrategy(s.implementation).rate(p.shares);
415:         uint256 shares;
416:         uint256 collat;
417:         {
418:             // Transfer collateral to liquidator
419:             uint256 target = helper.value(poolAsset, borrow + (fee * 2));
420:             if (amount < target) {
421:                 // Only use collateral if needed, some "in profit" position
422:                 // could be liquidatable if "expired/forced to exit"
423:                 collat = (target - amount) * 1e18 / helper.price(p.token);
424:                 if (collat > p.collateral) collat = p.collateral;
425:                 bank.transfer(p.token, msg.sender, collat);
426:             }
427: 
428:             // Transfer underlying to liquidator
429:             // scale shares to target. when just repaying borrow on an in
430:             // profit position, we don't want to use all shares
431:             shares = p.shares * target / amount;
432:             if (shares > p.shares) shares = p.shares;
433:         }
434:         bytes memory data = strategyProxy.kill(s.implementation, shares, msg.sender);
435: 
436:         // Update state
437:         p.collateral = p.collateral - collat;
438:         p.shares = p.shares - shares;
439:         p.borrow = 0;
440:         setPosition(id, p);
441: 
442:         emit Kill(id, borrow, amount, collat, shares, fee);
443:         return (p.token, data);
444:     }
```


```solidity
📁 File: PositionManager.sol

/// @audit Lines: 145 to 147
143:     function approve(address spender, uint256 id) public { 
144:         address owner = _ownerOf[id];
145:         require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");
146:         getApproved[id] = spender;
147:         emit Approval(owner, spender, id);
148:     }

/// @audit Lines: 136 to 139
/// @audit Lines: 136 to 139
182:     function transferFrom(address from, address to, uint256 id) public auth(id) { 
183:         require(from == _ownerOf[id], "WRONG_FROM");
184:         require(to != address(0), "INVALID_RECIPIENT");
185:         moveId(from, to, id);
186:     }

/// @audit Lines: 190 to 197
188:     function safeTransferFrom(address from, address to, uint256 id) public { 
189:         transferFrom(from, to, id);
190:         require(
191:             to.code.length == 0
192:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "")
193:                     == ERC721TokenReceiver.onERC721Received.selector,
194:             "UNSAFE_RECIPIENT"
195:         );
196:     }

/// @audit Lines: 200 to 207
198:     function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public { 
199:         transferFrom(from, to, id);
200:         require(
201:             to.code.length == 0
202:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)
203:                     == ERC721TokenReceiver.onERC721Received.selector,
204:             "UNSAFE_RECIPIENT"
205:         );
206:     }

/// @audit Lines: 224 to 231
214:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow, address to) public returns (uint256) { 
215:         if (address(whitelist) != address(0)) {
216:             if (!whitelist.check(msg.sender)) revert NotWhitelisted();
217:         }
218:         pull(token, msg.sender, collateral);
219:         rely(token, collateral);
220:         uint256 id = investor.open(strategy, token, collateral, borrow);
221:         require(to != address(0), "INVALID_RECIPIENT");
222:         require(_ownerOf[id] == address(0), "ALREADY_MINTED");
223:         moveId(address(0), to, id);
224:         require(
225:             to.code.length == 0
226:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
227:                     == ERC721TokenReceiver.onERC721Received.selector,
228:             "UNSAFE_RECIPIENT"
229:         );
230:         return id;
231:     }

/// @audit Lines: 136 to 139
/// @audit Lines: 136 to 139
233:     function edit(uint256 id, int256 borrow, int256 collateral) public auth(id) { 
234:         IInvestor.Position memory p = investor.getPosition(id);
235:         if (collateral > 0) {
236:             pull(p.token, msg.sender, uint256(collateral));
237:             rely(p.token, uint256(collateral));
238:         }
239:         investor.edit(id, borrow, collateral);
240:         push(p.token, msg.sender);
241:         push(IPool(investor.getPool()).asset(), msg.sender);
242:     }

/// @audit Lines: 136 to 139
/// @audit Lines: 136 to 139
244:     function burn(uint256 id) public auth(id) { 
245:         IInvestor.Position memory p = investor.getPosition(id);
246:         require(p.collateral == 0, "NOT_CLOSED");
247:         address owner = _ownerOf[id];
248:         require(owner != address(0), "NOT_MINTED");
249:         moveId(owner, address(0), id);
250:     }

/// @audit Lines: 136 to 139
/// @audit Lines: 136 to 139
252:     function forceBurn(uint256 id) public auth(id) { 
253:         address owner = _ownerOf[id];
254:         require(owner != address(0), "NOT_MINTED");
255:         moveId(owner, address(0), id);
256:     }

/// @audit Lines: 269 
266:     function push(address ast, address usr) internal { 
267:         IERC20 asset = IERC20(ast);
268:         uint256 bal = asset.balanceOf(address(this));
269:         if (bal > 0 && !asset.transfer(usr, bal)) revert TransferFailed();
270:     }
```


```solidity
📁 File: Store.sol

/// @audit Lines: 54 
/// @audit Lines: 55 
51:     function setUintDelta(bytes32 key, int256 value) external auth returns (uint256) { 
52:         uint256 prev = uintValues[key];
53:         uint256 next = uint256(int256(prev) + value);
54:         if (value > 0 && next < prev) revert OverOrUnderflow();
55:         if (value < 0 && next > prev) revert OverOrUnderflow();
56:         uintValues[key] = next;
57:         return next;
58:     }
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit Lines: 73 to 76
48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _xgrail,
52:         address _strategyHelperUniswapV3,
53:         address _uniProxy,
54:         address _quoter,
55:         address _hypervisor,
56:         address _nftPool,
57:         address _targetAsset,
58:         bytes memory _pathToLp
59:     ) {
60:         exec[msg.sender] = true;
61:         asset = IERC20(_asset);
62:         strategyHelper = IStrategyHelper(_strategyHelper);
63:         xgrail = IXGrail(_xgrail);
64:         strategyHelperUniswapV3 = IStrategyHelperUniswapV3(_strategyHelperUniswapV3);
65:         uniProxy = IUniProxy(_uniProxy);
66:         quoter = IQuoter(_quoter);
67:         hypervisor = IHypervisor(_hypervisor);
68:         nftPool = INFTPool(_nftPool);
69:         targetAsset = _targetAsset;
70:         pathToLp = _pathToLp;
71:         name = string(abi.encodePacked("Camelot V3 ", hypervisor.token0().symbol(), "/", hypervisor.token1().symbol()));
72: 
73:         if (_targetAsset != address(hypervisor.token0()) && _targetAsset != address(hypervisor.token1())) {
74:             revert WrongTargetAsset();
75:         }
76:     }

/// @audit Lines: 208 to 217
206:     function stake(uint256 amount) internal { 
207:         IERC20(address(hypervisor)).approve(address(nftPool), amount);
208:         if (tokenId != 0 && totalManagedAssets() > 0) {
209:             nftPool.addToPosition(tokenId, amount);
210:         } else {
211:             // Clear the token if it's already set from a position that
212:             // went to 0 and got burned
213:             if (tokenId != 0) tokenId = 0;
214:             nftPool.createPosition(amount, 0);
215:         }
216:     }

/// @audit Lines: 391 to 393
390:     function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external returns (bytes4) { 
391:         if (msg.sender == address(nftPool) && tokenId == 0) {
392:             tokenId = _tokenId;
393:         }
394:         return StrategyCamelotV3.onERC721Received.selector;
395:     }
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit Lines: 139 to 142
/// @audit Lines: 139 to 142
138:     function withdrawAirdrop(address token) external auth { 
139:       if (token == address(market) || token == tokenShort || token == tokenLong) revert BadToken();
140:       IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));
141:     }

/// @audit Lines: 152 
143:     function mint(uint256 amount) external auth loop returns (uint256) { 
144:         uint256 slp = slippage;
145:         uint256 tot = totalShares;
146:         uint256 tma = rate(tot);
147: 
148:         asset.transferFrom(msg.sender, address(this), amount);
149:         asset.approve(address(strategyHelper), amount);
150:         uint256 bal = strategyHelper.swap(address(asset), tokenShort, amount, slp, address(this));
151:         uint256 val = strategyHelper.value(tokenShort, bal);
152:         uint256 shares = (tma == 0 || tot == 0) ? val : val * tot / tma;
153: 
154:         totalShares += shares;
155:         emit Mint(amount, shares);
156:         return shares;
157:     }

/// @audit Lines: 188 to 192
184:     function earn() external payable loop { 
185:         if (!keepers[msg.sender]) revert NotKeeper();
186:         uint256 before = rate(totalShares);
187: 
188:         if (amountPendingDeposit != 0 || amountPendingWithdraw != 0) {
189:             revert ActionPending();
190:         }
191: 
192:         uint256 slp = slippage;
193:         uint256 bal = IERC20(tokenLong).balanceOf(address(this));
194:         if (bal > 0) {
195:             IERC20(tokenLong).approve(address(strategyHelper), bal);
196:             strategyHelper.swap(tokenLong, tokenShort, bal, slp, address(this));
197:         }
198: 
199:         bal = IERC20(tokenShort).balanceOf(address(this));
200:         uint256 have = strategyHelper.value(tokenShort, bal);
201:         uint256 need = rate(totalShares) * reserveRatio / 10000;
202: 
203:         if (have > need) {
204:             uint256 amt = (have - need) * bal / have;
205:             uint256 haf = amt / 2;
206:             IERC20(tokenShort).approve(address(strategyHelper), haf);
207:             uint256 out = strategyHelper.swap(tokenShort, tokenLong, haf, slp, address(this));
208:             uint256 minOut = (have - need) * 1e18 / marketTokenPrice(true);
209:             amountPendingDeposit = minOut;
210:             minOut = minOut * (10000 - slp) / 10000;
211: 
212:             IExchangeRouter.CreateDepositParams memory params = IExchangeRouter.CreateDepositParams({
213:                 receiver: address(this),
214:                 callbackContract: address(this),
215:                 uiFeeReceiver: address(0),
216:                 market: market,
217:                 initialLongToken: tokenLong,
218:                 initialShortToken: tokenShort,
219:                 longTokenSwapPath: new address[](0),
220:                 shortTokenSwapPath: new address[](0),
221:                 minMarketTokens: minOut,
222:                 shouldUnwrapNativeToken: false,
223:                 executionFee: earnActionValue,
224:                 callbackGasLimit: callbackGasLimit
225:             });
226: 
227:             IMarket.Props memory marketInfo = reader.getMarket(dataStore, market);
228:             bytes[] memory data = new bytes[](4);
229:             address router = exchangeRouter.router();
230:             address vault = depositVault;
231: 
232:             IERC20(marketInfo.longToken).approve(router, out);
233:             IERC20(marketInfo.shortToken).approve(router, amt - haf);
234: 
235:             data[0] = abi.encodeWithSelector(IExchangeRouter.sendWnt.selector, vault, params.executionFee);
236:             data[1] = abi.encodeWithSelector(IExchangeRouter.sendTokens.selector, marketInfo.longToken, vault, out);
237:             data[2] =
238:                 abi.encodeWithSelector(IExchangeRouter.sendTokens.selector, marketInfo.shortToken, vault, amt - haf);
239:             data[3] = abi.encodeWithSelector(IExchangeRouter.createDeposit.selector, params);
240:             exchangeRouter.multicall{value: params.executionFee}(data);
241:         } else if (have < need) {
242:             uint256 amt = (need - have) * 1e18 / marketTokenPrice(true);
243: 
244:             IMarket.Props memory marketInfo = reader.getMarket(dataStore, market);
245:             (uint256 longOut, uint256 shortOut) = reader.getWithdrawalAmountOut(
246:                 dataStore,
247:                 marketInfo,
248:                 IMarket.Prices({
249:                     indexTokenPrice: gmxPrice(marketInfo.indexToken, true),
250:                     longTokenPrice: gmxPrice(marketInfo.longToken, false),
251:                     shortTokenPrice: gmxPrice(marketInfo.shortToken, false)
252:                 }),
253:                 amt,
254:                 address(0)
255:             );
256:             IExchangeRouter.CreateWithdrawalParams memory params = IExchangeRouter.CreateWithdrawalParams({
257:                 receiver: address(this),
258:                 callbackContract: address(this),
259:                 uiFeeReceiver: address(0),
260:                 market: market,
261:                 longTokenSwapPath: new address[](0),
262:                 shortTokenSwapPath: new address[](0),
263:                 minLongTokenAmount: longOut * (10000 - slp) / 10000,
264:                 minShortTokenAmount: shortOut * (10000 - slp) / 10000,
265:                 shouldUnwrapNativeToken: false,
266:                 executionFee: earnActionValue,
267:                 callbackGasLimit: callbackGasLimit
268:             });
269: 
270:             amountPendingWithdraw = amt;
271:             bytes[] memory data = new bytes[](3);
272:             IERC20(market).approve(exchangeRouter.router(), amt);
273:             data[0] = abi.encodeWithSelector(IExchangeRouter.sendWnt.selector, withdrawalVault, params.executionFee);
274:             data[1] = abi.encodeWithSelector(IExchangeRouter.sendTokens.selector, market, withdrawalVault, amt);
275:             data[2] = abi.encodeWithSelector(IExchangeRouter.createWithdrawal.selector, params);
276:             exchangeRouter.multicall{value: params.executionFee}(data);
277:         }
278: 
279:         uint256 current = rate(totalShares);
280:         emit Earn(current, current - min(current, before));
281:     }

/// @audit Lines: 284 to 288
283:     function exit(address strategy) external auth { 
284:         if (amountPendingDeposit != 0 || amountPendingWithdraw != 0) {
285:             revert ActionPending();
286:         }
287:         IERC20(market).transfer(strategy, IERC20(market).balanceOf(address(this)));
288:         IERC20(tokenLong).transfer(strategy, IERC20(tokenLong).balanceOf(address(this)));
289:         IERC20(tokenShort).transfer(strategy, IERC20(tokenShort).balanceOf(address(this)));
290:     }
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit Lines: 73 
72:     function rate(uint256 sha) public view returns (uint256) { 
73:         if (sha == 0 || totalShares == 0) return 0;
74:         IUniswapV2Pair pair = pool;
75:         uint256 tot = pair.totalSupply();
76:         uint256 amt = totalManagedAssets();
77:         uint256 reserve0;
78:         uint256 reserve1;
79:         {
80:             (uint112 r0, uint112 r1,) = pair.getReserves();
81:             reserve0 = uint256(r0) * 1e18 / (10 ** IERC20(pair.token0()).decimals());
82:             reserve1 = uint256(r1) * 1e18 / (10 ** IERC20(pair.token1()).decimals());
83:         }
84:         uint256 price0 = strategyHelper.price(pair.token0());
85:         uint256 price1 = strategyHelper.price(pair.token1());
86:         uint256 val = 2 * ((sqrt(reserve0 * reserve1) * sqrt(price0 * price1)) / tot);
87:         return sha * (val * amt / 1e18) / totalShares;
88:     }
```


</details>


---
### [GAS&#x2011;53] Splitting `revert()` statements saves gas
Splitting the conditions into two separate checks [saves](https://gist.github.com/IllIllI000/7e25b0fca6bd9d57d9b9bcb9d2018959) 2 **gas**


Gas saved per Instance: ~2 *(Total: ~8)*
<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

202:             if (data == 0 || data > 4) revert InvalidFile(); 

263:         if (store.getUint(STATUS) < STATUS_LIVE || s.status < STATUS_LIVE) revert WrongStatus(); 

403:         if (store.getUint(STATUS) < STATUS_LIQUIDATE || s.status < STATUS_LIQUIDATE) revert WrongStatus(); 
```


```solidity
📁 File: StrategyGMXGM.sol

139:       if (token == address(market) || token == tokenShort || token == tokenLong) revert BadToken(); 
```


</details>


---
### [GAS&#x2011;54] Stack variable is only used once
If the variable is only accessed once, it's cheaper to use the assigned value directly that one time, and save the 3 gas the extra stack assignment would spend.


Gas saved per Instance: ~3 *(Total: ~186)*
<details>
<summary><i>There are 62 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

44:         uint256 repay = investor.killRepayment(id); 

57:         uint256 id = uint256(bytes32(params)); 
```


```solidity
📁 File: Investor.sol

169:             IPool pool = IPool(store.getAddress(POOL)); 
170:             address poolAsset = pool.asset();

240:         uint256 cap = store.getUint(keccak256(abi.encode(token, COLLATERAL_CAP))); 

246:         uint256 factor = store.getUint(keccak256(abi.encode(token, COLLATERAL_FACTOR))); 

280:             address poolAsset = pool.asset(); 

323:             uint256 collateralCap = store.getUint(keccak256(abi.encode(p.token, COLLATERAL_CAP))); 

349:                     uint256 topup = helper.swap(p.token, poolAsset, cAmount, slippage, address(this)); 

355:             uint256 used = pool.repay(repaying); 

389:         IPool pool = IPool(store.getAddress(POOL)); 
390:         Position memory p = getPosition(id);

392:         uint256 fee = borrow * killCollateralPadding / 10000 / 2; 

397:         IBank bank = IBank(store.getAddress(BANK)); 

434:         bytes memory data = strategyProxy.kill(s.implementation, shares, msg.sender); 

447:         Position memory p = getPosition(id); 

453:         IStrategy s = IStrategy(store.getAddress(keccak256(abi.encode(p.strategy, STRATEGIES_ADDRESS)))); 

456:         uint256 factor = store.getUint(keccak256(abi.encode(p.token, COLLATERAL_FACTOR))); 
457:         uint256 sharesValue = s.rate(p.shares);
458:         uint256 collateralValue = helper.value(p.token, p.collateral);
459:         uint256 value = (sharesValue + collateralValue) * factor / 1e18;
460:         uint256 price = (uint256(oracle.latestAnswer()) * 1e18) / (10 ** oracle.decimals());
461:         uint256 scaled = (p.borrow * 1e18) / (10 ** IERC20(pool.asset()).decimals());
462:         uint256 borrow = (scaled * pool.getUpdatedIndex() / 1e18) * price / 1e18;
```


```solidity
📁 File: PositionManager.sol

245:         IInvestor.Position memory p = investor.getPosition(id); 

273:         string memory image = generateImage(id); 

310:         IInvestor.Position memory p = investor.getPosition(id); 
311:         IInvestor.Strategy memory s = investor.getStrategy(p.strategy);

325:         IInvestor.Strategy memory s = investor.getStrategy(p.strategy); 

327:         uint256 len = bytes(str).length + 7; 

340:         IInvestor.Position memory p = investor.getPosition(id); 

343:         uint256 amt = ( 

347:         uint256 len = bytes(str).length + 8; 

360:         uint256 amt = investor.life(id); 

362:         uint256 len = bytes(str).length + 6; 

375:         uint256 x = 10 ** d; 
376:         uint256 r = n / (10 ** (d - f)) % (10 ** f);
```


```solidity
📁 File: StrategyCamelotV3.sol

152:             uint256 tgtAmt = IERC20(tgtAst).balanceOf(address(this)); 

161:         uint256 val = valueLiquidity() * liq / totalManagedAssets(); 

173:         uint256 val = valueLiquidity() * amt / tma; 

230:         uint256 before = rate(totalShares); 

315:         uint256 toLp1 = amt - toLp0; 

339:         uint256 minOut = strategyHelper.convert(trgtAst, ast, toLp) * (10000 - slp) / 10000; 

377:         bytes32 key; 
```


```solidity
📁 File: StrategyGMXGM.sol

144:         uint256 slp = slippage; 

150:         uint256 bal = strategyHelper.swap(address(asset), tokenShort, amount, slp, address(this)); 

160:         uint256 slp = slippage; 
161:         uint256 val = rate(shares);

172:         uint256 value = rate(shares); 

186:         uint256 before = rate(totalShares); 

298:         uint256 bal = IERC20(market).balanceOf(address(this)) + amountPendingDeposit + amountPendingWithdraw; 
```


```solidity
📁 File: StrategySushiswap.sol

75:         uint256 tot = pair.totalSupply(); 
76:         uint256 amt = totalManagedAssets();

84:         uint256 price0 = strategyHelper.price(pair.token0()); 
85:         uint256 price1 = strategyHelper.price(pair.token1());
86:         uint256 val = 2 * ((sqrt(reserve0 * reserve1) * sqrt(price0 * price1)) / tot);

121:             uint256 tma = totalManagedAssets(); 
122:             uint256 amt = shares * tma / totalShares;

132:         uint256 amt0 = strategyHelper.swap(address(tok0), address(asset), bal0, slp, msg.sender); 
133:         uint256 amt1 = strategyHelper.swap(address(tok1), address(asset), bal1, slp, msg.sender);

155:         uint256 before = rate(totalShares); 
```


```solidity
📁 File: UtilFarmingBalances.sol

16:         IPositionManager pm = IPositionManager(0x5e4d7F61cC608485A2E4F105713D26D58a9D0cF6); 
```


</details>


---
### [GAS&#x2011;55] State variable read in a loop
The state variable should be cached in and read from a local variable, or accumulated in a local variable then written to storage once outside of the loop, rather than reading/updating it on every iteration of the loop, which will replace each Gwarmaccess (**100 gas**) with a much cheaper stack read.


Gas saved per Instance: ~97 *(Total: ~194)*
<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

/// @audit _ownerIds
129:         for (uint256 i = start; i < end; i++) { 
```


```solidity
📁 File: Store.sol

/// @audit bytes32Sets
136:         for (uint256 i = start; i < end; i++) { 
```


</details>


---
### [GAS&#x2011;56] State variables can be packed into fewer storage slots by truncating timestamp bytes
By using a `uint32` rather than a larger type for variables that track timestamps, one can save gas by using fewer storage slots per struct, at the expense of the protocol breaking after the year 2106 (when `uint32` wraps). If this is an acceptable tradeoff, if variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper


Gas saved per Instance: ~240,000 

<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyCamelotV3.sol

/// @audit use this order:
/// -  exec
/// -  keepers
/// -  name
/// -  totalShares
/// -  slippage
/// -  entered
/// -  asset
/// -  strategyHelper
/// -  pathToLp
/// -  targetAsset
/// -  nftPool
/// -  nitroPool
/// -  tokenId
/// -  twapPeriod (uint32)
/// -  rewardToken1
/// -  rewardToken2
/// -  rewardToken3
/// @audit 12 storage slot(s) saved, (before 16, after 4)
7: contract StrategyCamelotV3 { 
```



---
### [GAS&#x2011;57] State variables can be reordered to fit into fewer storage slots
If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper


Gas saved per Instance: ~20,000 *(Total: ~40,000)*
<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: StrategyCamelotV3.sol

/// @audit use this order: 
/// - exec,
/// - keepers,
/// - name,
/// - totalShares,
/// - slippage,
/// - entered,
/// - asset,
/// - strategyHelper,
/// - pathToLp,
/// - targetAsset,
/// - nftPool,
/// - nitroPool,
/// - tokenId,
/// - twapPeriod,
/// - rewardToken1,
/// - rewardToken2,
/// - rewardToken3
/// @audit to save 1 storage slots, (before 5, after 4)
7: contract StrategyCamelotV3 { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit use this order: 
/// - name,
/// - totalShares,
/// - slippage,
/// - asset,
/// - strategyHelper,
/// - exec,
/// - keepers,
/// - exchangeRouter,
/// - reader,
/// - indexTokenDecimals,
/// - amountPendingDeposit,
/// - amountPendingWithdraw,
/// - reserveRatio,
/// - earnActionValue,
/// - callbackGasLimit,
/// - depositHandler,
/// - entered,
/// - depositVault,
/// - withdrawalVault,
/// - withdrawalHandler
/// @audit to save 1 storage slots, (before 20, after 19)
4: contract StrategyGMXGM { 
```


</details>


---
### [GAS&#x2011;58] State variables only set in the constructor should be declared `immutable`
Avoids a Gsset (**20000 gas**) in the constructor, and replaces the first access in each transaction (Gcoldsload - **2100 gas**) and each access thereafter (Gwarmacces - **100 gas**) with a `PUSH32` (**3 gas**).

While `string`s are not value types, and therefore cannot be `immutable`/`constant` if not hard-coded outside of the constructor, the same behavior can be achieved by making the current contract `abstract` with `virtual` functions for the `string` accessors, and having a child contract override the functions with the hard-coded implementation-specific values.


Gas saved per Instance: ~2,097 *(Total: ~39,843)*
<details>
<summary><i>There are 19 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

30:     IInvestor public investor; 
31:     IERC20 public asset;
32:     IAavePool public lender; // 0x794a61358D6845594F94dc1DB02A252b5b4814aD
33:     IStrategyHelper public sh;
```


```solidity
📁 File: Investor.sol

66:     IStore public store; 
```


```solidity
📁 File: InvestorStrategyProxy.sol

16:     IERC20 public asset; 
```


```solidity
📁 File: StrategyCamelotV3.sol

8:     string public name; 

12:     IERC20 public asset; 
13:     IStrategyHelper public strategyHelper;

23:     address public targetAsset; 
```


```solidity
📁 File: StrategyGMXGM.sol

5:     string public name; 

9:     IERC20 public asset; 
10:     IStrategyHelper public strategyHelper;
```


```solidity
📁 File: StrategySushiswap.sol

5:     string public name; 

9:     IERC20 public asset; 
10:     IStrategyHelper public strategyHelper;
11:     ISushiswapMiniChefV2 public rewarder;
12:     IUniswapV2Pair public pool;
13:     uint256 public poolId;
```


</details>


---
### [GAS&#x2011;59] State variables only set in their definitions should be declared `constant`
This can avoid a Gsset (**20000 gas**) on deployment (in constructor), and replaces the first access in each transaction (Gcoldsload - **2100 gas**) and each access thereafter (Gwarmacces - **100 gas**) with a `PUSH32` (**3 gas**).


Gas saved per Instance: ~2,097 

<i>There is one instance of this issue:</i>

```solidity
📁 File: Helper.sol

34:     uint256 public slippage = 2500; 
```



---
### [GAS&#x2011;60] State variables should be cached in stack variables rather than re-reading them from storage
When performing multiple operations on a state variable in a function, it is recommended to cache it first. Either multiple reads or multiple writes to a state variable can save gas by caching it on the stack. Caching of a state variable replaces each Gwarmaccess (100 gas) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses. *Saves 100 gas per instance*.


Gas saved per Instance: ~100 *(Total: ~9,000)*
<details>
<summary><i>There are 90 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

/// @audit exec: 2 reads (1 in modifiers)
26:     function file(bytes32 what, address data) external auth { 
```


```solidity
📁 File: Helper.sol

/// @audit investor: 2 reads 
/// @audit asset: 4 reads 
/// @audit lender: 2 reads 
48:     function executeOperation( 
49:       address,
50:       uint256 amount,
51:       uint256 premium,
52:       address initiator,
53:       bytes calldata params
54:     ) external returns (bool) {

/// @audit sh: 2 reads 
76:     function swap(address _fromAsset) internal { 
```


```solidity
📁 File: Investor.sol

/// @audit store: 3 reads 
162:     function file(bytes32 what, address data) external auth { 

/// @audit store: 3 reads 
210:     function strategyNew(uint256 index, address implementation) external auth { 

/// @audit store: 2 reads 
239:     function collateralSetFactor(address token, uint256 factor) external auth { 

/// @audit store: 2 reads 
245:     function collateralSetCap(address token, uint256 cap) external auth { 

/// @audit store: 5 reads 
/// @audit whitelist: 2 reads 
/// @audit strategyProxy: 2 reads 
255:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external loop returns (uint256) { 

/// @audit store: 5 reads 
/// @audit helper: 3 reads 
/// @audit strategyProxy: 3 reads 
295:     function edit(uint256 id, int256 borrow, int256 collateral) external loop { 

/// @audit store: 3 reads 
/// @audit helper: 2 reads 
396:     function kill(uint256 id) external loop returns (address, bytes memory) { 

/// @audit store: 3 reads 
451:     function _life(Position memory p) internal view returns (uint256) { 

/// @audit store: 8 reads 
466:     function getPosition(uint256 id) public view returns (Position memory p) { 

/// @audit store: 8 reads 
477:     function setPosition(uint256 id, Position memory p) internal { 

/// @audit store: 3 reads 
488:     function getStrategy(uint256 id) public view returns (Strategy memory s) { 
```


```solidity
📁 File: PositionManager.sol

/// @audit _balanceOf: 2 reads 
/// @audit _ownerIds: 2 reads 
155:     function moveId(address from, address to, uint256 id) internal { 

/// @audit _ownerOf: 2 reads (1 in modifiers)
182:     function transferFrom(address from, address to, uint256 id) public auth(id) { 

/// @audit whitelist: 2 reads 
214:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow, address to) public returns (uint256) { 

/// @audit investor: 3 reads 
233:     function edit(uint256 id, int256 borrow, int256 collateral) public auth(id) { 

/// @audit _ownerOf: 2 reads (1 in modifiers)
244:     function burn(uint256 id) public auth(id) { 

/// @audit _ownerOf: 2 reads (1 in modifiers)
252:     function forceBurn(uint256 id) public auth(id) { 

/// @audit investor: 2 reads 
309:     function generateHeader(uint256 id) private view returns (string memory) { 

/// @audit investor: 2 reads 
323:     function generateLabelVal(uint256 id) private view returns (string memory) { 

/// @audit investor: 2 reads 
339:     function generateLabelBor(uint256 id) private view returns (string memory) { 
```


```solidity
📁 File: Store.sol

/// @audit exec: 2 reads (1 in modifiers)
35:     function file(bytes32 what, address data) external auth { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit tokenId: 3 reads 
123:     function setNitroPool(address _nitroPool) external auth { 

/// @audit totalShares: 2 reads 
/// @audit asset: 4 reads 
/// @audit strategyHelper: 3 reads 
141:     function mint(uint256 amount) external auth loop returns (uint256) { 

/// @audit totalShares: 2 reads 
/// @audit asset: 3 reads 
/// @audit strategyHelper: 4 reads 
170:     function burn(uint256 shares) external auth loop returns (uint256) { 

/// @audit totalShares: 2 reads 
193:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit nftPool: 3 reads 
/// @audit tokenId: 3 reads 
206:     function stake(uint256 amount) internal { 

/// @audit nftPool: 2 reads 
/// @audit nitroPool: 4 reads 
/// @audit tokenId: 3 reads 
218:     function unstake(uint256 amount) internal { 

/// @audit totalShares: 2 reads 
/// @audit strategyHelper: 10 reads 
/// @audit nitroPool: 2 reads 
/// @audit tokenId: 2 reads 
/// @audit rewardToken1: 5 reads 
/// @audit rewardToken2: 5 reads 
/// @audit rewardToken3: 5 reads 
228:     function earn() external payable loop { 

/// @audit nitroPool: 2 reads 
/// @audit tokenId: 3 reads 
276:     function exit(address strategy) external auth { 

/// @audit nitroPool: 2 reads 
284:     function move(address old) external auth { 

/// @audit strategyHelper: 2 reads 
344:     function valueLiquidity() private view returns (uint256) { 

/// @audit tokenId: 2 reads 
370:     function totalManagedAssets() private view returns (uint256) { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit exec: 2 reads (1 in modifiers)
94:     function file(bytes32 what, address data) external auth { 

/// @audit totalShares: 2 reads 
/// @audit asset: 3 reads 
/// @audit strategyHelper: 3 reads 
143:     function mint(uint256 amount) external auth loop returns (uint256) { 

/// @audit strategyHelper: 3 reads 
159:     function burn(uint256 shares) external auth loop returns (uint256) { 

/// @audit totalShares: 3 reads 
/// @audit strategyHelper: 5 reads 
/// @audit exchangeRouter: 4 reads 
/// @audit reader: 3 reads 
/// @audit withdrawalVault: 2 reads 
/// @audit earnActionValue: 2 reads 
/// @audit callbackGasLimit: 2 reads 
184:     function earn() external payable loop { 

/// @audit strategyHelper: 2 reads 
294:     function rate(uint256 shares) public view returns (uint256) { 

/// @audit strategyHelper: 2 reads 
345:     function afterWithdrawalExecution(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit pool: 2 reads 
29:     constructor(address _asset, address _strategyHelper, address _rewarder, uint256 _poolId) { 

/// @audit exec: 2 reads (1 in modifiers)
52:     function file(bytes32 what, address data) external auth { 

/// @audit totalShares: 2 reads 
/// @audit strategyHelper: 2 reads 
72:     function rate(uint256 sha) public view returns (uint256) { 

/// @audit totalShares: 2 reads 
/// @audit asset: 4 reads 
/// @audit strategyHelper: 3 reads 
/// @audit rewarder: 2 reads 
90:     function mint(uint256 amount) public auth loop returns (uint256) {  

/// @audit totalShares: 2 reads 
/// @audit asset: 2 reads 
/// @audit strategyHelper: 4 reads 
117:     function burn(uint256 shares) public auth loop returns (uint256) { 

/// @audit totalShares: 2 reads 
141:     function kill(uint256 shares, address to) external auth loop returns (bytes memory) { 

/// @audit totalShares: 2 reads 
/// @audit slippage: 2 reads 
/// @audit strategyHelper: 4 reads 
/// @audit rewarder: 4 reads 
/// @audit poolId: 2 reads 
153:     function earn() public payable loop { 

/// @audit rewarder: 2 reads 
186:     function move(address old) public auth { 
```


```solidity
📁 File: Whitelist.sol

/// @audit exec: 2 reads (1 in modifiers)
23:     function file(bytes32 what, address data) external auth { 
```


</details>


---
### [GAS&#x2011;61] Struct can be reordered to fit into fewer storage slots
In Solidity, data type packing within struct variables is a recommended practice to optimize gas usage and efficiency in smart contracts.

This technique leverages the fact that Ethereum’s storage model stores variables in slots, with each slot offering a capacity of 32 bytes. When data types that consume less than 32 bytes, such as **uint8**, **bool**, or **address**, are declared individually, each occupies a whole storage slot. However, when these smaller variables are grouped into a struct, they can share a storage slot, resulting in a significant reduction in storage requirements and, by extension, gas costs.


Gas saved per Instance: ~20,000 *(Total: ~40,000)*

<i>There are 2 instaces of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

/// @audit use this order:  longTokenSwapPath, shortTokenSwapPath, minMarketTokens, executionFee, callbackGasLimit, receiver, shouldUnwrapNativeToken, uiFeeReceiver, market, initialLongToken, initialShortToken, callbackContract
/// @audit 1 storage slot(s) saved, (before 12, after 11)
400:     struct CreateDepositParams { 

/// @audit use this order:  longTokenSwapPath, shortTokenSwapPath, minLongTokenAmount, minShortTokenAmount, executionFee, callbackGasLimit, receiver, shouldUnwrapNativeToken, uiFeeReceiver, market, callbackContract
/// @audit 1 storage slot(s) saved, (before 11, after 10)
415:     struct CreateWithdrawalParams { 
```



---
### [GAS&#x2011;62] Structs can be assigned more efficiently
Rather defining the struct in a single line, it is more efficient to declare an empty struct and then assign each struct element individually. This can net quite a large gas saving of **130 per instance**.


Gas saved per Instance: ~130 *(Total: ~390)*

<i>There are 3 instaces of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

212:             IExchangeRouter.CreateDepositParams memory params = IExchangeRouter.CreateDepositParams({ 
213:                 receiver: address(this),
214:                 callbackContract: address(this),
215:                 uiFeeReceiver: address(0),
216:                 market: market,
217:                 initialLongToken: tokenLong,
218:                 initialShortToken: tokenShort,
219:                 longTokenSwapPath: new address[](0),
220:                 shortTokenSwapPath: new address[](0),
221:                 minMarketTokens: minOut,
222:                 shouldUnwrapNativeToken: false,
223:                 executionFee: earnActionValue,
224:                 callbackGasLimit: callbackGasLimit
225:             });

248:                 IMarket.Prices({ 
249:                     indexTokenPrice: gmxPrice(marketInfo.indexToken, true),
250:                     longTokenPrice: gmxPrice(marketInfo.longToken, false),
251:                     shortTokenPrice: gmxPrice(marketInfo.shortToken, false)
252:                 }),

256:             IExchangeRouter.CreateWithdrawalParams memory params = IExchangeRouter.CreateWithdrawalParams({ 
257:                 receiver: address(this),
258:                 callbackContract: address(this),
259:                 uiFeeReceiver: address(0),
260:                 market: market,
261:                 longTokenSwapPath: new address[](0),
262:                 shortTokenSwapPath: new address[](0),
263:                 minLongTokenAmount: longOut * (10000 - slp) / 10000,
264:                 minShortTokenAmount: shortOut * (10000 - slp) / 10000,
265:                 shouldUnwrapNativeToken: false,
266:                 executionFee: earnActionValue,
267:                 callbackGasLimit: callbackGasLimit
268:             });
```



---
### [GAS&#x2011;63] The result of a function call should be cached rather than re-calling the function
External calls are expensive. Results of external function calls should be cached rather than call them multiple times. Consider caching the following:


Gas saved per Instance: ~100 *(Total: ~1,700)*
<details>
<summary><i>There are 17 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

/// @audit si.totalShares() called on lines 278, 289
255:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external loop returns (uint256) { 

/// @audit si.totalShares() called on lines 362, 383
295:     function edit(uint256 id, int256 borrow, int256 collateral) external loop { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit hypervisor.token0() called on lines 73, 71
/// @audit hypervisor.token1() called on lines 73, 71
48:     constructor( 

/// @audit totalManagedAssets() called on lines 145, 161
141:     function mint(uint256 amount) external auth loop returns (uint256) { 

/// @audit hypervisor.token0() called on lines 178, 183
/// @audit hypervisor.token1() called on lines 179, 184
170:     function burn(uint256 shares) external auth loop returns (uint256) { 

/// @audit hypervisor.token0() called on lines 313, 302
297:     function quoteAddLiquidity(uint256 amt, address trgtAst, bytes memory path) private returns (uint256, uint256) { 

/// @audit hypervisor.token0() called on lines 323, 331, 333
/// @audit hypervisor.token1() called on lines 326, 327, 329
320:     function quoteAndSwap(address trgtAst, uint256 amt, uint256 slp) private returns (uint256 amt0, uint256 amt1) { 

/// @audit hypervisor.token0() called on lines 356, 356
/// @audit hypervisor.token1() called on lines 359, 359
344:     function valueLiquidity() private view returns (uint256) { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit exchangeRouter.router() called on lines 229, 272
184:     function earn() external payable loop { 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit pair.token0() called on lines 84, 81
/// @audit pair.token1() called on lines 85, 82
72:     function rate(uint256 sha) public view returns (uint256) { 

/// @audit pair.token0() called on lines 164, 166, 166
/// @audit pair.token1() called on lines 165, 167, 167
153:     function earn() public payable loop { 
```


</details>


---
### [GAS&#x2011;64] `unchecked {}` can be used on the division of two `uint`s in order to save gas
The division cannot overflow, since both the numerator and the denominator are non-negative


Gas saved per Instance: ~60 *(Total: ~120)*

<i>There are 2 instaces of this issue:</i>

```solidity
📁 File: PositionManager.sol

/// @note Confidence: 100.00%
376:         uint256 r = n / (10 ** (d - f)) % (10 ** f); 

/// @note Confidence: 100.00%
381:         return string(abi.encodePacked(Strings.toString(n / x), ".", sr)); 
```



---
### [GAS&#x2011;65] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead
Citing the [documentation](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html):

> When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher.This is because the EVM operates on 32 bytes at a time.Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.

For example, each operation involving a `uint8` costs an extra ** 22 - 28 gas ** (depending on whether the other operand is also a variable of type `uint8`) as compared to ones involving`uint256`, due to the compiler having to clear the higher bits of the memory word before operating on the`uint8`, as well as the associated stack operations of doing so.

Consider using a larger size, then downcast where needed.


Gas saved per Instance: ~6 *(Total: ~132)*
<details>
<summary><i>There are 22 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

16:     function flashLoanSimple(address receiver, address asset, uint256 amount, bytes calldata params, uint16 referrer) external; 
```


```solidity
📁 File: StrategyCamelotV3.sol

8:     string public name; 

10:     uint256 public slippage = 500; 

12:     IERC20 public asset; 

22:     bytes public pathToLp; // UniV3 path from targetAsset to other asset 

24:     INFTPool public nftPool; 

26:     uint256 public tokenId; 

28:     address public rewardToken1; 

30:     address public rewardToken3; 

352:         uint160 midX96 = TickMath.getSqrtRatioAtTick(int24((tickCumulatives[1] - tickCumulatives[0]) / int32(period))); 

376:     function getPosition(uint160 midX96, int24 minTick, int24 maxTick) private view returns (uint256, uint256) { 

382:         (uint128 liq,,,, uint128 owed0, uint128 owed1) = IAlgebraPool(address(hypervisor.pool())).positions(key); 

448:     function baseUpper() external view returns (int24); 

450:     function limitUpper() external view returns (int24); 

481:         uint128 liquidityAmount, 

485:         uint128 fees0, 
```


```solidity
📁 File: StrategyGMXGM.sol

385:         uint80 roundId, 

389:         uint80 answeredInRound 
```


```solidity
📁 File: StrategySushiswap.sol

80:             (uint112 r0, uint112 r1,) = pair.getReserves(); 

272:     function getReserves() external view returns (uint112, uint112, uint32); 
```


</details>


---
### [GAS&#x2011;66] Use `Array.unsafeAccess()` to avoid repeated array length checks
When using storage arrays, solidity adds an internal lookup of the array's length (a Gcoldsload **2100 gas**) to ensure you don't read past the array's end. You can avoid this lookup by using [`Array.unsafeAccess()`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/94697be8a3f0dfcd95dfb13ffbd39b5973f5c65d/contracts/utils/Arrays.sol#L57) in cases where the length has already been checked, as is the case with the instances below


Gas saved per Instance: ~2,100 

<i>There is one instance of this issue:</i>

```solidity
📁 File: Whitelist.sol

37:             whitelist[addresses[i]] = status; 
```



---
### [GAS&#x2011;67] Use assembly for small `keccak256` hashes
The assembly version of the keccak256 hashing function can be more gas efficient than the high-level Solidity version.


Gas saved per Instance: ~80 *(Total: ~2,640)*

<i>There are 33 instaces of this issue:</i>

```solidity
📁 File: Investor.sol

211:         if (store.getAddress(keccak256(abi.encode(index, STRATEGIES_ADDRESS))) != address(0)) { 

214:         store.setAddress(keccak256(abi.encode(index, STRATEGIES_ADDRESS)), implementation); 
215:         store.setUint(keccak256(abi.encode(index, STRATEGIES_STATUS)), 4);

223:         store.setAddress(keccak256(abi.encode(index, STRATEGIES_ADDRESS)), implementation); 

229:         store.setUint(keccak256(abi.encode(index, STRATEGIES_STATUS)), status); 

235:         store.setUint(keccak256(abi.encode(index, STRATEGIES_CAP)), cap); 

240:         uint256 cap = store.getUint(keccak256(abi.encode(token, COLLATERAL_CAP))); 
241:         store.setUint(keccak256(abi.encode(token, COLLATERAL_FACTOR)), factor);

246:         uint256 factor = store.getUint(keccak256(abi.encode(token, COLLATERAL_FACTOR))); 
247:         store.setUint(keccak256(abi.encode(token, COLLATERAL_CAP)), cap);

264:         uint256 collateralCap = store.getUint(keccak256(abi.encode(token, COLLATERAL_CAP))); 

323:             uint256 collateralCap = store.getUint(keccak256(abi.encode(p.token, COLLATERAL_CAP))); 

453:         IStrategy s = IStrategy(store.getAddress(keccak256(abi.encode(p.strategy, STRATEGIES_ADDRESS)))); 

456:         uint256 factor = store.getUint(keccak256(abi.encode(p.token, COLLATERAL_FACTOR))); 

467:         p.owner = store.getAddress(keccak256(abi.encode(id, POSITIONS_OWNER))); 
468:         p.start = store.getUint(keccak256(abi.encode(id, POSITIONS_START)));
469:         p.strategy = store.getUint(keccak256(abi.encode(id, POSITIONS_STRATEGY)));
470:         p.token = store.getAddress(keccak256(abi.encode(id, POSITIONS_TOKEN)));
471:         p.collateral = store.getUint(keccak256(abi.encode(id, POSITIONS_COLLATERAL)));
472:         p.borrow = store.getUint(keccak256(abi.encode(id, POSITIONS_BORROW)));
473:         p.shares = store.getUint(keccak256(abi.encode(id, POSITIONS_SHARES)));
474:         p.basis = store.getUint(keccak256(abi.encode(id, POSITIONS_BASIS)));

478:         store.setAddress(keccak256(abi.encode(id, POSITIONS_OWNER)), p.owner); 
479:         store.setUint(keccak256(abi.encode(id, POSITIONS_START)), p.start);
480:         store.setUint(keccak256(abi.encode(id, POSITIONS_STRATEGY)), p.strategy);
481:         store.setAddress(keccak256(abi.encode(id, POSITIONS_TOKEN)), p.token);
482:         store.setUint(keccak256(abi.encode(id, POSITIONS_COLLATERAL)), p.collateral);
483:         store.setUint(keccak256(abi.encode(id, POSITIONS_BORROW)), p.borrow);
484:         store.setUint(keccak256(abi.encode(id, POSITIONS_SHARES)), p.shares);
485:         store.setUint(keccak256(abi.encode(id, POSITIONS_BASIS)), p.basis);

489:         s.implementation = store.getAddress(keccak256(abi.encode(id, STRATEGIES_ADDRESS))); 
490:         s.cap = store.getUint(keccak256(abi.encode(id, STRATEGIES_CAP)));
491:         s.status = store.getUint(keccak256(abi.encode(id, STRATEGIES_STATUS)));
```



---
### [GAS&#x2011;68] Use assembly in place of `abi.decode`
Instead of using abi.decode, we can use assembly to decode our desired calldata values directly. This will allow us to avoid decoding calldata values that we will not use.


Gas saved per Instance: ~112 *(Total: ~224)*
<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

60:         (bytes32 strategy, address[] memory assets) = abi.decode(data, (bytes32, address[])); 
```


```solidity
📁 File: UtilFarmingBalances.sol

24:               users[y-start] = abi.decode(data, (address)); 
```


</details>


---
### [GAS&#x2011;69] Use assembly scratch space to build calldata for event emits
Utilizing Solidity's assembly scratch space to build calldata for emitting events with just one or two arguments can optimize gas usage. The scratch space, a designated area in the first 64 bytes of memory, is ideal for temporary storage during assembly-level operations. By directly writing the event arguments into this area, developers can bypass the standard memory allocation process required for event emission. This approach results in gas savings, particularly for contracts where events are frequently emitted. However, such low-level optimization requires a deep understanding of Ethereum Virtual Machine (EVM) mechanics and careful coding to prevent data mishandling. Rigorous testing is essential to ensure the integrity and correct functionality of the contract.
> ❗ Issue is removed from: (pech, sxima)


Gas saved per Instance: ~220 *(Total: ~5,720)*
<details>
<summary><i>There are 26 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

32:         emit File(what, data); 
```


```solidity
📁 File: Investor.sol

185:         emit File(what, data); 

207:         emit File(what, data); 
```


```solidity
📁 File: InvestorStrategyProxy.sol

40:         emit File(what, data); 
```


```solidity
📁 File: PositionManager.sol

111:         emit File(what, data); 
```


```solidity
📁 File: Store.sol

41:         emit File(what, data); 
```


```solidity
📁 File: StrategyCamelotV3.sol

104:         emit File(what, data); 

116:         emit File(what, data); 

166:         emit Mint(amount, shares); 

189:         emit Burn(bal, shares); 

199:         emit Kill(amount, shares); 

273:         emit Earn(current, current - min(current, before)); 
```


```solidity
📁 File: StrategyGMXGM.sol

112:         emit File(what, data); 

130:         emit File(what, data); 

155:         emit Mint(amount, shares); 

167:         emit Burn(bal, shares); 

177:         emit Kill(amount, shares); 

280:         emit Earn(current, current - min(current, before)); 
```


```solidity
📁 File: StrategySushiswap.sol

60:         emit File(what, data); 

69:         emit File(what, data); 

113:         emit Mint(amount, shares); 

137:         emit Burn(amount, shares); 

146:         emit Kill(amount, shares); 

174:         emit Earn(current, current - min(current, before)); 
```


```solidity
📁 File: Whitelist.sol

31:         emit File(what, data); 

39:         emit BatchWhitelist(addresses, status); 
```


</details>


---
### [GAS&#x2011;70] Use assembly scratch space to build calldata for external calls
Using Solidity's assembly scratch space for constructing calldata in external calls with one or two arguments can be a gas-efficient approach. This method leverages the designated memory area (the first 64 bytes of memory) for temporary data storage during assembly operations. By directly writing arguments into this scratch space, it eliminates the need for additional memory allocation typically required for calldata preparation. This technique can lead to notable gas savings, especially in high-frequency or gas-sensitive operations. However, it requires careful implementation to avoid data corruption and should be used with a thorough understanding of low-level EVM operations and memory handling. Proper testing and validation are crucial when employing such optimizations.


Gas saved per Instance: ~220 *(Total: ~72,820)*
<details>
<summary><i>There are 331 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

43:         if (!IERC20(token).transfer(to, amount)) revert TransferFailed(); 
```


```solidity
📁 File: Helper.sol

44:         uint256 repay = investor.killRepayment(id); 
45:         lender.flashLoanSimple(address(this), address(asset), repay, abi.encodePacked(id), 0);

58:         asset.approve(address(investor), amount); 
59:         (address casset, bytes memory data) = investor.kill(id);

65:             IERC20(a).transfer(a, IERC20(a).balanceOf(address(this))); 
66:             ISushi(a).burn(address(this));
67:             swap(ISushi(a).token0());
68:             swap(ISushi(a).token1());

71:         asset.approve(address(lender), amount+premium); 
72:         asset.transfer(msg.sender, asset.balanceOf(address(this)) - amount - premium);

78:         uint256 amount = fromAsset.balanceOf(address(this)); 
79:         fromAsset.approve(address(sh), amount);
80:         sh.swap(_fromAsset, address(asset), amount, slippage, address(this));
```


```solidity
📁 File: Investor.sol

169:             IPool pool = IPool(store.getAddress(POOL)); 
170:             address poolAsset = pool.asset();
171:             if (helper.price(poolAsset) == 0) revert InvalidFile();

174:             if (!strategyProxy.exec(address(this))) revert InvalidFile(); 

176:             store.setAddress(BANK, data); 
177:             if (!IBank(data).exec(address(this))) revert InvalidFile();

179:             store.setAddress(POOL, data); 
180:             if (!IPool(data).exec(address(this))) revert InvalidFile();
181:             if (IPool(data).asset() == address(0)) revert InvalidFile();

203:             store.setUint(STATUS, data); 

211:         if (store.getAddress(keccak256(abi.encode(index, STRATEGIES_ADDRESS))) != address(0)) { 

214:         store.setAddress(keccak256(abi.encode(index, STRATEGIES_ADDRESS)), implementation); 
215:         store.setUint(keccak256(abi.encode(index, STRATEGIES_STATUS)), 4);

221:         IStrategy(s.implementation).exit(implementation); 
222:         IStrategy(implementation).move(s.implementation);
223:         store.setAddress(keccak256(abi.encode(index, STRATEGIES_ADDRESS)), implementation);

229:         store.setUint(keccak256(abi.encode(index, STRATEGIES_STATUS)), status); 

235:         store.setUint(keccak256(abi.encode(index, STRATEGIES_CAP)), cap); 

240:         uint256 cap = store.getUint(keccak256(abi.encode(token, COLLATERAL_CAP))); 
241:         store.setUint(keccak256(abi.encode(token, COLLATERAL_FACTOR)), factor);

246:         uint256 factor = store.getUint(keccak256(abi.encode(token, COLLATERAL_FACTOR))); 
247:         store.setUint(keccak256(abi.encode(token, COLLATERAL_CAP)), cap);

252:         IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))); 

257:             if (!whitelist.check(msg.sender)) revert NotWhitelisted(); 

259:         uint256 id = store.setUintDelta(POSITIONS, 1); 

263:         if (store.getUint(STATUS) < STATUS_LIVE || s.status < STATUS_LIVE) revert WrongStatus(); 
264:         uint256 collateralCap = store.getUint(keccak256(abi.encode(token, COLLATERAL_CAP)));

266:         if (IERC20(token).balanceOf(store.getAddress(BANK)) + collateral > collateralCap) { 

278:             if (si.totalShares() == 0) revert StrategyUninitialized(); 
279:             IPool pool = IPool(store.getAddress(POOL));
280:             address poolAsset = pool.asset();

282:             p.borrow = pool.borrow(borrow); 

284:             p.shares = strategyProxy.mint(address(si), borrow); 
285:             p.basis = si.rate(p.shares);

289:         if (si.rate(si.totalShares()) > s.cap) revert StrategyOverCap(); 

296:         IBank bank = IBank(store.getAddress(BANK)); 
297:         IPool pool = IPool(store.getAddress(POOL));

299:         address poolAsset = pool.asset(); 

310:             uint256 status = store.getUint(STATUS); 

323:             uint256 collateralCap = store.getUint(keccak256(abi.encode(p.token, COLLATERAL_CAP))); 
324:             if (IERC20(p.token).balanceOf(store.getAddress(BANK)) > collateralCap) {

331:             p.basis = p.basis - min(p.basis, si.rate(uint256(-borrow))); 
332:             uint256 amount = strategyProxy.burn(address(si), uint256(-borrow));

334:             uint256 index = pool.getUpdatedIndex(); 

344:                     uint256 cAmount = helper.convert(poolAsset, p.token, needed - amount); 

347:                     bank.transfer(p.token, address(this), cAmount); 
348:                     IERC20(p.token).approve(address(helper), cAmount);
349:                     uint256 topup = helper.swap(p.token, poolAsset, cAmount, slippage, address(this));

354:             IERC20(poolAsset).approve(address(pool), amount); 
355:             uint256 used = pool.repay(repaying);

362:             if (si.totalShares() == 0) revert StrategyUninitialized(); 

364:             p.borrow = p.borrow + pool.borrow(uint256(borrow)); 

366:             uint256 shares = strategyProxy.mint(address(si), uint256(borrow)); 

368:             p.basis = p.basis + si.rate(shares); 

379:             bank.transfer(p.token, msg.sender, amt); 

383:         if (borrow > 0 && si.rate(si.totalShares()) > s.cap) revert StrategyOverCap(); 

389:         IPool pool = IPool(store.getAddress(POOL)); 

391:         uint256 borrow = p.borrow * pool.getUpdatedIndex() / 1e18; 

397:         IBank bank = IBank(store.getAddress(BANK)); 
398:         IPool pool = IPool(store.getAddress(POOL));

401:         address poolAsset = pool.asset(); 

403:         if (store.getUint(STATUS) < STATUS_LIQUIDATE || s.status < STATUS_LIQUIDATE) revert WrongStatus(); 

408:         uint256 borrow = p.borrow * pool.getUpdatedIndex() / 1e18; 

410:         IERC20(poolAsset).transferFrom(msg.sender, address(this), borrow + fee); 
411:         IERC20(poolAsset).approve(address(pool), borrow);
412:         pool.repay(p.borrow);

414:         uint256 amount = IStrategy(s.implementation).rate(p.shares); 

419:             uint256 target = helper.value(poolAsset, borrow + (fee * 2)); 

423:                 collat = (target - amount) * 1e18 / helper.price(p.token); 

425:                 bank.transfer(p.token, msg.sender, collat); 

434:         bytes memory data = strategyProxy.kill(s.implementation, shares, msg.sender); 

453:         IStrategy s = IStrategy(store.getAddress(keccak256(abi.encode(p.strategy, STRATEGIES_ADDRESS)))); 
454:         IPool pool = IPool(store.getAddress(POOL));
455:         IOracle oracle = IOracle(pool.oracle());
456:         uint256 factor = store.getUint(keccak256(abi.encode(p.token, COLLATERAL_FACTOR)));
457:         uint256 sharesValue = s.rate(p.shares);
458:         uint256 collateralValue = helper.value(p.token, p.collateral);

460:         uint256 price = (uint256(oracle.latestAnswer()) * 1e18) / (10 ** oracle.decimals()); 
461:         uint256 scaled = (p.borrow * 1e18) / (10 ** IERC20(pool.asset()).decimals());
462:         uint256 borrow = (scaled * pool.getUpdatedIndex() / 1e18) * price / 1e18;

467:         p.owner = store.getAddress(keccak256(abi.encode(id, POSITIONS_OWNER))); 
468:         p.start = store.getUint(keccak256(abi.encode(id, POSITIONS_START)));
469:         p.strategy = store.getUint(keccak256(abi.encode(id, POSITIONS_STRATEGY)));
470:         p.token = store.getAddress(keccak256(abi.encode(id, POSITIONS_TOKEN)));
471:         p.collateral = store.getUint(keccak256(abi.encode(id, POSITIONS_COLLATERAL)));
472:         p.borrow = store.getUint(keccak256(abi.encode(id, POSITIONS_BORROW)));
473:         p.shares = store.getUint(keccak256(abi.encode(id, POSITIONS_SHARES)));
474:         p.basis = store.getUint(keccak256(abi.encode(id, POSITIONS_BASIS)));

478:         store.setAddress(keccak256(abi.encode(id, POSITIONS_OWNER)), p.owner); 
479:         store.setUint(keccak256(abi.encode(id, POSITIONS_START)), p.start);
480:         store.setUint(keccak256(abi.encode(id, POSITIONS_STRATEGY)), p.strategy);
481:         store.setAddress(keccak256(abi.encode(id, POSITIONS_TOKEN)), p.token);
482:         store.setUint(keccak256(abi.encode(id, POSITIONS_COLLATERAL)), p.collateral);
483:         store.setUint(keccak256(abi.encode(id, POSITIONS_BORROW)), p.borrow);
484:         store.setUint(keccak256(abi.encode(id, POSITIONS_SHARES)), p.shares);
485:         store.setUint(keccak256(abi.encode(id, POSITIONS_BASIS)), p.basis);

489:         s.implementation = store.getAddress(keccak256(abi.encode(id, STRATEGIES_ADDRESS))); 
490:         s.cap = store.getUint(keccak256(abi.encode(id, STRATEGIES_CAP)));
491:         s.status = store.getUint(keccak256(abi.encode(id, STRATEGIES_STATUS)));

496:         return store.getAddress(POOL); 

501:         if (!IERC20(asset).transfer(user, amount)) { 

508:         if (!IERC20(asset).transferFrom(user, store.getAddress(BANK), amount)) { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

44:         asset.approve(strategy, amount); 
45:         return IStrategy(strategy).mint(amount);

49:         uint256 amount = IStrategy(strategy).burn(shares); 
50:         asset.transfer(msg.sender, amount);

55:         return IStrategy(strategy).kill(shares, target); 
```


```solidity
📁 File: PositionManager.sol

192:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") 

202:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) 

216:             if (!whitelist.check(msg.sender)) revert NotWhitelisted(); 

220:         uint256 id = investor.open(strategy, token, collateral, borrow); 

226:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") 

234:         IInvestor.Position memory p = investor.getPosition(id); 

239:         investor.edit(id, borrow, collateral); 

241:         push(IPool(investor.getPool()).asset(), msg.sender); 

245:         IInvestor.Position memory p = investor.getPosition(id); 

259:         if (!IERC20(ast).approve(address(investor), amt)) revert TransferFailed(); 

263:         if (!IERC20(ast).transferFrom(usr, address(this), amt)) revert TransferFailed(); 

268:         uint256 bal = asset.balanceOf(address(this)); 
269:         if (bal > 0 && !asset.transfer(usr, bal)) revert TransferFailed();

310:         IInvestor.Position memory p = investor.getPosition(id); 
311:         IInvestor.Strategy memory s = investor.getStrategy(p.strategy);

317:                 IStrategy(s.implementation).name(), 

324:         IInvestor.Position memory p = investor.getPosition(id); 
325:         IInvestor.Strategy memory s = investor.getStrategy(p.strategy);
326:         string memory str = formatNumber(IStrategy(s.implementation).rate(p.shares), 18, 2);

340:         IInvestor.Position memory p = investor.getPosition(id); 
341:         address pool = investor.getPool();
342:         IOracle oracle = IOracle(IPool(pool).oracle());

344:             (p.borrow * IPool(pool).getUpdatedIndex() / 1e18) * 1e18 / (10 ** IERC20(IPool(pool).asset()).decimals()) 
345:         ) * uint256(oracle.latestAnswer()) / (10 ** oracle.decimals());

360:         uint256 amt = investor.life(id); 
```


```solidity
📁 File: StrategyCamelotV3.sol

71:         name = string(abi.encodePacked("Camelot V3 ", hypervisor.token0().symbol(), "/", hypervisor.token1().symbol())); 

73:         if (_targetAsset != address(hypervisor.token0()) && _targetAsset != address(hypervisor.token1())) { 

126:             nitroPool.withdraw(tokenId); 

128:             nftPool.safeTransferFrom(address(this), _nitroPool, tokenId, ""); 

134:         xgrail.redeem(amount, duration); 

138:         xgrail.finalizeRedeem(index); 

142:         asset.transferFrom(msg.sender, address(this), amount); 

147:         asset.approve(address(strategyHelper), amount); 
148:         strategyHelper.swap(address(asset), tgtAst, amount, slp, address(this));

152:             uint256 tgtAmt = IERC20(tgtAst).balanceOf(address(this)); 

155:             hypervisor.token0().approve(hyp, amt0); 
156:             hypervisor.token1().approve(hyp, amt1);
157:             liq = uniProxy.deposit(amt0, amt1, address(this), hyp, [uint256(0), 0, 0, 0]);

162:         if (val < strategyHelper.value(address(asset), amount) * (10000 - slp) / 10000) revert PriceSlipped(); 

175:         (uint256 amt0, uint256 amt1) = hypervisor.withdraw(amt, address(this), address(this), [uint256(0), 0, 0, 0]); 

178:         hypervisor.token0().approve(strategyHelperAddress, amt0); 
179:         hypervisor.token1().approve(strategyHelperAddress, amt1);

183:         bal += strategyHelper.swap(address(hypervisor.token0()), address(asset), amt0, slp, msg.sender); 
184:         bal += strategyHelper.swap(address(hypervisor.token1()), address(asset), amt1, slp, msg.sender);

186:         if (strategyHelper.value(address(asset), bal) < val * (10000 - slp) / 10000) revert PriceSlipped(); 

196:         hypervisor.transfer(to, amount); 

207:         IERC20(address(hypervisor)).approve(address(nftPool), amount); 

209:             nftPool.addToPosition(tokenId, amount); 

214:             nftPool.createPosition(amount, 0); 

220:             nitroPool.withdraw(tokenId); 

222:         nftPool.withdrawFromPosition(tokenId, amount); 

224:             nftPool.safeTransferFrom(address(this), address(nitroPool), tokenId, ""); 

235:         nftPool.harvestPosition(tokenId); 

241:             uint256 balance = IERC20(rewardToken1).balanceOf(address(this)); 
242:             if (strategyHelper.value(rewardToken1, balance) > 1e18) {
243:                 IERC20(rewardToken1).approve(address(strategyHelper), balance);
244:                 strategyHelper.swap(rewardToken1, tgtAsset, balance, slp, address(this));

249:             uint256 balance = IERC20(rewardToken2).balanceOf(address(this)); 
250:             if (strategyHelper.value(rewardToken2, balance) > 1e18) {
251:                 IERC20(rewardToken2).approve(address(strategyHelper), balance);
252:                 strategyHelper.swap(rewardToken2, tgtAsset, balance, slp, address(this));

257:             uint256 balance = IERC20(rewardToken3).balanceOf(address(this)); 
258:             if (strategyHelper.value(rewardToken3, balance) > 1e18) {
259:                 IERC20(rewardToken3).approve(address(strategyHelper), balance);
260:                 strategyHelper.swap(rewardToken3, tgtAsset, balance, slp, address(this));

264:         uint256 amt = IERC20(tgtAsset).balanceOf(address(this)); 
265:         if (strategyHelper.value(tgtAsset, amt) < 1e18) return;

268:         IHypervisor(h).token0().approve(h, amt0); 
269:         IHypervisor(h).token1().approve(h, amt1);
270:         stake(uniProxy.deposit(amt0, amt1, address(this), h, [uint256(0), 0, 0, 0]));

279:             nitroPool.withdraw(tokenId); 

281:         nftPool.safeTransferFrom(address(this), strategy, tokenId, ""); 

285:         nftPool = StrategyCamelotV3(old).nftPool(); 
286:         nitroPool = StrategyCamelotV3(old).nitroPool();
287:         tokenId = StrategyCamelotV3(old).tokenId();

289:             nftPool.safeTransferFrom(address(this), address(nitroPool), tokenId, ""); 

302:         bytes memory path0 = trgtAst != address(hypervisor.token0()) ? path : bytes(""); 
303:         bytes memory path1 = trgtAst != address(hypervisor.token1()) ? path : bytes("");

306:             out0 = quoter.quoteExactInput(path0, lp0Amt); 

309:             out1 = quoter.quoteExactInput(path1, lp1Amt); 

313:             uniProxy.getDepositAmount(address(hypervisor), address(hypervisor.token0()), out0); 

323:         address token0 = address(hypervisor.token0()); 

326:             uint256 before = hypervisor.token1().balanceOf(address(this)); 
327:             swap(trgtAst, address(hypervisor.token1()), path, toLp1, slp);

329:             amt1 = hypervisor.token1().balanceOf(address(this)) - before; 

331:             uint256 before = hypervisor.token0().balanceOf(address(this)); 

333:             amt0 = hypervisor.token0().balanceOf(address(this)) - before; 

339:         uint256 minOut = strategyHelper.convert(trgtAst, ast, toLp) * (10000 - slp) / 10000; 
340:         IERC20(trgtAst).transfer(address(strategyHelperUniswapV3), toLp);
341:         strategyHelperUniswapV3.swap(trgtAst, path, toLp, minOut, address(this));

351:         (int56[] memory tickCumulatives,,,) = hypervisor.pool().getTimepoints(secondsAgos); 

353:         (uint256 bas0, uint256 bas1) = getPosition(midX96, hypervisor.baseLower(), hypervisor.baseUpper()); 
354:         (uint256 lim0, uint256 lim1) = getPosition(midX96, hypervisor.limitLower(), hypervisor.limitUpper());
355:         uint256 val0 = strategyHelper.value(
356:             address(hypervisor.token0()), bas0 + lim0 + hypervisor.token0().balanceOf(address(hypervisor))

358:         uint256 val1 = strategyHelper.value( 
359:             address(hypervisor.token1()), bas1 + lim1 + hypervisor.token1().balanceOf(address(hypervisor))

362:         uint256 spl = hypervisor.totalSupply(); 

372:         (uint256 amount,,,,,,,) = nftPool.getStakingPosition(tokenId); 

382:         (uint128 liq,,,, uint128 owed0, uint128 owed1) = IAlgebraPool(address(hypervisor.pool())).positions(key); 
```


```solidity
📁 File: StrategyGMXGM.sol

70:         IMarket.Props memory marketInfo = reader.getMarket(_dataStore, market); 

140:       IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))); 

149:         asset.approve(address(strategyHelper), amount); 

151:         uint256 val = strategyHelper.value(tokenShort, bal); 

162:         uint256 amt = (val * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort); 
163:         IERC20(tokenShort).approve(address(strategyHelper), amt);

173:         uint256 amount = (value * (10 ** IERC20(tokenShort).decimals())) / strategyHelper.price(tokenShort); 
174:         IERC20(tokenShort).transfer(to, amount);

193:         uint256 bal = IERC20(tokenLong).balanceOf(address(this)); 

195:             IERC20(tokenLong).approve(address(strategyHelper), bal); 

199:         bal = IERC20(tokenShort).balanceOf(address(this)); 
200:         uint256 have = strategyHelper.value(tokenShort, bal);

206:             IERC20(tokenShort).approve(address(strategyHelper), haf); 

227:             IMarket.Props memory marketInfo = reader.getMarket(dataStore, market); 

232:             IERC20(marketInfo.longToken).approve(router, out); 
233:             IERC20(marketInfo.shortToken).approve(router, amt - haf);

240:             exchangeRouter.multicall{value: params.executionFee}(data); 

244:             IMarket.Props memory marketInfo = reader.getMarket(dataStore, market); 

272:             IERC20(market).approve(exchangeRouter.router(), amt); 

276:             exchangeRouter.multicall{value: params.executionFee}(data); 

287:         IERC20(market).transfer(strategy, IERC20(market).balanceOf(address(this))); 
288:         IERC20(tokenLong).transfer(strategy, IERC20(tokenLong).balanceOf(address(this)));
289:         IERC20(tokenShort).transfer(strategy, IERC20(tokenShort).balanceOf(address(this)));

295:         uint256 val = strategyHelper.value(tokenLong, IERC20(tokenLong).balanceOf(address(this))); 
296:         val += strategyHelper.value(tokenShort, IERC20(tokenShort).balanceOf(address(this)));

298:         uint256 bal = IERC20(market).balanceOf(address(this)) + amountPendingDeposit + amountPendingWithdraw; 

307:         IMarket.Props memory marketInfo = r.getMarket(store, market); 

330:         uint256 price = strategyHelper.price(token); 

348:         uint256 bal = IERC20(tokenLong).balanceOf(address(this)); 
349:         IERC20(tokenLong).approve(address(strategyHelper), bal);
```


```solidity
📁 File: StrategySushiswap.sol

35:         pool = IUniswapV2Pair(rewarder.lpToken(poolId)); 

84:         uint256 price0 = strategyHelper.price(pair.token0()); 
85:         uint256 price1 = strategyHelper.price(pair.token1());

99:             asset.approve(address(strategyHelper), amount); 

102:             IERC20(tok0).transfer(address(pair), tok0.balanceOf(address(this))); 
103:             IERC20(tok1).transfer(address(pair), tok1.balanceOf(address(this)));

105:         pair.mint(address(this)); 
106:         pair.skim(address(this));
107:         uint256 liq = IERC20(address(pair)).balanceOf(address(this));
108:         IERC20(address(pair)).approve(address(rewarder), liq);

124:             pair.burn(address(this)); 

128:         uint256 bal0 = tok0.balanceOf(address(this)); 
129:         uint256 bal1 = tok1.balanceOf(address(this));
130:         tok0.approve(address(strategyHelper), bal0);
131:         tok1.approve(address(strategyHelper), bal1);

159:         rewarder.harvest(poolId, address(this)); 
160:         uint256 amt = rew.balanceOf(address(this));

162:         if (strategyHelper.value(address(rew), amt) < 0.5e18) return; 
163:         rew.approve(address(strategyHelper), amt);

166:         IERC20(pair.token0()).transfer(address(pair), IERC20(pair.token0()).balanceOf(address(this))); 
167:         IERC20(pair.token1()).transfer(address(pair), IERC20(pair.token1()).balanceOf(address(this)));
168:         pair.mint(address(this));
169:         pair.skim(address(this));
170:         uint256 liq = IERC20(address(pair)).balanceOf(address(this));
171:         IERC20(address(pair)).approve(address(rewarder), liq);

178:         (uint256 amt,) = rewarder.userInfo(poolId, address(this)); 

188:         totalShares = StrategySushiswap(old).totalShares(); 

190:         uint256 bal = lp.balanceOf(address(this)); 

192:         lp.approve(address(rewarder), bal); 
```


```solidity
📁 File: UtilFarmingBalances.sol

17:         uint256 max = i.nextPosition(); 

21:             (,,,,,uint256 value,) = i.positions(y); 
```


</details>


---
### [GAS&#x2011;71] Use assembly to perform efficient back-to-back calls
If a similar external call is performed back-to-back, we can use assembly to reuse any function signatures and function parameters that stay the same. In addition, we can also reuse the same memory space for each function call (`scratch space` + `free memory pointer` + `zero slot`), which can potentially allow us to avoid memory expansion costs.


Gas saved per Instance: ~300 *(Total: ~2,400)*

<i>There are 8 instaces of this issue:</i>

```solidity
📁 File: Investor.sol

479:         store.setUint(keccak256(abi.encode(id, POSITIONS_START)), p.start); 
480:         store.setUint(keccak256(abi.encode(id, POSITIONS_STRATEGY)), p.strategy);

482:         store.setUint(keccak256(abi.encode(id, POSITIONS_COLLATERAL)), p.collateral); 
483:         store.setUint(keccak256(abi.encode(id, POSITIONS_BORROW)), p.borrow);
484:         store.setUint(keccak256(abi.encode(id, POSITIONS_SHARES)), p.shares);
485:         store.setUint(keccak256(abi.encode(id, POSITIONS_BASIS)), p.basis);
```



---
### [GAS&#x2011;72] Use assembly to validate `msg.sender`
We can use assembly to efficiently validate msg.sender with the least amount of opcodes necessary. For more details check the following report [Here](https://code4rena.com/reports/2023-05-juicebox#g-06-use-assembly-to-validate-msgsender)


Gas saved per Instance: ~12 *(Total: ~204)*
<details>
<summary><i>There are 17 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

55:         require(msg.sender == address(lender), "!lender"); 
```


```solidity
📁 File: Investor.sol

257:             if (!whitelist.check(msg.sender)) revert NotWhitelisted(); 

303:         if (p.owner != msg.sender) revert NotOwner(); 
```


```solidity
📁 File: PositionManager.sol

145:         require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED"); 

190:         require( 
191:             to.code.length == 0
192:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "")
193:                     == ERC721TokenReceiver.onERC721Received.selector,
194:             "UNSAFE_RECIPIENT"
195:         );

200:         require( 
201:             to.code.length == 0
202:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)
203:                     == ERC721TokenReceiver.onERC721Received.selector,
204:             "UNSAFE_RECIPIENT"
205:         );

216:             if (!whitelist.check(msg.sender)) revert NotWhitelisted(); 

224:         require( 
225:             to.code.length == 0
226:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
227:                     == ERC721TokenReceiver.onERC721Received.selector,
228:             "UNSAFE_RECIPIENT"
229:         );
```


```solidity
📁 File: StrategyCamelotV3.sol

229:         if (!keepers[msg.sender]) revert NotKeeper(); 

391:         if (msg.sender == address(nftPool) && tokenId == 0) { 
```


```solidity
📁 File: StrategyGMXGM.sol

185:         if (!keepers[msg.sender]) revert NotKeeper(); 

336:         if (msg.sender != depositHandler) revert NotGMX(); 

341:         if (msg.sender != depositHandler) revert NotGMX(); 

346:         if (msg.sender != withdrawalHandler) revert NotGMX(); 

354:         if (msg.sender != withdrawalHandler) revert NotGMX(); 
```


```solidity
📁 File: StrategySushiswap.sol

154:         if (!keepers[msg.sender]) revert NotKeeper(); 
```


</details>


---
### [GAS&#x2011;73] Use `assembly` to write address/contract storage values
Using `assembly { sstore(state.slot, addr) }` instead of `state = addr` can save gas.


Gas saved per Instance: ~50 *(Total: ~2,900)*
<details>
<summary><i>There are 58 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

37:         investor = IInvestor(_investor); 
38:         asset = IERC20(_asset);
39:         lender = IAavePool(_lender);
40:         sh = IStrategyHelper(_sh);
```


```solidity
📁 File: Investor.sol

145:         store = IStore(_store); 
146:         helper = IHelper(_helper);

166:             whitelist = IWhitelist(data); 

168:             helper = IHelper(data); 

173:             strategyProxy = IStrategyProxy(data); 

271:         p.owner = msg.sender; 

274:         p.token = token; 

467:         p.owner = store.getAddress(keccak256(abi.encode(id, POSITIONS_OWNER))); 

470:         p.token = store.getAddress(keccak256(abi.encode(id, POSITIONS_TOKEN))); 

489:         s.implementation = store.getAddress(keccak256(abi.encode(id, STRATEGIES_ADDRESS))); 
```


```solidity
📁 File: InvestorStrategyProxy.sol

25:         asset = IERC20(_asset); 
```


```solidity
📁 File: PositionManager.sol

92:         investor = IInvestor(_investor); 

105:             investor = IInvestor(data); 

107:             whitelist = IWhitelist(data); 

115:         require((owner = _ownerOf[id]) != address(0), "NOT_MINTED"); 

146:         getApproved[id] = spender; 

178:         _ownerOf[id] = to; 
```


```solidity
📁 File: Store.sol

81:         addressValues[key] = value; 
```


```solidity
📁 File: StrategyCamelotV3.sol

61:         asset = IERC20(_asset); 
62:         strategyHelper = IStrategyHelper(_strategyHelper);

68:         nftPool = INFTPool(_nftPool); 
69:         targetAsset = _targetAsset;

96:             rewardToken1 = data; 

98:             rewardToken2 = data; 

100:             rewardToken3 = data; 

130:         nitroPool = INitroPool(_nitroPool); 

202:         assets[0] = address(hypervisor); 

285:         nftPool = StrategyCamelotV3(old).nftPool(); 
286:         nitroPool = StrategyCamelotV3(old).nitroPool();
```


```solidity
📁 File: StrategyGMXGM.sol

59:         asset = IERC20(_asset); 
60:         strategyHelper = IStrategyHelper(_strategyHelper);
61:         exchangeRouter = IExchangeRouter(_exchangeRouter);
62:         reader = IReader(_reader);
63:         depositHandler = _depositHandler;
64:         withdrawalHandler = _withdrawalHandler;
65:         depositVault = IHandler(_depositHandler).depositVault();
66:         withdrawalVault = IHandler(_withdrawalHandler).withdrawalVault();
67:         dataStore = _dataStore;
68:         market = _market;

71:         tokenLong = marketInfo.longToken; 
72:         tokenShort = marketInfo.shortToken;

100:             reader = IReader(data); 

102:             exchangeRouter = IExchangeRouter(data); 

104:             depositHandler = data; 
105:             depositVault = IHandler(data).depositVault();

107:             withdrawalHandler = data; 
108:             withdrawalVault = IHandler(data).withdrawalVault();

180:         assets[0] = tokenShort; 
```


```solidity
📁 File: StrategySushiswap.sol

31:         asset = IERC20(_asset); 
32:         strategyHelper = IStrategyHelper(_strategyHelper);
33:         rewarder = ISushiswapMiniChefV2(_rewarder);

35:         pool = IUniswapV2Pair(rewarder.lpToken(poolId)); 

149:         assets[0] = address(pool); 
```


```solidity
📁 File: UtilFarmingBalances.sol

24:               users[y-start] = abi.decode(data, (address)); 
```


</details>


---
### [GAS&#x2011;74] Use bitwise operators rather than boolean operators, to save gas
Instead of `((a != b) || (c != d))` use `((a ^ b) | (c ^ d))`


<i>There are 2 instaces of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

188:         if (amountPendingDeposit != 0 || amountPendingWithdraw != 0) { 

284:         if (amountPendingDeposit != 0 || amountPendingWithdraw != 0) { 
```



---
### [GAS&#x2011;75] Use `calldata` instead of `memory` for function arguments that do not get mutated
Mark data types as `calldata` instead of `memory` where possible. This makes it so that the data is not automatically loaded into memory. If the data passed into the function does not need to be changed (like updating values in an array), it can be passed in as `calldata`. The one exception to this is if the argument must later be passed into another function that takes an argument that specifies `memory` storage.


Gas saved per Instance: ~300 *(Total: ~6,600)*
<details>
<summary><i>There are 22 instances of this issue:</i></summary>

```solidity
📁 File: Store.sol

/// @audit value
100:     function setString(bytes32 key, string memory value) external auth returns (string memory) { 

/// @audit value
121:     function setBytes32Array(bytes32 key, bytes32[] memory value) external auth { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit _pathToLp
48:     constructor( 
49:         address _asset,
50:         address _strategyHelper,
51:         address _xgrail,
52:         address _strategyHelperUniswapV3,
53:         address _uniProxy,
54:         address _quoter,
55:         address _hypervisor,
56:         address _nftPool,
57:         address _targetAsset,
58:         bytes memory _pathToLp
59:     ) {

/// @audit minIn
433:     function deposit(uint256 deposit0, uint256 deposit1, address to, address pos, uint256[4] memory minIn) external returns (uint256 shares); 

/// @audit path
438:     function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut); 

/// @audit minAmounts
442:     function withdraw(uint256 shares, address to, address from, uint256[4] memory minAmounts) external returns (uint256 amount0, uint256 amount1); 

/// @audit _data
454:     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external; 
```


```solidity
📁 File: StrategyGMXGM.sol

335:     function afterDepositExecution(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 

340:     function afterDepositCancellation(bytes32, IDeposit.Props memory, IEventUtils.EventLogData memory) external { 

345:     function afterWithdrawalExecution(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 

353:     function afterWithdrawalCancellation(bytes32, IWithdrawal.Props memory, IEventUtils.EventLogData memory) external { 

/// @audit market
/// @audit indexTokenPrice
/// @audit longTokenPrice
/// @audit shortTokenPrice
479:     function getMarketTokenPrice( 

/// @audit market
/// @audit prices
488:     function getWithdrawalAmountOut( 
```


```solidity
📁 File: Whitelist.sol

/// @audit addresses
34:     function batchWhitelist(address[] memory addresses, bool status) external auth { 
```


</details>


---
### [GAS&#x2011;76] Use constants instead of `type(uint<n>).max` / `.min`

Gas saved per Instance: ~4 

<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyCamelotV3.sol

/// @audit 0xFFFFFFFF
111:             if (data > uint256(int256(type(int32).max))) revert TwapPeriodTooLong(); 
```



---
### [GAS&#x2011;77] Use custom errors rather than `revert()`/`require()` strings to save gas
[Source](https://blog.soliditylang.org/2021/04/21/custom-errors/)
Instead of using error strings, to reduce deployment and runtime cost, you should use Custom Errors. This would save both deployment and runtime cost.


Gas saved per Instance: ~29 *(Total: ~493)*
<details>
<summary><i>There are 17 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

55:         require(msg.sender == address(lender), "!lender"); 
56:         require(initiator == address(this), "!me");
```


```solidity
📁 File: PositionManager.sol

115:         require((owner = _ownerOf[id]) != address(0), "NOT_MINTED"); 

119:         require(owner != address(0), "ZERO_ADDRESS"); 

136:         require( 
137:             msg.sender == owner || isApprovedForAll[owner][msg.sender] || msg.sender == getApproved[id],
138:             "NOT_AUTHORIZED"
139:         );

145:         require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED"); 

183:         require(from == _ownerOf[id], "WRONG_FROM"); 
184:         require(to != address(0), "INVALID_RECIPIENT");

190:         require( 
191:             to.code.length == 0
192:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "")
193:                     == ERC721TokenReceiver.onERC721Received.selector,
194:             "UNSAFE_RECIPIENT"
195:         );

200:         require( 
201:             to.code.length == 0
202:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)
203:                     == ERC721TokenReceiver.onERC721Received.selector,
204:             "UNSAFE_RECIPIENT"
205:         );

221:         require(to != address(0), "INVALID_RECIPIENT"); 
222:         require(_ownerOf[id] == address(0), "ALREADY_MINTED");

224:         require( 
225:             to.code.length == 0
226:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
227:                     == ERC721TokenReceiver.onERC721Received.selector,
228:             "UNSAFE_RECIPIENT"
229:         );

246:         require(p.collateral == 0, "NOT_CLOSED"); 

248:         require(owner != address(0), "NOT_MINTED"); 

254:         require(owner != address(0), "NOT_MINTED"); 
```


```solidity
📁 File: StrategySushiswap.sol

187:         require(totalShares == 0, "ts=0"); 
```


</details>


---
### [GAS&#x2011;78] Use gas-efficient version of `min`()/`max`()
Prefer using `xor(a, mul(xor(a, b), gt(b, a)))` instead of `a > b ? a : b`
> ❗ Issue is removed from: (sme6en)

<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

513:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
514:         return a < b ? a : b;
515:     }
```


```solidity
📁 File: StrategyCamelotV3.sol

409:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
410:         return a < b ? a : b;
411:     }
```


```solidity
📁 File: StrategyGMXGM.sol

358:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
359:         return a < b ? a : b;
360:     }
```


```solidity
📁 File: StrategySushiswap.sol

196:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
197:         return a < b ? a : b;
198:     }
```


</details>


---
### [GAS&#x2011;79] Use `if` statements instead of ternary operators
https://gist.github.com/notbozho/0d9f4dbc0026f8e7771a4fa39244f57e

<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: StrategyCamelotV3.sol

163:         uint256 shares = tma == 0 ? liq : liq * totalShares / tma; 

302:         bytes memory path0 = trgtAst != address(hypervisor.token0()) ? path : bytes(""); 
303:         bytes memory path1 = trgtAst != address(hypervisor.token1()) ? path : bytes("");
```


```solidity
📁 File: StrategyGMXGM.sol

152:         uint256 shares = (tma == 0 || tot == 0) ? val : val * tot / tma; 

326:         uint256 decimals = isIndex ? indexTokenDecimals : 0; 
```


```solidity
📁 File: StrategySushiswap.sol

110:         uint256 shares = tma == 0 ? liq : liq * totalShares / tma; 
```


</details>


---
### [GAS&#x2011;80] Use immutable when you have storage variable that is not going to change
<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

34:     uint256 public slippage = 2500; 
```


```solidity
📁 File: StrategyCamelotV3.sol

8:     string public name; 
```


```solidity
📁 File: StrategyGMXGM.sol

5:     string public name; 
```


```solidity
📁 File: StrategySushiswap.sol

5:     string public name; 
```


</details>


---
### [GAS&#x2011;81] Use `revert()` to gain maximum gas savings
If you dont need Error messages, or you want gain maximum gas savings - `revert()` is the cheapest way to revert a transaction in terms of gas.

```solidity
	revert(); // 117 gas
	require(false); // 132 gas
	revert CustomError(); // 157 gas
	assert(false); // 164 gas
	revert("Custom Error"); // 406 gas
	require(false, "Custom Error"); // 421 gas
```
The gas savings are calculated based on the average gas cost of the total instances of these functions in the contract, minus the gas cost of `revert()` which is 117 gas.
> ❗ Issue is removed from: (sxima, sme6en)


Gas saved per Instance: ~291.452 *(Total: ~30,311)*
<details>
<summary><i>There are 104 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

22:         if (!exec[msg.sender]) revert Unauthorized(); 

30:             revert InvalidFile(); 

38:         if (!s) revert TransferFailed(); 

43:         if (!IERC20(token).transfer(to, amount)) revert TransferFailed(); 
```


```solidity
📁 File: Helper.sol

55:         require(msg.sender == address(lender), "!lender"); 
56:         require(initiator == address(this), "!me");
```


```solidity
📁 File: Investor.sol

151:         if (!exec[msg.sender]) revert Unauthorized(); 

156:         if (entered) revert NoReentering(); 

171:             if (helper.price(poolAsset) == 0) revert InvalidFile(); 

174:             if (!strategyProxy.exec(address(this))) revert InvalidFile(); 

177:             if (!IBank(data).exec(address(this))) revert InvalidFile(); 

180:             if (!IPool(data).exec(address(this))) revert InvalidFile(); 
181:             if (IPool(data).asset() == address(0)) revert InvalidFile();

183:             revert InvalidFile(); 

190:             if (data > 1e18) revert InvalidFile(); 

193:             if (data > 5000) revert InvalidFile(); 

196:             if (data > 1e18) revert InvalidFile(); 

199:             if (data > 1e18) revert InvalidFile(); 

202:             if (data == 0 || data > 4) revert InvalidFile(); 

205:             revert InvalidFile(); 

212:             revert StrategyExists(); 

257:             if (!whitelist.check(msg.sender)) revert NotWhitelisted(); 

263:         if (store.getUint(STATUS) < STATUS_LIVE || s.status < STATUS_LIVE) revert WrongStatus(); 

265:         if (collateralCap == 0) revert UnknownCollateral(); 

267:             revert CollateralOverCap(); 

278:             if (si.totalShares() == 0) revert StrategyUninitialized(); 

288:         if (_life(p) < 1e18) revert Undercollateralized(); 
289:         if (si.rate(si.totalShares()) > s.cap) revert StrategyOverCap();

303:         if (p.owner != msg.sender) revert NotOwner(); 
304:         if (borrow < 0 && uint256(-borrow) > p.shares) revert InvalidParameters();
305:         if (borrow > 0 && p.shares == 0) revert InvalidParameters();
306:         if (collateral < 0 && uint256(-collateral) > p.collateral) revert InvalidParameters();
307:         if (lastBlock[id] == block.number) revert NoEditingInSameBlock();

312:                 revert WrongStatus(); 

315:                 revert WrongStatus(); 

325:                 revert CollateralOverCap(); 

362:             if (si.totalShares() == 0) revert StrategyUninitialized(); 
363:             if (p.shares == 0) revert StrategyClosed();

382:         if (_life(p) < 1e18) revert Undercollateralized(); 
383:         if (borrow > 0 && si.rate(si.totalShares()) > s.cap) revert StrategyOverCap();

402:         if (_life(p) >= 1e18) revert PositionNotLiquidatable(); 
403:         if (store.getUint(STATUS) < STATUS_LIQUIDATE || s.status < STATUS_LIQUIDATE) revert WrongStatus();
404:         if (lastBlock[id] == block.number) revert NoEditingInSameBlock();

492:         if (s.implementation == address(0)) revert UnknownStrategy(); 

502:             revert TransferFailed(); 

509:             revert TransferFailed(); 
```


```solidity
📁 File: InvestorStrategyProxy.sol

30:         if (!exec[msg.sender]) revert Unauthorized(); 

38:             revert InvalidFile(); 
```


```solidity
📁 File: PositionManager.sol

97:         if (!exec[msg.sender]) revert Unauthorized(); 

109:             revert InvalidFile(); 

115:         require((owner = _ownerOf[id]) != address(0), "NOT_MINTED"); 

119:         require(owner != address(0), "ZERO_ADDRESS"); 

136:         require( 
137:             msg.sender == owner || isApprovedForAll[owner][msg.sender] || msg.sender == getApproved[id],
138:             "NOT_AUTHORIZED"
139:         );

145:         require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED"); 

183:         require(from == _ownerOf[id], "WRONG_FROM"); 
184:         require(to != address(0), "INVALID_RECIPIENT");

190:         require( 
191:             to.code.length == 0
192:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "")
193:                     == ERC721TokenReceiver.onERC721Received.selector,
194:             "UNSAFE_RECIPIENT"
195:         );

200:         require( 
201:             to.code.length == 0
202:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)
203:                     == ERC721TokenReceiver.onERC721Received.selector,
204:             "UNSAFE_RECIPIENT"
205:         );

216:             if (!whitelist.check(msg.sender)) revert NotWhitelisted(); 

221:         require(to != address(0), "INVALID_RECIPIENT"); 
222:         require(_ownerOf[id] == address(0), "ALREADY_MINTED");

224:         require( 
225:             to.code.length == 0
226:                 || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
227:                     == ERC721TokenReceiver.onERC721Received.selector,
228:             "UNSAFE_RECIPIENT"
229:         );

246:         require(p.collateral == 0, "NOT_CLOSED"); 

248:         require(owner != address(0), "NOT_MINTED"); 

254:         require(owner != address(0), "NOT_MINTED"); 

259:         if (!IERC20(ast).approve(address(investor), amt)) revert TransferFailed(); 

263:         if (!IERC20(ast).transferFrom(usr, address(this), amt)) revert TransferFailed(); 

269:         if (bal > 0 && !asset.transfer(usr, bal)) revert TransferFailed(); 
```


```solidity
📁 File: Store.sol

31:         if (!exec[msg.sender]) revert Unauthorized(); 

39:             revert InvalidFile(); 

54:         if (value > 0 && next < prev) revert OverOrUnderflow(); 
55:         if (value < 0 && next > prev) revert OverOrUnderflow();
```


```solidity
📁 File: StrategyCamelotV3.sol

74:             revert WrongTargetAsset(); 

79:         if (entered) revert NoReentering(); 

86:         if (!exec[msg.sender]) revert Unauthorized(); 

102:             revert InvalidFile(); 

111:             if (data > uint256(int256(type(int32).max))) revert TwapPeriodTooLong(); 

114:             revert InvalidFile(); 

124:         if (tokenId == 0) revert TokenIdNeededFirst(); 

162:         if (val < strategyHelper.value(address(asset), amount) * (10000 - slp) / 10000) revert PriceSlipped(); 

186:         if (strategyHelper.value(address(asset), bal) < val * (10000 - slp) / 10000) revert PriceSlipped(); 

229:         if (!keepers[msg.sender]) revert NotKeeper(); 
```


```solidity
📁 File: StrategyGMXGM.sol

83:         if (entered) revert NoReentering(); 

90:         if (!exec[msg.sender]) revert Unauthorized(); 

110:             revert InvalidFile(); 

121:             if (data > 10000) revert WrongReserveRatio(); 

128:             revert InvalidFile(); 

135:         if (!success) revert ErrorSendingETH(); 

139:       if (token == address(market) || token == tokenShort || token == tokenLong) revert BadToken(); 

185:         if (!keepers[msg.sender]) revert NotKeeper(); 

189:             revert ActionPending(); 

285:             revert ActionPending(); 

336:         if (msg.sender != depositHandler) revert NotGMX(); 

341:         if (msg.sender != depositHandler) revert NotGMX(); 

346:         if (msg.sender != withdrawalHandler) revert NotGMX(); 

354:         if (msg.sender != withdrawalHandler) revert NotGMX(); 
```


```solidity
📁 File: StrategySushiswap.sol

41:         if (entered) revert NoReentering(); 

48:         if (!exec[msg.sender]) revert Unauthorized(); 

58:             revert InvalidFile(); 

67:             revert InvalidFile(); 

154:         if (!keepers[msg.sender]) revert NotKeeper(); 

187:         require(totalShares == 0, "ts=0"); 
```


```solidity
📁 File: Whitelist.sol

19:         if (!exec[msg.sender]) revert Unauthorized(); 

29:             revert InvalidFile(); 
```


</details>


---
### [GAS&#x2011;82] Use scratch space when building emitted events
We can use assembly to emit events efficiently by utilizing `scratch space` and the `free memory pointer`. This will allow us to potentially avoid memory expansion costs.
Note: In order to do this optimization safely, we will need to cache and restore the free memory pointer.

For example, for a generic `emit` event for `eventSentAmountExample`: 
```solidity
// uint256 id, uint256 value, uint256 amount
emit eventSentAmountExample(id, value, amount);
```



Gas saved per Instance: ~38 *(Total: ~1,026)*
<details>
<summary><i>There are 27 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

32:         emit File(what, data); 
```


```solidity
📁 File: Investor.sol

185:         emit File(what, data); 

207:         emit File(what, data); 
```


```solidity
📁 File: InvestorStrategyProxy.sol

40:         emit File(what, data); 
```


```solidity
📁 File: PositionManager.sol

111:         emit File(what, data); 

152:         emit ApprovalForAll(msg.sender, operator, approved); 
```


```solidity
📁 File: Store.sol

41:         emit File(what, data); 
```


```solidity
📁 File: StrategyCamelotV3.sol

104:         emit File(what, data); 

116:         emit File(what, data); 

166:         emit Mint(amount, shares); 

189:         emit Burn(bal, shares); 

199:         emit Kill(amount, shares); 

273:         emit Earn(current, current - min(current, before)); 
```


```solidity
📁 File: StrategyGMXGM.sol

112:         emit File(what, data); 

130:         emit File(what, data); 

155:         emit Mint(amount, shares); 

167:         emit Burn(bal, shares); 

177:         emit Kill(amount, shares); 

280:         emit Earn(current, current - min(current, before)); 
```


```solidity
📁 File: StrategySushiswap.sol

60:         emit File(what, data); 

69:         emit File(what, data); 

113:         emit Mint(amount, shares); 

137:         emit Burn(amount, shares); 

146:         emit Kill(amount, shares); 

174:         emit Earn(current, current - min(current, before)); 
```


```solidity
📁 File: Whitelist.sol

31:         emit File(what, data); 

39:         emit BatchWhitelist(addresses, status); 
```


</details>


---
### [GAS&#x2011;83] Use `selfbalance()` instead of `address(this).balance`
Use assembly when getting a contract's balance of ETH.

You can use `selfbalance()` instead of `address(this).balance` when getting your contract's balance of ETH to save gas.
Additionally, you can use `balance(address)` instead of `address().balance` when getting an external contract's balance of ETH.

*Saves 15 gas when checking internal balance, 6 for external*


<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

134:         (bool success,) = address(msg.sender).call{value: address(this).balance}(""); 
```



---
### [GAS&#x2011;84] Use shift right/left instead of division/multiplication if possible
`<x> * 2` is the same as `<x> << 1`. While the compiler uses the `SHL` opcode to accomplish both, the version that uses multiplication incurs an overhead of **20 gas** due to `JUMP`s to and from a compiler utility function that introduces checks which can be avoided by using `unchecked {}` around the division by two.


Gas saved per Instance: ~20 *(Total: ~180)*
<details>
<summary><i>There are 9 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

392:         uint256 fee = borrow * killCollateralPadding / 10000 / 2; 

409:         uint256 fee = borrow * killCollateralPadding / 10000 / 2; 

419:             uint256 target = helper.value(poolAsset, borrow + (fee * 2)); 
```


```solidity
📁 File: StrategyCamelotV3.sol

298:         uint256 lp0Amt = amt / 2; 

314:         uint256 toLp0 = amt * 1e18 / ((((start + end) / 2) * 1e18 / out1) + 1e18); 
```


```solidity
📁 File: StrategyGMXGM.sol

205:             uint256 haf = amt / 2; 
```


```solidity
📁 File: StrategySushiswap.sol

86:         uint256 val = 2 * ((sqrt(reserve0 * reserve1) * sqrt(price0 * price1)) / tot); 

98:             uint256 haf = amount / 2; 

161:         uint256 haf = amt / 2; 
```


</details>


---
### [GAS&#x2011;85] Use short-circuit evaluation to avoid external calls

<i>There are 2 instaces of this issue:</i>

```solidity
📁 File: Investor.sol

/// @audit Move getUint to the right side 
263:         if (store.getUint(STATUS) < STATUS_LIVE || s.status < STATUS_LIVE) revert WrongStatus(); 

/// @audit Move getUint to the right side 
403:         if (store.getUint(STATUS) < STATUS_LIQUIDATE || s.status < STATUS_LIQUIDATE) revert WrongStatus(); 
```



---
### [GAS&#x2011;86] Use the inputs/results of assignments rather than re-reading state variables
When a state variable is assigned, it saves gas to use the value being assigned, later in the function, rather than re-reading the state variable itself. If needed, it can also be stored to a local variable, and be used in that way. Both options avoid a Gwarmaccess (**100 gas**). Note that if the operation is, say `+=`, the assignment also results in a value which can be used. The instances below point to the first reference after the assignment, since later references are already covered by issues describing the caching of state variable values.


Gas saved per Instance: ~97 *(Total: ~1,649)*
<details>
<summary><i>There are 17 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

/// @audit use result of assignment of helper, here
171:             if (helper.price(poolAsset) == 0) revert InvalidFile(); 

/// @audit use result of assignment of strategyProxy, here
174:             if (!strategyProxy.exec(address(this))) revert InvalidFile(); 

/// @audit use result of assignment of shares, here
/// @audit use result of assignment of shares, here
432:             if (shares > p.shares) shares = p.shares; 

/// @audit use result of assignment of shares, here
434:         bytes memory data = strategyProxy.kill(s.implementation, shares, msg.sender); 

/// @audit use result of assignment of shares, here
438:         p.shares = p.shares - shares; 

/// @audit use result of assignment of shares, here
442:         emit Kill(id, borrow, amount, collat, shares, fee); 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit use result of assignment of nitroPool, here
288:         if (address(nitroPool) != address(0)) { 
/// @audit use result of assignment of tokenId, here
/// @audit use result of assignment of nitroPool, here
/// @audit use result of assignment of nftPool, here
289:             nftPool.safeTransferFrom(address(this), address(nitroPool), tokenId, "");
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit use result of assignment of reader, here
70:         IMarket.Props memory marketInfo = reader.getMarket(_dataStore, market); 
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit use result of assignment of poolId, here
/// @audit use result of assignment of rewarder, here
35:         pool = IUniswapV2Pair(rewarder.lpToken(poolId)); 

/// @audit use result of assignment of pool, here
/// @audit use result of assignment of pool, here
37:             string(abi.encodePacked("SushiSwap ", IERC20(pool.token0()).symbol(), "/", IERC20(pool.token1()).symbol())); 

/// @audit use result of assignment of totalShares, here
191:         totalShares = bal; 
```


</details>


---
### [GAS&#x2011;87] Use `uint256(1)`/`uint256(2)` instead of `true`/`false`
Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from ‘false’ to ‘true’, after having been ‘true’ in the past. Refer to the [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5ae630684a0f57de400ef69499addab4c32ac8fb/contracts/security/ReentrancyGuard.sol#L23-L27).


Gas saved per Instance: ~17,100 *(Total: ~307,800)*
<details>
<summary><i>There are 18 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

9:     mapping(address => bool) public exec; 
```


```solidity
📁 File: Investor.sol

74:     bool internal entered; 

76:     mapping(address => bool) public exec; 
```


```solidity
📁 File: InvestorStrategyProxy.sol

17:     mapping(address => bool) public exec; 
```


```solidity
📁 File: PositionManager.sol

69:     mapping(address => bool) public exec; 

74:     mapping(address => mapping(address => bool)) public isApprovedForAll; 
```


```solidity
📁 File: Store.sol

5:     mapping(address => bool) public exec; 

9:     mapping(bytes32 => bool) public boolValues; 
```


```solidity
📁 File: StrategyCamelotV3.sol

14:     mapping(address => bool) public exec; 
15:     mapping(address => bool) public keepers;
```


```solidity
📁 File: StrategyGMXGM.sol

8:     bool internal entered; 

11:     mapping(address => bool) public exec; 
12:     mapping(address => bool) public keepers;
```


```solidity
📁 File: StrategySushiswap.sol

8:     bool internal entered; 

14:     mapping(address => bool) public exec; 
15:     mapping(address => bool) public keepers;
```


```solidity
📁 File: Whitelist.sol

5:     mapping(address => bool) public exec; 
6:     mapping(address => bool) public whitelist;
```


</details>


---
### [GAS&#x2011;88] Using `bool`s for storage incurs overhead
Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from ‘false’ to ‘true’, after having been ‘true’ in the past. See [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27).


Gas saved per Instance: ~17,100 *(Total: ~256,500)*
<details>
<summary><i>There are 15 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

74:     bool internal entered; 
```


```solidity
📁 File: StrategyGMXGM.sol

8:     bool internal entered; 

410:         bool shouldUnwrapNativeToken; 

424:         bool shouldUnwrapNativeToken; 

526:         bool shouldUnwrapNativeToken; 

557:         bool shouldUnwrapNativeToken; 

639:         bool value; 

644:         bool[] value; 
```


```solidity
📁 File: StrategySushiswap.sol

8:     bool internal entered; 
```


</details>


---
### [GAS&#x2011;89] Using `constant`s directly, rather than caching the value, saves gas

<i>There is one instance of this issue:</i>

```solidity
📁 File: StrategyGMXGM.sol

306:         address store = dataStore; 
```



---
### [GAS&#x2011;90] Using `private` rather than `public`, saves gas
For constants, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that returns a tuple of the values of all currently-public constants. Saves 3406-3606 gas in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table


Gas saved per Instance: ~3,606 *(Total: ~331,752)*
<details>
<summary><i>There are 92 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

9:     mapping(address => bool) public exec; 
```


```solidity
📁 File: Helper.sol

30:     IInvestor public investor; 
31:     IERC20 public asset;
32:     IAavePool public lender; // 0x794a61358D6845594F94dc1DB02A252b5b4814aD
33:     IStrategyHelper public sh;
34:     uint256 public slippage = 2500;
```


```solidity
📁 File: Investor.sol

66:     IStore public store; 
67:     IHelper public helper;
68:     IWhitelist public whitelist;
69:     IStrategyProxy public strategyProxy;
70:     uint256 public slippage = 200;
71:     uint256 public performanceFee = 2000;
72:     uint256 public killCollateralPadding = 500;
73:     uint256 public closeCollateralPadding = 400;

76:     mapping(address => bool) public exec; 

78:     uint256 public constant STATUS_LIVE = 4; 
79:     uint256 public constant STATUS_WITHDRAW = 3;
80:     uint256 public constant STATUS_LIQUIDATE = 2;
81:     uint256 public constant STATUS_PAUSED = 1;
```


```solidity
📁 File: InvestorStrategyProxy.sol

16:     IERC20 public asset; 
17:     mapping(address => bool) public exec;
```


```solidity
📁 File: PositionManager.sol

65:     string public constant name = "Rodeo V2 Position"; 
66:     string public constant symbol = "RP2";
67:     IInvestor public investor;
68:     IWhitelist public whitelist;
69:     mapping(address => bool) public exec;

73:     mapping(uint256 => address) public getApproved; 
74:     mapping(address => mapping(address => bool)) public isApprovedForAll;
```


```solidity
📁 File: Store.sol

5:     mapping(address => bool) public exec; 
6:     mapping(bytes32 => uint256) public uintValues;
7:     mapping(bytes32 => int256) public intValues;
8:     mapping(bytes32 => address) public addressValues;
9:     mapping(bytes32 => bool) public boolValues;
10:     mapping(bytes32 => string) public stringValues;
11:     mapping(bytes32 => bytes32) public bytes32Values;
12:     mapping(bytes32 => bytes32[]) public bytes32ArrayValues;
```


```solidity
📁 File: StrategyCamelotV3.sol

8:     string public name; 
9:     uint256 public totalShares = 1_000_000;
10:     uint256 public slippage = 500;

12:     IERC20 public asset; 
13:     IStrategyHelper public strategyHelper;
14:     mapping(address => bool) public exec;
15:     mapping(address => bool) public keepers;

17:     IXGrail public immutable xgrail; 
18:     IStrategyHelperUniswapV3 public immutable strategyHelperUniswapV3;
19:     IUniProxy public immutable uniProxy;
20:     IQuoter public immutable quoter;
21:     IHypervisor public immutable hypervisor;
22:     bytes public pathToLp; // UniV3 path from targetAsset to other asset
23:     address public targetAsset;
24:     INFTPool public nftPool;
25:     INitroPool public nitroPool;
26:     uint256 public tokenId;
27:     uint32 public twapPeriod = 43200;
28:     address public rewardToken1;
29:     address public rewardToken2;
30:     address public rewardToken3;
```


```solidity
📁 File: StrategyGMXGM.sol

5:     string public name; 
6:     uint256 public totalShares = 1_000_000;
7:     uint256 public slippage = 500;

9:     IERC20 public asset; 
10:     IStrategyHelper public strategyHelper;
11:     mapping(address => bool) public exec;
12:     mapping(address => bool) public keepers;

14:     IExchangeRouter public exchangeRouter; 
15:     IReader public reader;
16:     address public depositHandler;
17:     address public withdrawalHandler;
18:     address public depositVault;
19:     address public withdrawalVault;
20:     address public immutable dataStore;
21:     address public immutable market;
22:     address public immutable tokenLong; // Volatile
23:     address public immutable tokenShort; // Stable
24:     uint256 public indexTokenDecimals; // Optional, used to set sythetic index token decimals
25:     uint256 public amountPendingDeposit;
26:     uint256 public amountPendingWithdraw;
27:     uint256 public reserveRatio = 1000; // 10%
28:     uint256 public earnActionValue = 0.0015675e18;
29:     uint256 public callbackGasLimit = 500_000;
```


```solidity
📁 File: StrategySushiswap.sol

5:     string public name; 
6:     uint256 public totalShares = 1_000_000;
7:     uint256 public slippage = 500;

9:     IERC20 public asset; 
10:     IStrategyHelper public strategyHelper;
11:     ISushiswapMiniChefV2 public rewarder;
12:     IUniswapV2Pair public pool;
13:     uint256 public poolId;
14:     mapping(address => bool) public exec;
15:     mapping(address => bool) public keepers;
```


```solidity
📁 File: Whitelist.sol

5:     mapping(address => bool) public exec; 
6:     mapping(address => bool) public whitelist;
```


</details>


---
### [GAS&#x2011;91] Using `storage` instead of `memory` for structs/arrays saves gas
When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct


Gas saved per Instance: ~2,100 *(Total: ~67,200)*
<details>
<summary><i>There are 32 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

220:         Strategy memory s = getStrategy(index); 

228:         Strategy memory s = getStrategy(index); 

234:         Strategy memory s = getStrategy(index); 

261:         Strategy memory s = getStrategy(strategy); 

270:         Position memory p; 

300:         Position memory p = getPosition(id); 
301:         Strategy memory s = getStrategy(p.strategy); 

390:         Position memory p = getPosition(id); 

399:         Position memory p = getPosition(id); 
400:         Strategy memory s = getStrategy(p.strategy); 

447:         Position memory p = getPosition(id); 
```


```solidity
📁 File: PositionManager.sol

234:         IInvestor.Position memory p = investor.getPosition(id); 

245:         IInvestor.Position memory p = investor.getPosition(id); 

310:         IInvestor.Position memory p = investor.getPosition(id); 
311:         IInvestor.Strategy memory s = investor.getStrategy(p.strategy);

324:         IInvestor.Position memory p = investor.getPosition(id); 
325:         IInvestor.Strategy memory s = investor.getStrategy(p.strategy);

340:         IInvestor.Position memory p = investor.getPosition(id); 
```


```solidity
📁 File: StrategyCamelotV3.sol

201:         address[] memory assets = new address[](1); 

346:         uint32[] memory secondsAgos = new uint32[](2); 
```


```solidity
📁 File: StrategyGMXGM.sol

70:         IMarket.Props memory marketInfo = reader.getMarket(_dataStore, market); 

179:         address[] memory assets = new address[](1); 

212:             IExchangeRouter.CreateDepositParams memory params = IExchangeRouter.CreateDepositParams({ 
213:                 receiver: address(this),
214:                 callbackContract: address(this),
215:                 uiFeeReceiver: address(0),
216:                 market: market,
217:                 initialLongToken: tokenLong,
218:                 initialShortToken: tokenShort,
219:                 longTokenSwapPath: new address[](0),
220:                 shortTokenSwapPath: new address[](0),
221:                 minMarketTokens: minOut,
222:                 shouldUnwrapNativeToken: false,
223:                 executionFee: earnActionValue,
224:                 callbackGasLimit: callbackGasLimit
225:             });

227:             IMarket.Props memory marketInfo = reader.getMarket(dataStore, market); 
228:             bytes[] memory data = new bytes[](4);

244:             IMarket.Props memory marketInfo = reader.getMarket(dataStore, market); 

256:             IExchangeRouter.CreateWithdrawalParams memory params = IExchangeRouter.CreateWithdrawalParams({ 
257:                 receiver: address(this),
258:                 callbackContract: address(this),
259:                 uiFeeReceiver: address(0),
260:                 market: market,
261:                 longTokenSwapPath: new address[](0),
262:                 shortTokenSwapPath: new address[](0),
263:                 minLongTokenAmount: longOut * (10000 - slp) / 10000,
264:                 minShortTokenAmount: shortOut * (10000 - slp) / 10000,
265:                 shouldUnwrapNativeToken: false,
266:                 executionFee: earnActionValue,
267:                 callbackGasLimit: callbackGasLimit
268:             });

271:             bytes[] memory data = new bytes[](3); 

307:         IMarket.Props memory marketInfo = r.getMarket(store, market); 
```


```solidity
📁 File: StrategySushiswap.sol

148:         address[] memory assets = new address[](1); 
```


```solidity
📁 File: UtilFarmingBalances.sol

18:         address[] memory users = new address[](max-start); 
19:         uint256[] memory balances = new uint256[](max-start);
```


</details>


---
### [GAS&#x2011;92] `x + y` is more efficient than using `+=` for state variables (likewise for `-=`)
In instances found where either `+=` or -= are used against state variables use `x = x + y` instead


Gas saved per Instance: ~248 *(Total: ~2,232)*
<details>
<summary><i>There are 9 instances of this issue:</i></summary>

```solidity
📁 File: StrategyCamelotV3.sol

165:         totalShares += shares; 

188:         totalShares -= shares; 

198:         totalShares -= shares; 
```


```solidity
📁 File: StrategyGMXGM.sol

154:         totalShares += shares; 

166:         totalShares -= shares; 

176:         totalShares -= shares; 
```


```solidity
📁 File: StrategySushiswap.sol

112:         totalShares += shares; 

136:         totalShares -= shares; 

145:         totalShares -= shares; 
```


</details>


## Disputed


The issues below may be reported by other bots/wardens, but can be penalized/ignored since either the rule or the specified instances are invalid.

---
### [D&#x2011;1] ~~File allows a version of solidity that is susceptible to `.selector`-related optimizer bug~~
File uses a version of solidity that is susceptible to `.selector`-related optimizer bug, but does not use `.selector`.

<details>
<summary><i>There are 7 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Helper.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: Investor.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: InvestorStrategyProxy.sol

2: pragma solidity 0.8.17; 
```


```solidity
📁 File: Store.sol

2: pragma solidity ^0.8.0; 
```


```solidity
📁 File: StrategySushiswap.sol

2: pragma solidity 0.8.17; 
```


```solidity
📁 File: Whitelist.sol

2: pragma solidity ^0.8.0; 
```


</details>


---
### [D&#x2011;2] ~~Functions contain the same code~~
The rule is valid, but the following findings are invalid.

<details>
<summary><i>There are 23 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

495:     function getPool() public view returns (address) { 
496:         return store.getAddress(POOL);
497:     }

513:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
514:         return a < b ? a : b;
515:     }
```


```solidity
📁 File: InvestorStrategyProxy.sol

54:     function kill(address strategy, uint256 shares, address target) public auth returns (bytes memory) { 
55:         return IStrategy(strategy).kill(shares, target);
56:     }
```


```solidity
📁 File: PositionManager.sol

123:     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) { 
124:         return _ownerIds[owner].values[index];
125:     }

208:     function supportsInterface(bytes4 interfaceId) public pure returns (bool) { 
209:         return interfaceId == 0x01ffc9a7 // ERC165
210:             || interfaceId == 0x80ac58cd // ERC721
211:             || interfaceId == 0x5b5e139f; // ERC721Metadata
212:     }

293:     function generateImage(uint256 id) private view returns (string memory) { 
294:         return Base64.encode(
295:             abi.encodePacked(
296:                 '<svg width="290" height="290" viewBox="0 0 290 290" xmlns="http://www.w3.org/2000/svg"',
297:                 " xmlns:xlink='http://www.w3.org/1999/xlink'>",
298:                 '<defs><clipPath id="corners"><rect width="290" height="290" rx="42" ry="42" /></clipPath><linearGradient id="0" x1="0.5" y1="0" x2="0.5" y2="1"><stop offset="0%" stop-color="#f3a526"/><stop offset="100%" stop-color="#e7940b"/></linearGradient><radialGradient id="1" gradientTransform="translate(-1 -0.5) scale(2, 2)"><stop offset="10%" stop-color="#f3a526"/><stop offset="100%" stop-color="#ffca74"/></radialGradient></defs>',
299:                 '<g clip-path="url(#corners)"><rect fill="url(#0)" x="0px" y="0px" width="290px" height="290px" /><rect fill="url(#1)" x="0px" y="0px" width="290px" height="290px" /><ellipse cx="50%" cy="32px" rx="220px" ry="120px" fill="rgba(255,255,255,0.2)" opacity="0.85" /><rect x="16" y="16" width="258" height="258" rx="26" ry="26" fill="rgba(0,0,0,0)" stroke="rgba(255,255,255,0.4)" />',
300:                 generateHeader(id),
301:                 generateLabelVal(id),
302:                 generateLabelBor(id),
303:                 generateLabelLif(id),
304:                 "</g></svg>"
305:             )
306:         );
307:     }
```


```solidity
📁 File: Store.sol

44:     function getUint(bytes32 key) external view returns (uint256) { 
45:         return uintValues[key];
46:     }

62:     function getInt(bytes32 key) external view returns (int256) { 
63:         return intValues[key];
64:     }

77:     function getAddress(bytes32 key) external view returns (address) { 
78:         return addressValues[key];
79:     }

87:     function getBool(bytes32 key) external view returns (bool) { 
88:         return boolValues[key];
89:     }

97:     function getString(bytes32 key) external view returns (string memory) { 
98:         return stringValues[key];
99:     }

107:     function getBytes32(bytes32 key) external view returns (bytes32) { 
108:         return bytes32Values[key];
109:     }

118:     function getBytes32Array(bytes32 key) external view returns (bytes32[] memory) { 
119:         return bytes32ArrayValues[key];
120:     }

128:     function containsBytes32(bytes32 key, bytes32 value) external view returns (bool) { 
129:         return bytes32Sets[key].positions[value] != 0;
130:     }
131:     function getBytes32Count(bytes32 key) external view returns (uint256) {
132:         return bytes32Sets[key].values.length;
133:     }
```


```solidity
📁 File: StrategyCamelotV3.sol

293:     function rate(uint256 shares) public view returns (uint256) { 
294:         return shares * valueLiquidity() / totalShares;
295:     }

397:     function onNFTHarvest(address, address, uint256, uint256, uint256) public pure returns (bool) { 
398:         return true;
399:     }

401:     function onNFTAddToPosition(address, uint256, uint256) public pure returns (bool) { 
402:         return true;
403:     }

405:     function onNFTWithdraw(address, uint256, uint256) public pure returns (bool) { 
406:         return true;
407:     }

409:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
410:         return a < b ? a : b;
411:     }
```


```solidity
📁 File: StrategyGMXGM.sol

358:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
359:         return a < b ? a : b;
360:     }
```


```solidity
📁 File: StrategySushiswap.sol

196:     function min(uint256 a, uint256 b) internal pure returns (uint256) { 
197:         return a < b ? a : b;
198:     }
```


```solidity
📁 File: Whitelist.sol

42:     function check(address user) external view returns (bool) { 
43:         return whitelist[user];
44:     }
```


</details>


---
### [D&#x2011;3] ~~Functions should be named in mixedCase style~~
The rule is valid, but the following findings are invalid.

<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

/// @audit onERC721Received
60:     function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4); 

/// @audit tokenURI
272:     function tokenURI(uint256 id) public view returns (string memory) { 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit onERC721Received
390:     function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external returns (bytes4) { 

/// @audit onNFTHarvest
397:     function onNFTHarvest(address, address, uint256, uint256, uint256) public pure returns (bool) { 

/// @audit onNFTAddToPosition
401:     function onNFTAddToPosition(address, uint256, uint256) public pure returns (bool) { 

/// @audit onNFTWithdraw
405:     function onNFTWithdraw(address, uint256, uint256) public pure returns (bool) { 
```


</details>


---
### [D&#x2011;4] ~~`abi.encode()` is less efficient than `abi.encodePacked()` for non-address arguments~~
The rule is valid, but the following findings are invalid.

<details>
<summary><i>There are 10 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

240:         uint256 cap = store.getUint(keccak256(abi.encode(token, COLLATERAL_CAP))); 
241:         store.setUint(keccak256(abi.encode(token, COLLATERAL_FACTOR)), factor);

246:         uint256 factor = store.getUint(keccak256(abi.encode(token, COLLATERAL_FACTOR))); 
247:         store.setUint(keccak256(abi.encode(token, COLLATERAL_CAP)), cap);

264:         uint256 collateralCap = store.getUint(keccak256(abi.encode(token, COLLATERAL_CAP))); 

323:             uint256 collateralCap = store.getUint(keccak256(abi.encode(p.token, COLLATERAL_CAP))); 

456:         uint256 factor = store.getUint(keccak256(abi.encode(p.token, COLLATERAL_FACTOR))); 
```


```solidity
📁 File: StrategyCamelotV3.sol

203:         return abi.encode(bytes32("camelotv3"), assets); 
```


```solidity
📁 File: StrategyGMXGM.sol

181:         return abi.encode(bytes32("gmxgm"), assets); 
```


```solidity
📁 File: StrategySushiswap.sol

150:         return abi.encode(bytes32("sushi"), assets); 
```


</details>


---
### [D&#x2011;5] ~~Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`~~
There are not enough mappings to combine.


<i>There is one instance of this issue:</i>

```solidity
📁 File: Investor.sol

75:     mapping(uint256 => uint256) private lastBlock; 
```



---
### [D&#x2011;6] ~~Stack variable is only used once~~
The following stack variables are used as cache for a loop.


<i>There is one instance of this issue:</i>

```solidity
📁 File: Whitelist.sol

35:         uint256 l = addresses.length; 
```



---
### [D&#x2011;7] ~~State variable read in a loop~~
The following variables aren't read from storage, but from stack variables that shadow storage variables.

<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

/// @audit v, i, start
129:         for (uint256 i = start; i < end; i++) { 
```


```solidity
📁 File: Store.sol

/// @audit v, i, start
136:         for (uint256 i = start; i < end; i++) { 
```


```solidity
📁 File: UtilFarmingBalances.sol

/// @audit users, y, start, balances
20:         for (uint256 y = start; y < max; y++) { 
```


```solidity
📁 File: Whitelist.sol

/// @audit addresses, i
36:         for (uint256 i = 0; i < l; i++) { 
```


</details>


---
### [D&#x2011;8] ~~Use local variables for emitting~~
The following arguments aren't read from storage, but from stack variables that shadow storage variables.


<i>There are 15 instaces of this issue:</i>

```solidity
📁 File: Investor.sol

/// @audit 'implementation' is being shadowed here.
210:     function strategyNew(uint256 index, address implementation) external auth { 
211:         if (store.getAddress(keccak256(abi.encode(index, STRATEGIES_ADDRESS))) != address(0)) {
212:             revert StrategyExists();
213:         }
214:         store.setAddress(keccak256(abi.encode(index, STRATEGIES_ADDRESS)), implementation);
215:         store.setUint(keccak256(abi.encode(index, STRATEGIES_STATUS)), 4);
216:         emit StrategyUpdate(index, implementation, 4, 0);
217:     }

/// @audit 'implementation' is being shadowed here.
219:     function strategyUgrade(uint256 index, address implementation) external auth { 
220:         Strategy memory s = getStrategy(index);
221:         IStrategy(s.implementation).exit(implementation);
222:         IStrategy(implementation).move(s.implementation);
223:         store.setAddress(keccak256(abi.encode(index, STRATEGIES_ADDRESS)), implementation);
224:         emit StrategyUpdate(index, implementation, s.status, s.cap);
225:     }

/// @audit 'status' is being shadowed here.
227:     function strategySetStatus(uint256 index, uint256 status) external auth { 
228:         Strategy memory s = getStrategy(index);
229:         store.setUint(keccak256(abi.encode(index, STRATEGIES_STATUS)), status);
230:         emit StrategyUpdate(index, s.implementation, status, s.cap);
231:     }

/// @audit 'cap' is being shadowed here.
233:     function strategySetCap(uint256 index, uint256 cap) external auth { 
234:         Strategy memory s = getStrategy(index);
235:         store.setUint(keccak256(abi.encode(index, STRATEGIES_CAP)), cap);
236:         emit StrategyUpdate(index, s.implementation, s.status, cap);
237:     }

/// @audit 'token' is being shadowed here.
239:     function collateralSetFactor(address token, uint256 factor) external auth { 
/// @audit 'cap' is being shadowed here.
240:         uint256 cap = store.getUint(keccak256(abi.encode(token, COLLATERAL_CAP)));
241:         store.setUint(keccak256(abi.encode(token, COLLATERAL_FACTOR)), factor);
242:         emit CollateralUpdate(token, factor, cap);
243:     }

/// @audit 'token' is being shadowed here.
/// @audit 'cap' is being shadowed here.
245:     function collateralSetCap(address token, uint256 cap) external auth { 
246:         uint256 factor = store.getUint(keccak256(abi.encode(token, COLLATERAL_FACTOR)));
247:         store.setUint(keccak256(abi.encode(token, COLLATERAL_CAP)), cap);
248:         emit CollateralUpdate(token, factor, cap);
249:     }

/// @audit 'strategy' is being shadowed here.
/// @audit 'token' is being shadowed here.
/// @audit 'collateral' is being shadowed here.
/// @audit 'borrow' is being shadowed here.
255:     function open(uint256 strategy, address token, uint256 collateral, uint256 borrow) external loop returns (uint256) { 
256:         if (address(whitelist) != address(0)) {
257:             if (!whitelist.check(msg.sender)) revert NotWhitelisted();
258:         }
259:         uint256 id = store.setUintDelta(POSITIONS, 1);
260:         lastBlock[id] = block.number;
261:         Strategy memory s = getStrategy(strategy);
262:         IStrategy si = IStrategy(s.implementation);
263:         if (store.getUint(STATUS) < STATUS_LIVE || s.status < STATUS_LIVE) revert WrongStatus();
264:         uint256 collateralCap = store.getUint(keccak256(abi.encode(token, COLLATERAL_CAP)));
265:         if (collateralCap == 0) revert UnknownCollateral();
266:         if (IERC20(token).balanceOf(store.getAddress(BANK)) + collateral > collateralCap) {
267:             revert CollateralOverCap();
268:         }
269: 
270:         Position memory p;
271:         p.owner = msg.sender;
272:         p.start = block.timestamp;
273:         p.strategy = strategy;
274:         p.token = token;
275:         p.collateral = collateral;
276: 
277:         {
278:             if (si.totalShares() == 0) revert StrategyUninitialized();
279:             IPool pool = IPool(store.getAddress(POOL));
280:             address poolAsset = pool.asset();
281:             pullToBank(token, msg.sender, collateral);
282:             p.borrow = pool.borrow(borrow);
283:             push(poolAsset, address(strategyProxy), borrow);
284:             p.shares = strategyProxy.mint(address(si), borrow);
285:             p.basis = si.rate(p.shares);
286:         }
287: 
288:         if (_life(p) < 1e18) revert Undercollateralized();
289:         if (si.rate(si.totalShares()) > s.cap) revert StrategyOverCap();
290:         setPosition(id, p);
291:         emit Open(id, borrow, collateral, strategy, token);
292:         return id;
293:     }

/// @audit 'borrow' is being shadowed here.
295:     function edit(uint256 id, int256 borrow, int256 collateral) external loop { 
296:         IBank bank = IBank(store.getAddress(BANK));
297:         IPool pool = IPool(store.getAddress(POOL));
298:         int256 collateralAdjusted = collateral;
299:         address poolAsset = pool.asset();
300:         Position memory p = getPosition(id);
301:         Strategy memory s = getStrategy(p.strategy); 
302:         IStrategy si = IStrategy(s.implementation);
303:         if (p.owner != msg.sender) revert NotOwner();
304:         if (borrow < 0 && uint256(-borrow) > p.shares) revert InvalidParameters();
305:         if (borrow > 0 && p.shares == 0) revert InvalidParameters();
306:         if (collateral < 0 && uint256(-collateral) > p.collateral) revert InvalidParameters();
307:         if (lastBlock[id] == block.number) revert NoEditingInSameBlock();
308:         lastBlock[id] = block.number;
309:         {
310:             uint256 status = store.getUint(STATUS);
311:             if (borrow > 0 && (status < STATUS_LIVE || s.status < STATUS_LIVE)) {
312:                 revert WrongStatus();
313:             }
314:             if (borrow <= 0 && (status < STATUS_WITHDRAW || s.status < STATUS_WITHDRAW)) {
315:                 revert WrongStatus();
316:             }
317:         }
318: 
319:         // 1. Adjust collateral
320:         if (collateral > 0) {
321:             pullToBank(p.token, msg.sender, uint256(collateral));
322:             p.collateral = p.collateral + uint256(collateral);
323:             uint256 collateralCap = store.getUint(keccak256(abi.encode(p.token, COLLATERAL_CAP)));
324:             if (IERC20(p.token).balanceOf(store.getAddress(BANK)) > collateralCap) {
325:                 revert CollateralOverCap();
326:             }
327:         }
328: 
329:         // 2. Sell strategy shares to repay loan
330:         if (borrow < 0) {
331:             p.basis = p.basis - min(p.basis, si.rate(uint256(-borrow)));
332:             uint256 amount = strategyProxy.burn(address(si), uint256(-borrow));
333:             p.shares = p.shares - uint256(-borrow);
334:             uint256 index = pool.getUpdatedIndex();
335:             uint256 repaying = amount * 1e18 / index;
336:             if (repaying > p.borrow) repaying = p.borrow;
337:             // If closing the position, make sure we repay the whole borrow
338:             if (p.shares == 0) {
339:                 p.basis = 0;
340:                 repaying = p.borrow;
341:                 uint256 needed = p.borrow * index / 1e18;
342:                 if (needed > amount) {
343:                     // If we don't have enough USDC from shares, sell some collateral
344:                     uint256 cAmount = helper.convert(poolAsset, p.token, needed - amount);
345:                     cAmount = cAmount * (10000 + closeCollateralPadding) / 10000;
346:                     if (cAmount > p.collateral) cAmount = p.collateral;
347:                     bank.transfer(p.token, address(this), cAmount);
348:                     IERC20(p.token).approve(address(helper), cAmount);
349:                     uint256 topup = helper.swap(p.token, poolAsset, cAmount, slippage, address(this));
350:                     amount = amount + topup;
351:                     p.collateral = p.collateral - cAmount;
352:                 }
353:             }
354:             IERC20(poolAsset).approve(address(pool), amount);
355:             uint256 used = pool.repay(repaying);
356:             p.borrow = p.borrow - repaying;
357:             push(poolAsset, msg.sender, (amount - used) * (10000 - performanceFee) / 10000);
358:         }
359: 
360:         // 3. Borrow more from pool and mint strategy shares
361:         if (borrow > 0) {
362:             if (si.totalShares() == 0) revert StrategyUninitialized();
363:             if (p.shares == 0) revert StrategyClosed();
364:             p.borrow = p.borrow + pool.borrow(uint256(borrow));
365:             push(poolAsset, address(strategyProxy), uint256(borrow));
366:             uint256 shares = strategyProxy.mint(address(si), uint256(borrow));
367:             p.shares = p.shares + shares;
368:             p.basis = p.basis + si.rate(shares);
369:         }
370: 
371:         // 4. Withdraw collateral asked for
372:         if (collateral < 0) {
373:             uint256 amt = uint256(-collateral);
374:             // Allow a user to ask for all it's collateral but support some being taken away
375:             // as topup for the repayment of the debt
376:             if (amt > p.collateral) amt = p.collateral;
377:             collateralAdjusted = -int256(amt);
378:             p.collateral = p.collateral - amt;
379:             bank.transfer(p.token, msg.sender, amt);
380:         }
381: 
382:         if (_life(p) < 1e18) revert Undercollateralized();
383:         if (borrow > 0 && si.rate(si.totalShares()) > s.cap) revert StrategyOverCap();
384:         setPosition(id, p);
385:         emit Edit(id, borrow, collateralAdjusted);
386:     }

396:     function kill(uint256 id) external loop returns (address, bytes memory) { 
397:         IBank bank = IBank(store.getAddress(BANK));
398:         IPool pool = IPool(store.getAddress(POOL));
399:         Position memory p = getPosition(id);
400:         Strategy memory s = getStrategy(p.strategy); 
401:         address poolAsset = pool.asset();
402:         if (_life(p) >= 1e18) revert PositionNotLiquidatable();
403:         if (store.getUint(STATUS) < STATUS_LIQUIDATE || s.status < STATUS_LIQUIDATE) revert WrongStatus();
404:         if (lastBlock[id] == block.number) revert NoEditingInSameBlock();
405:         lastBlock[id] = block.number;
406: 
407:         // Repay borrow using liquidator funds
/// @audit 'borrow' is being shadowed here.
408:         uint256 borrow = p.borrow * pool.getUpdatedIndex() / 1e18;
409:         uint256 fee = borrow * killCollateralPadding / 10000 / 2;
410:         IERC20(poolAsset).transferFrom(msg.sender, address(this), borrow + fee);
411:         IERC20(poolAsset).approve(address(pool), borrow);
412:         pool.repay(p.borrow);
413: 
414:         uint256 amount = IStrategy(s.implementation).rate(p.shares);
/// @audit 'shares' is being shadowed here.
415:         uint256 shares;
416:         uint256 collat;
417:         {
418:             // Transfer collateral to liquidator
419:             uint256 target = helper.value(poolAsset, borrow + (fee * 2));
420:             if (amount < target) {
421:                 // Only use collateral if needed, some "in profit" position
422:                 // could be liquidatable if "expired/forced to exit"
423:                 collat = (target - amount) * 1e18 / helper.price(p.token);
424:                 if (collat > p.collateral) collat = p.collateral;
425:                 bank.transfer(p.token, msg.sender, collat);
426:             }
427: 
428:             // Transfer underlying to liquidator
429:             // scale shares to target. when just repaying borrow on an in
430:             // profit position, we don't want to use all shares
431:             shares = p.shares * target / amount;
432:             if (shares > p.shares) shares = p.shares;
433:         }
434:         bytes memory data = strategyProxy.kill(s.implementation, shares, msg.sender);
435: 
436:         // Update state
437:         p.collateral = p.collateral - collat;
438:         p.shares = p.shares - shares;
439:         p.borrow = 0;
440:         setPosition(id, p);
441: 
442:         emit Kill(id, borrow, amount, collat, shares, fee);
443:         return (p.token, data);
444:     }
```



---
### [D&#x2011;9] ~~All interfaces used within a project should be imported~~
These contracts don't rely on other contracts for their definitions, so there's nothing to import

<details>
<summary><i>There are 63 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

4: interface IERC20 { 

8: contract Bank { 
```


```solidity
📁 File: Helper.sol

4: interface IERC20 { 

10: interface IInvestor { 

15: interface IAavePool { 

19: interface IStrategyHelper { 

23: interface ISushi { 

29: contract Helper { 
```


```solidity
📁 File: Investor.sol

4: interface IERC20 { 

12: interface IOracle { 

17: interface IStore { 

26: interface IBank { 

31: interface IPool { 

40: interface IHelper { 

47: interface IStrategy { 

54: interface IStrategyProxy { 

61: interface IWhitelist { 

65: contract Investor { 
```


```solidity
📁 File: InvestorStrategyProxy.sol

4: interface IERC20 { 

9: interface IStrategy { 

15: contract InvestorStrategyProxy { 
```


```solidity
📁 File: PositionManager.sol

7: interface IERC20 { 

15: interface IOracle { 

20: interface IPool { 

26: interface IStrategy { 

31: interface IInvestor { 

55: interface IWhitelist { 

59: interface ERC721TokenReceiver { 

64: contract PositionManager { 
```


```solidity
📁 File: Store.sol

4: contract Store { 
```


```solidity
📁 File: StrategyCamelotV3.sol

7: contract StrategyCamelotV3 { 

414: interface IERC20 { 

422: interface IStrategyHelper { 

428: interface IStrategyHelperUniswapV3 { 

432: interface IUniProxy { 

437: interface IQuoter { 

453: interface INFTPool { 

466: interface INitroPool { 

471: interface IAlgebraPool { 

490: interface IXGrail { 
```


```solidity
📁 File: StrategyGMXGM.sol

4: contract StrategyGMXGM { 

363: interface IERC20 { 

372: interface IStrategyHelper { 

378: interface IHandler { 

383: interface IPriceFeed { 

393: interface IDataStore { 

399: interface IExchangeRouter { 

437: interface IMarket { 

454: interface IPrice { 

461: interface IMarketPoolValueInfo { 

477: interface IReader { 

497: interface IDeposit { 

530: interface IWithdrawal { 

561: interface IEventUtils { 
```


```solidity
📁 File: StrategySushiswap.sol

4: contract StrategySushiswap { 

253: interface IERC20 { 

262: interface IStrategyHelper { 

268: interface IUniswapV2Pair { 

281: interface ISushiswapMiniChefV2 { 
```


```solidity
📁 File: UtilFarmingBalances.sol

4: interface IInvestor { 

9: interface IPositionManager { 

13: contract UtilFarmingBalances { 
```


```solidity
📁 File: Whitelist.sol

4: contract Whitelist { 
```


</details>


---
### [D&#x2011;10] ~~Array lengths not checked~~
These instances only have one array

<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: Store.sol

121:     function setBytes32Array(bytes32 key, bytes32[] memory value) external auth { 
```


```solidity
📁 File: Whitelist.sol

34:     function batchWhitelist(address[] memory addresses, bool status) external auth { 
```


</details>


---
### [D&#x2011;11] ~~Avoid unnecessary `public` variables~~
The general rule is valid, but the instances below are invalid

<details>
<summary><i>There are 3 instances of this issue:</i></summary>

```solidity
📁 File: StrategyCamelotV3.sol

24:     INFTPool public nftPool; 

26:     uint256 public tokenId; 
```


```solidity
📁 File: StrategySushiswap.sol

6:     uint256 public totalShares = 1_000_000; 
```


</details>


---
### [D&#x2011;12] ~~Bad bot rules~~
The titles below correspond to issues submitted by various bots, where the submitting bot solely submitted invalid findings (i.e. the submitter didn't filter the results of the rule), so they should be given extra scrutiny:
- **Max allowance is not compatible with all tokens** - internal approval for the contract's own balance, so the rule is pointing to the support **for** max allowance
- **increase/decrease allowance should be used instead of approve** - this is an internal approval function
- **Must approve or increase allowance first** - the rule is flagging all transferFrom() calls, without approval logic
- **Contract existence is not checked before low level call** - reading calldata, not making an external call
- **Empty function blocks** - the bot's removed the extensive comment documentation in the 'code blocks' it shows for these virtual functions used to allow child contracts to implement functionality, or are constructors
- **Utility contracts can be made into libraries** - all provided examples are invalid
- **Address values should be used through variables rather than used as literals** - none of the examples are of addresses
- **Employ Explicit Casting to Bytes or Bytes32 for Enhanced Code Clarity and Meaning** - the large majority of the examples are of multiple arguments, not just one
- **Some if-statement can be converted to a ternary** - you can't use a ternary when only one of the branches is a `return`
- **Addresses shouldn't be hard-coded** - none of these are addresses
- **State variables used within a function more than once should be cached to save gas** - none of these are state variables
- **Use storage instead of memory for structs/arrays** - these all are array call arguments, not arrays copied from storage
- **Use bitmap to save gas** - none of these are examples where bitmaps can be used
- **Consider merging sequential for loops** - the examples cannot be merged
- **Emitting storage values instead of the memory one.** - this is a gas finding, not a Low one
- **`selfbalance()` is cheaper than `address(this).balance`** - some bots submit the issue twice (under the heading `Use assembly when getting a contractundefineds balance of ETH`)
- **Imports could be organized more systematically** - a lot of bots are blindly checking for interfaces not coming first. That is not the only way of organizing imports, and most projects are doing it in a systematic, valid, way
- **Unused * definition** - some bots are reporting false positives for these rules. Check that it isn't used, or that if it's used, that there are two definitions, with one being unused
- **`internal` functions not called by the contract should be removed** - some bots are reporting false positives when the function is called by a child contract, rather than the defining contract
- **Change `public` to `external` for functions that are not called internally** - some bots are reporting false positives when the function is called by a child contract, rather than the defining contract
- **Avoid contract existence checks by using low level calls** - at least one bot isn't checking that the version is prior to 0.8.10
- **For Operations that will not overflow, you could use unchecked** - at least one bot is flagging every single line, which has nothing to do with using `unchecked`

Some of these have been raised as invalid in multiple contests, and the bot owners have not fixed them. Without penalties, they're unlikely to make any changes


---
### [D&#x2011;13] ~~Consider adding a block/deny-list~~
Contract doesn't handle tokens

<details>
<summary><i>There are 11 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

8: contract Bank { 
9:     mapping(address => bool) public exec;
10: 
11:     event File(bytes32 indexed what, address data);
12: 
13:     error InvalidFile();
14:     error Unauthorized();
15:     error TransferFailed();
16: 
17:     constructor() {
18:         exec[msg.sender] = true;
```


```solidity
📁 File: Helper.sol

29: contract Helper { 
30:     IInvestor public investor;
31:     IERC20 public asset;
32:     IAavePool public lender; // 0x794a61358D6845594F94dc1DB02A252b5b4814aD
33:     IStrategyHelper public sh;
34:     uint256 public slippage = 2500;
35: 
36:     constructor(address _investor, address _asset, address _lender, address _sh) {
37:         investor = IInvestor(_investor);
38:         asset = IERC20(_asset);
39:         lender = IAavePool(_lender);
```


```solidity
📁 File: Investor.sol

65: contract Investor { 
66:     IStore public store;
67:     IHelper public helper;
68:     IWhitelist public whitelist;
69:     IStrategyProxy public strategyProxy;
70:     uint256 public slippage = 200;
71:     uint256 public performanceFee = 2000;
72:     uint256 public killCollateralPadding = 500;
73:     uint256 public closeCollateralPadding = 400;
74:     bool internal entered;
75:     mapping(uint256 => uint256) private lastBlock;
```


```solidity
📁 File: InvestorStrategyProxy.sol

15: contract InvestorStrategyProxy { 
16:     IERC20 public asset;
17:     mapping(address => bool) public exec;
18: 
19:     event File(bytes32 indexed what, address data);
20: 
21:     error InvalidFile();
22:     error Unauthorized();
23: 
24:     constructor(address _asset) {
25:         asset = IERC20(_asset);
```


```solidity
📁 File: PositionManager.sol

64: contract PositionManager { 
65:     string public constant name = "Rodeo V2 Position";
66:     string public constant symbol = "RP2";
67:     IInvestor public investor;
68:     IWhitelist public whitelist;
69:     mapping(address => bool) public exec;
70:     mapping(uint256 => address) internal _ownerOf;
71:     mapping(address => uint256) internal _balanceOf;
72:     mapping(address => Ids) internal _ownerIds;
73:     mapping(uint256 => address) public getApproved;
74:     mapping(address => mapping(address => bool)) public isApprovedForAll;
```


```solidity
📁 File: Store.sol

4: contract Store { 
5:     mapping(address => bool) public exec;
6:     mapping(bytes32 => uint256) public uintValues;
7:     mapping(bytes32 => int256) public intValues;
8:     mapping(bytes32 => address) public addressValues;
9:     mapping(bytes32 => bool) public boolValues;
10:     mapping(bytes32 => string) public stringValues;
11:     mapping(bytes32 => bytes32) public bytes32Values;
12:     mapping(bytes32 => bytes32[]) public bytes32ArrayValues;
13:     mapping(bytes32 => Bytes32Set) internal bytes32Sets;
14: 
```


```solidity
📁 File: StrategyCamelotV3.sol

7: contract StrategyCamelotV3 { 
8:     string public name;
9:     uint256 public totalShares = 1_000_000;
10:     uint256 public slippage = 500;
11:     bool internal entered;
12:     IERC20 public asset;
13:     IStrategyHelper public strategyHelper;
14:     mapping(address => bool) public exec;
15:     mapping(address => bool) public keepers;
16: 
17:     IXGrail public immutable xgrail;
```


```solidity
📁 File: StrategyGMXGM.sol

4: contract StrategyGMXGM { 
5:     string public name;
6:     uint256 public totalShares = 1_000_000;
7:     uint256 public slippage = 500;
8:     bool internal entered;
9:     IERC20 public asset;
10:     IStrategyHelper public strategyHelper;
11:     mapping(address => bool) public exec;
12:     mapping(address => bool) public keepers;
13: 
14:     IExchangeRouter public exchangeRouter;
```


```solidity
📁 File: StrategySushiswap.sol

4: contract StrategySushiswap { 
5:     string public name;
6:     uint256 public totalShares = 1_000_000;
7:     uint256 public slippage = 500;
8:     bool internal entered;
9:     IERC20 public asset;
10:     IStrategyHelper public strategyHelper;
11:     ISushiswapMiniChefV2 public rewarder;
12:     IUniswapV2Pair public pool;
13:     uint256 public poolId;
14:     mapping(address => bool) public exec;
```


```solidity
📁 File: UtilFarmingBalances.sol

13: contract UtilFarmingBalances { 
14:     function get(uint256 start) external view returns (address[] memory, uint256[] memory) {
15:         IInvestor i = IInvestor(0x8accf43Dd31DfCd4919cc7d65912A475BfA60369);
16:         IPositionManager pm = IPositionManager(0x5e4d7F61cC608485A2E4F105713D26D58a9D0cF6);
17:         uint256 max = i.nextPosition();
18:         address[] memory users = new address[](max-start);
19:         uint256[] memory balances = new uint256[](max-start);
20:         for (uint256 y = start; y < max; y++) {
21:             (,,,,,uint256 value,) = i.positions(y);
22:             (bool ok, bytes memory data) = address(pm).staticcall(abi.encodeWithSelector(IPositionManager.ownerOf.selector, y));
23:             if (ok) {
```


```solidity
📁 File: Whitelist.sol

4: contract Whitelist { 
5:     mapping(address => bool) public exec;
6:     mapping(address => bool) public whitelist;
7: 
8:     event File(bytes32 indexed what, address data);
9:     event BatchWhitelist(address[] addresses, bool status);
10: 
11:     error InvalidFile();
12:     error Unauthorized();
13: 
14:     constructor() {
```


</details>


---
### [D&#x2011;14] ~~Consider merging sequential for loops~~
The general rule is valid, but the instances below are invalid

<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

378:         for (uint256 i = sr.length; i < f; i++) { 
```


```solidity
📁 File: Whitelist.sol

36:         for (uint256 i = 0; i < l; i++) { 
```


</details>


---
### [D&#x2011;15] ~~Default `bool` values are manually reset~~
Using delete instead of assigning zero/false to state variables does not save any extra gas with the optimizer [on](https://gist.github.com/IllIllI000/ef8ec3a70aede7f12433fe63dc418515#with-the-optimizer-set-at-200-runs) (saves 5-8 gas with optimizer completely off), so this finding is invalid, especially since if they were interested in gas savings, they'd have the optimizer enabled. Some bots are also flagging `true` rather than just `false`

<details>
<summary><i>There are 17 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

18:         exec[msg.sender] = true; 
```


```solidity
📁 File: Investor.sol

147:         exec[msg.sender] = true; 

157:         entered = true; 

159:         entered = false; 
```


```solidity
📁 File: InvestorStrategyProxy.sol

26:         exec[msg.sender] = true; 
```


```solidity
📁 File: PositionManager.sol

93:         exec[msg.sender] = true; 
```


```solidity
📁 File: Store.sol

27:         exec[msg.sender] = true; 
```


```solidity
📁 File: StrategyCamelotV3.sol

60:         exec[msg.sender] = true; 

80:         entered = true; 

82:         entered = false; 
```


```solidity
📁 File: StrategyGMXGM.sol

58:         exec[msg.sender] = true; 

84:         entered = true; 

86:         entered = false; 
```


```solidity
📁 File: StrategySushiswap.sol

30:         exec[msg.sender] = true; 

42:         entered = true; 

44:         entered = false; 
```


```solidity
📁 File: Whitelist.sol

15:         exec[msg.sender] = true; 
```


</details>


---
### [D&#x2011;16] ~~Event names should use CamelCase~~
The instances below are already CamelCase (events are supposed to use CamelCase, not lowerCamelCase).

<details>
<summary><i>There are 34 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

11:     event File(bytes32 indexed what, address data); 
```


```solidity
📁 File: Investor.sol

100:     event File(bytes32 indexed what, uint256 data); 
101:     event File(bytes32 indexed what, address data);
102:     event Open(uint256 indexed id, uint256 borrow, uint256 collateral, uint256 strategy, address token);
103:     event Edit(uint256 indexed id, int256 borrow, int256 collateral);
104:     event Kill(uint256 indexed id, uint256 borrow, uint256 value, uint256 collateral, uint256 shares, uint256 fee);
105:     event StrategyUpdate(uint256 indexed index, address implementation, uint256 status, uint256 cap);
106:     event CollateralUpdate(address indexed token, uint256 factor, uint256 cap);
```


```solidity
📁 File: InvestorStrategyProxy.sol

19:     event File(bytes32 indexed what, address data); 
```


```solidity
📁 File: PositionManager.sol

76:     event Transfer(address indexed from, address indexed to, uint256 indexed id); 
77:     event Approval(address indexed owner, address indexed spender, uint256 indexed id);
78:     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
79:     event File(bytes32 indexed what, address data);
```


```solidity
📁 File: Store.sol

20:     event File(bytes32 indexed what, address data); 
```


```solidity
📁 File: StrategyCamelotV3.sol

32:     event File(bytes32 indexed what, uint256 data); 
33:     event File(bytes32 indexed what, address data);
34:     event Mint(uint256 amount, uint256 shares);
35:     event Burn(uint256 amount, uint256 shares);
36:     event Kill(uint256 amount, uint256 shares);
37:     event Earn(uint256 tvl, uint256 profit);
```


```solidity
📁 File: StrategyGMXGM.sol

31:     event File(bytes32 indexed what, uint256 data); 
32:     event File(bytes32 indexed what, address data);
33:     event Mint(uint256 amount, uint256 shares);
34:     event Burn(uint256 amount, uint256 shares);
35:     event Kill(uint256 amount, uint256 shares);
36:     event Earn(uint256 tvl, uint256 profit);
```


```solidity
📁 File: StrategySushiswap.sol

17:     event File(bytes32 indexed what, uint256 data); 
18:     event File(bytes32 indexed what, address data);
19:     event Mint(uint256 amount, uint256 shares);
20:     event Burn(uint256 amount, uint256 shares);
21:     event Kill(uint256 amount, uint256 shares);
22:     event Earn(uint256 tvl, uint256 profit);
```


```solidity
📁 File: Whitelist.sol

8:     event File(bytes32 indexed what, address data); 
9:     event BatchWhitelist(address[] addresses, bool status);
```


</details>


---
### [D&#x2011;17] ~~Inconsistent comment spacing~~
URLs are not comments


<i>There are 3 instaces of this issue:</i>

```solidity
📁 File: PositionManager.sol

63: /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol) 

296:                 '<svg width="290" height="290" viewBox="0 0 290 290" xmlns="http://www.w3.org/2000/svg"', 
297:                 " xmlns:xlink='http://www.w3.org/1999/xlink'>",
```



---
### [D&#x2011;18] ~~Integer increments by one can be unchecked to save on gas fees~~
The instances below are already in an unchecked block.

<details>
<summary><i>There are 16 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

171:             unchecked { _balanceOf[to]++; } 
```


```solidity
📁 File: StrategySushiswap.sol

205:             result = (result + a / result) >> 1; 
206:             result = (result + a / result) >> 1;
207:             result = (result + a / result) >> 1;
208:             result = (result + a / result) >> 1;
209:             result = (result + a / result) >> 1;
210:             result = (result + a / result) >> 1;
211:             result = (result + a / result) >> 1;

221:                 result += 128; 

225:                 result += 64; 

229:                 result += 32; 

233:                 result += 16; 

237:                 result += 8; 

241:                 result += 4; 

245:                 result += 2; 

247:             if (value >> 1 > 0) result += 1; 
```


</details>


---
### [D&#x2011;19] ~~Magic numbers should be replaced with constants~~
The rule is valid, but the following findings are invalid.


<i>There are 2 instaces of this issue:</i>

```solidity
📁 File: Investor.sol

78:     uint256 public constant STATUS_LIVE = 4; 
79:     uint256 public constant STATUS_WITHDRAW = 3;
```



---
### [D&#x2011;20] ~~Misplaced SPDX identifier~~
It's already on the first line

<details>
<summary><i>There are 11 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: Helper.sol

1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: Investor.sol

1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: InvestorStrategyProxy.sol

1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: PositionManager.sol

1: // SPDX-License-Identifier: AGPL-3.0-only 
```


```solidity
📁 File: Store.sol

1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: StrategyCamelotV3.sol

1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: StrategyGMXGM.sol

1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: StrategySushiswap.sol

1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: UtilFarmingBalances.sol

1: // SPDX-License-Identifier: MIT 
```


```solidity
📁 File: Whitelist.sol

1: // SPDX-License-Identifier: MIT 
```


</details>


---
### [D&#x2011;21] ~~Multiple mappings with same keys can be combined into a single struct mapping for readability~~
The general rule is valid, but the instances below are invalid

<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

75:     mapping(uint256 => uint256) private lastBlock; 
```


```solidity
📁 File: PositionManager.sol

70:     mapping(uint256 => address) internal _ownerOf; 
71:     mapping(address => uint256) internal _balanceOf;

73:     mapping(uint256 => address) public getApproved; 

88:         mapping(uint256 => uint256) positions; 
```


</details>


---
### [D&#x2011;22] ~~Prefer double quotes for string quoting~~
The examples below are not strings. Furthermore it's perfectly reasonable to use single quotes within text ([p. 16](https://www.ox.ac.uk/sites/files/oxford/media_wysiwyg/University%20of%20Oxford%20Style%20Guide.pdf)).

<details>
<summary><i>There are 3 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

343:                     // If we don't have enough USDC from shares, sell some collateral 
```


```solidity
📁 File: PositionManager.sol

296:                 '<svg width="290" height="290" viewBox="0 0 290 290" xmlns="http://www.w3.org/2000/svg"', 
297:                 " xmlns:xlink='http://www.w3.org/1999/xlink'>",
```


</details>


---
### [D&#x2011;23] ~~Timestamp may be manipulation~~
Use of `block.timestamp`, in and of itself, is not evidence of an issue; there must be an incorrect usage in the code in order for there to be a vulnerability. There should also be a corresponding suggested fix.


<i>There is one instance of this issue:</i>

```solidity
📁 File: Investor.sol

272:         p.start = block.timestamp; 
```



---
### [D&#x2011;24] ~~`unchecked {}` can be used on the division of two `uint`s in order to save gas~~
The instances below are already in an unchecked block.


<i>There are 8 instaces of this issue:</i>

```solidity
📁 File: StrategySushiswap.sol

205:             result = (result + a / result) >> 1; 
206:             result = (result + a / result) >> 1;
207:             result = (result + a / result) >> 1;
208:             result = (result + a / result) >> 1;
209:             result = (result + a / result) >> 1;
210:             result = (result + a / result) >> 1;
211:             result = (result + a / result) >> 1;
212:             return min(result, a / result);
```



---
### [D&#x2011;25] ~~Unsafe downcast~~
When a type is downcast to a smaller type, the higher order bits are truncated, effectively applying a modulo to the original value. Without any other checks, this wrapping will lead to unexpected behavior and bugs

<details>
<summary><i>There are 228 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @audit contract Helper -> address
/// @audit contract IERC20 -> address
45:         lender.flashLoanSimple(address(this), address(asset), repay, abi.encodePacked(id), 0); 

/// @audit contract IAavePool -> address
55:         require(msg.sender == address(lender), "!lender"); 
/// @audit contract Helper -> address
56:         require(initiator == address(this), "!me");
/// @audit bytes32 -> uint256
/// @audit bytes calldata -> bytes32
57:         uint256 id = uint256(bytes32(params));
/// @audit contract IInvestor -> address
58:         asset.approve(address(investor), amount);

/// @audit contract Helper -> address
65:             IERC20(a).transfer(a, IERC20(a).balanceOf(address(this))); 
/// @audit contract Helper -> address
66:             ISushi(a).burn(address(this));

/// @audit contract IAavePool -> address
71:         asset.approve(address(lender), amount+premium); 
/// @audit contract Helper -> address
72:         asset.transfer(msg.sender, asset.balanceOf(address(this)) - amount - premium);

/// @audit contract Helper -> address
78:         uint256 amount = fromAsset.balanceOf(address(this)); 
/// @audit contract IStrategyHelper -> address
79:         fromAsset.approve(address(sh), amount);
/// @audit contract IERC20 -> address
/// @audit contract Helper -> address
80:         sh.swap(_fromAsset, address(asset), amount, slippage, address(this));
```


```solidity
📁 File: Investor.sol

/// @audit contract Investor -> address
174:             if (!strategyProxy.exec(address(this))) revert InvalidFile(); 

/// @audit contract Investor -> address
177:             if (!IBank(data).exec(address(this))) revert InvalidFile(); 

/// @audit contract Investor -> address
180:             if (!IPool(data).exec(address(this))) revert InvalidFile(); 

/// @audit contract Investor -> address
252:         IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))); 

/// @audit contract IWhitelist -> address
256:         if (address(whitelist) != address(0)) { 

/// @audit contract IStrategyProxy -> address
283:             push(poolAsset, address(strategyProxy), borrow); 
/// @audit contract IStrategy -> address
284:             p.shares = strategyProxy.mint(address(si), borrow);

/// @audit int256 -> uint256
304:         if (borrow < 0 && uint256(-borrow) > p.shares) revert InvalidParameters(); 

/// @audit int256 -> uint256
306:         if (collateral < 0 && uint256(-collateral) > p.collateral) revert InvalidParameters(); 

/// @audit int256 -> uint256
321:             pullToBank(p.token, msg.sender, uint256(collateral)); 
/// @audit int256 -> uint256
322:             p.collateral = p.collateral + uint256(collateral);

/// @audit int256 -> uint256
331:             p.basis = p.basis - min(p.basis, si.rate(uint256(-borrow))); 
/// @audit contract IStrategy -> address
/// @audit int256 -> uint256
332:             uint256 amount = strategyProxy.burn(address(si), uint256(-borrow));
/// @audit int256 -> uint256
333:             p.shares = p.shares - uint256(-borrow);

/// @audit contract Investor -> address
347:                     bank.transfer(p.token, address(this), cAmount); 
/// @audit contract IHelper -> address
348:                     IERC20(p.token).approve(address(helper), cAmount);
/// @audit contract Investor -> address
349:                     uint256 topup = helper.swap(p.token, poolAsset, cAmount, slippage, address(this));

/// @audit contract IPool -> address
354:             IERC20(poolAsset).approve(address(pool), amount); 

/// @audit int256 -> uint256
364:             p.borrow = p.borrow + pool.borrow(uint256(borrow)); 
/// @audit contract IStrategyProxy -> address
/// @audit int256 -> uint256
365:             push(poolAsset, address(strategyProxy), uint256(borrow));
/// @audit contract IStrategy -> address
/// @audit int256 -> uint256
366:             uint256 shares = strategyProxy.mint(address(si), uint256(borrow));

/// @audit int256 -> uint256
373:             uint256 amt = uint256(-collateral); 

/// @audit uint256 -> int256
377:             collateralAdjusted = -int256(amt); 

/// @audit contract Investor -> address
410:         IERC20(poolAsset).transferFrom(msg.sender, address(this), borrow + fee); 
/// @audit contract IPool -> address
411:         IERC20(poolAsset).approve(address(pool), borrow);

/// @audit int256 -> uint256
460:         uint256 price = (uint256(oracle.latestAnswer()) * 1e18) / (10 ** oracle.decimals()); 
```


```solidity
📁 File: PositionManager.sol

/// @audit contract IWhitelist -> address
215:         if (address(whitelist) != address(0)) { 

/// @audit int256 -> uint256
236:             pull(p.token, msg.sender, uint256(collateral)); 
/// @audit int256 -> uint256
237:             rely(p.token, uint256(collateral));

/// @audit contract IInvestor -> address
259:         if (!IERC20(ast).approve(address(investor), amt)) revert TransferFailed(); 

/// @audit contract PositionManager -> address
263:         if (!IERC20(ast).transferFrom(usr, address(this), amt)) revert TransferFailed(); 

/// @audit contract PositionManager -> address
268:         uint256 bal = asset.balanceOf(address(this)); 

/// @audit bytes memory -> string
274:         return string( 
275:             abi.encodePacked(
276:                 "data:application/json;base64,",
277:                 Base64.encode(
/// @audit bytes memory -> bytes
278:                     bytes(
279:                         abi.encodePacked(
280:                             '{"name":"#',
281:                             Strings.toString(id),
282:                             '","description":"This NFT represents a leveraged farming position on Rodeo Finance. The owner of this NFT can modify or redeem the position.","image":"',
283:                             "data:image/svg+xml;base64,",
284:                             image,
285:                             '"}'
286:                         )
287:                     )
288:                 )
289:             )
290:         );

/// @audit bytes memory -> string
312:         return string( 
313:             abi.encodePacked(
314:                 '<text y="64px" x="32px" fill="white" font-family="\'Courier New\', monospace" font-weight="600" font-size="32px">#',
315:                 Strings.toString(id),
316:                 '</text><text y="111px" x="32px" fill="white" font-family="\'Courier New\', monospace" font-weight="200" font-size="24px">',
317:                 IStrategy(s.implementation).name(),
318:                 "</text>"
319:             )
320:         );

/// @audit string memory -> bytes
327:         uint256 len = bytes(str).length + 7; 
/// @audit bytes memory -> string
328:         return string(
329:             abi.encodePacked(
330:                 '<g style="transform:translate(29px, 175px)"><rect width="',
331:                 Strings.toString(7 * (len + 4)),
332:                 'px" height="26px" rx="8px" ry="8px" fill="rgba(0,0,0,0.4)" /><text x="12px" y="17px" font-family="\'Courier New\', monospace" font-size="12px" fill="white"><tspan fill="rgba(255,255,255,0.6)">Value: </tspan>',
333:                 str,
334:                 "</text></g>"
335:             )
336:         );

/// @audit int256 -> uint256
345:         ) * uint256(oracle.latestAnswer()) / (10 ** oracle.decimals()); 

/// @audit string memory -> bytes
347:         uint256 len = bytes(str).length + 8; 
/// @audit bytes memory -> string
348:         return string(
349:             abi.encodePacked(
350:                 '<g style="transform:translate(29px, 205px)"><rect width="',
351:                 Strings.toString(7 * (len + 4)),
352:                 'px" height="26px" rx="8px" ry="8px" fill="rgba(0,0,0,0.4)" /><text x="12px" y="17px" font-family="\'Courier New\', monospace" font-size="12px" fill="white"><tspan fill="rgba(255,255,255,0.6)">Borrow: </tspan>',
353:                 str,
354:                 "</text></g>"
355:             )
356:         );

/// @audit string memory -> bytes
362:         uint256 len = bytes(str).length + 6; 
/// @audit bytes memory -> string
363:         return string(
364:             abi.encodePacked(
365:                 '<g style="transform:translate(29px, 235px)"><rect width="',
366:                 Strings.toString(7 * (len + 4)),
367:                 'px" height="26px" rx="8px" ry="8px" fill="rgba(0,0,0,0.4)" /><text x="12px" y="17px" font-family="\'Courier New\', monospace" font-size="12px" fill="white"><tspan fill="rgba(255,255,255,0.6)">Life: </tspan>',
368:                 str,
369:                 "</text></g>"
370:             )
371:         );

/// @audit string memory -> bytes
377:         bytes memory sr = bytes(Strings.toString(r)); 

/// @audit bytes memory -> string
381:         return string(abi.encodePacked(Strings.toString(n / x), ".", sr)); 
```


```solidity
📁 File: Store.sol

/// @audit int256 -> uint256
/// @audit uint256 -> int256
53:         uint256 next = uint256(int256(prev) + value); 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit bytes memory -> string
71:         name = string(abi.encodePacked("Camelot V3 ", hypervisor.token0().symbol(), "/", hypervisor.token1().symbol())); 

/// @audit contract IERC20 -> address
/// @audit contract IERC20 -> address
73:         if (_targetAsset != address(hypervisor.token0()) && _targetAsset != address(hypervisor.token1())) { 

/// @audit int256 -> uint256
/// @audit int32 -> int256
111:             if (data > uint256(int256(type(int32).max))) revert TwapPeriodTooLong(); 
/// @audit uint32 -> uint32
112:             twapPeriod = uint32(twapPeriod);

/// @audit contract StrategyCamelotV3 -> address
128:             nftPool.safeTransferFrom(address(this), _nitroPool, tokenId, ""); 

/// @audit contract StrategyCamelotV3 -> address
142:         asset.transferFrom(msg.sender, address(this), amount); 

/// @audit contract IStrategyHelper -> address
147:         asset.approve(address(strategyHelper), amount); 
/// @audit contract IERC20 -> address
/// @audit contract StrategyCamelotV3 -> address
148:         strategyHelper.swap(address(asset), tgtAst, amount, slp, address(this));

/// @audit contract StrategyCamelotV3 -> address
152:             uint256 tgtAmt = IERC20(tgtAst).balanceOf(address(this)); 

/// @audit contract IHypervisor -> address
154:             address hyp = address(hypervisor); 

/// @audit contract StrategyCamelotV3 -> address
157:             liq = uniProxy.deposit(amt0, amt1, address(this), hyp, [uint256(0), 0, 0, 0]); 

/// @audit contract IERC20 -> address
162:         if (val < strategyHelper.value(address(asset), amount) * (10000 - slp) / 10000) revert PriceSlipped(); 

/// @audit contract StrategyCamelotV3 -> address
/// @audit contract StrategyCamelotV3 -> address
175:         (uint256 amt0, uint256 amt1) = hypervisor.withdraw(amt, address(this), address(this), [uint256(0), 0, 0, 0]); 

/// @audit contract IStrategyHelper -> address
177:         address strategyHelperAddress = address(strategyHelper); 

/// @audit contract IERC20 -> address
/// @audit contract IERC20 -> address
183:         bal += strategyHelper.swap(address(hypervisor.token0()), address(asset), amt0, slp, msg.sender); 
/// @audit contract IERC20 -> address
/// @audit contract IERC20 -> address
184:         bal += strategyHelper.swap(address(hypervisor.token1()), address(asset), amt1, slp, msg.sender);

/// @audit contract IERC20 -> address
186:         if (strategyHelper.value(address(asset), bal) < val * (10000 - slp) / 10000) revert PriceSlipped(); 

/// @audit contract IHypervisor -> address
202:         assets[0] = address(hypervisor); 
/// @audit literal_string "camelotv3" -> bytes32
203:         return abi.encode(bytes32("camelotv3"), assets);

/// @audit contract INFTPool -> address
/// @audit contract IHypervisor -> address
207:         IERC20(address(hypervisor)).approve(address(nftPool), amount); 

/// @audit contract INitroPool -> address
219:         if (address(nitroPool) != address(0)) { 

/// @audit contract INitroPool -> address
223:         if (address(nitroPool) != address(0)) { 
/// @audit contract StrategyCamelotV3 -> address
/// @audit contract INitroPool -> address
224:             nftPool.safeTransferFrom(address(this), address(nitroPool), tokenId, "");

/// @audit contract INitroPool -> address
236:         if (address(nitroPool) != address(0)) { 

/// @audit contract StrategyCamelotV3 -> address
241:             uint256 balance = IERC20(rewardToken1).balanceOf(address(this)); 

/// @audit contract IStrategyHelper -> address
243:                 IERC20(rewardToken1).approve(address(strategyHelper), balance); 
/// @audit contract StrategyCamelotV3 -> address
244:                 strategyHelper.swap(rewardToken1, tgtAsset, balance, slp, address(this));

/// @audit contract StrategyCamelotV3 -> address
249:             uint256 balance = IERC20(rewardToken2).balanceOf(address(this)); 

/// @audit contract IStrategyHelper -> address
251:                 IERC20(rewardToken2).approve(address(strategyHelper), balance); 
/// @audit contract StrategyCamelotV3 -> address
252:                 strategyHelper.swap(rewardToken2, tgtAsset, balance, slp, address(this));

/// @audit contract StrategyCamelotV3 -> address
257:             uint256 balance = IERC20(rewardToken3).balanceOf(address(this)); 

/// @audit contract IStrategyHelper -> address
259:                 IERC20(rewardToken3).approve(address(strategyHelper), balance); 
/// @audit contract StrategyCamelotV3 -> address
260:                 strategyHelper.swap(rewardToken3, tgtAsset, balance, slp, address(this));

/// @audit contract StrategyCamelotV3 -> address
264:         uint256 amt = IERC20(tgtAsset).balanceOf(address(this)); 

/// @audit contract IHypervisor -> address
267:         address h = address(hypervisor); 

/// @audit contract StrategyCamelotV3 -> address
270:         stake(uniProxy.deposit(amt0, amt1, address(this), h, [uint256(0), 0, 0, 0])); 

/// @audit contract INitroPool -> address
278:         if (address(nitroPool) != address(0)) { 

/// @audit contract StrategyCamelotV3 -> address
281:         nftPool.safeTransferFrom(address(this), strategy, tokenId, ""); 

/// @audit contract INitroPool -> address
288:         if (address(nitroPool) != address(0)) { 
/// @audit contract StrategyCamelotV3 -> address
/// @audit contract INitroPool -> address
289:             nftPool.safeTransferFrom(address(this), address(nitroPool), tokenId, "");

/// @audit literal_string "" -> bytes
/// @audit contract IERC20 -> address
302:         bytes memory path0 = trgtAst != address(hypervisor.token0()) ? path : bytes(""); 
/// @audit literal_string "" -> bytes
/// @audit contract IERC20 -> address
303:         bytes memory path1 = trgtAst != address(hypervisor.token1()) ? path : bytes("");

/// @audit contract IHypervisor -> address
/// @audit contract IERC20 -> address
313:             uniProxy.getDepositAmount(address(hypervisor), address(hypervisor.token0()), out0); 

/// @audit contract IERC20 -> address
323:         address token0 = address(hypervisor.token0()); 

/// @audit contract StrategyCamelotV3 -> address
326:             uint256 before = hypervisor.token1().balanceOf(address(this)); 
/// @audit contract IERC20 -> address
327:             swap(trgtAst, address(hypervisor.token1()), path, toLp1, slp);

/// @audit contract StrategyCamelotV3 -> address
329:             amt1 = hypervisor.token1().balanceOf(address(this)) - before; 

/// @audit contract StrategyCamelotV3 -> address
331:             uint256 before = hypervisor.token0().balanceOf(address(this)); 

/// @audit contract StrategyCamelotV3 -> address
333:             amt0 = hypervisor.token0().balanceOf(address(this)) - before; 

/// @audit contract IStrategyHelperUniswapV3 -> address
340:         IERC20(trgtAst).transfer(address(strategyHelperUniswapV3), toLp); 
/// @audit contract StrategyCamelotV3 -> address
341:         strategyHelperUniswapV3.swap(trgtAst, path, toLp, minOut, address(this));

/// @audit uint32 -> int32
352:         uint160 midX96 = TickMath.getSqrtRatioAtTick(int24((tickCumulatives[1] - tickCumulatives[0]) / int32(period))); 

/// @audit contract IERC20 -> address
/// @audit contract IHypervisor -> address
356:             address(hypervisor.token0()), bas0 + lim0 + hypervisor.token0().balanceOf(address(hypervisor)) 

/// @audit contract IERC20 -> address
/// @audit contract IHypervisor -> address
359:             address(hypervisor.token1()), bas1 + lim1 + hypervisor.token1().balanceOf(address(hypervisor)) 

/// @audit contract IHypervisor -> address
378:         address owner = address(hypervisor); 

/// @audit contract IAlgebraPool -> address
382:         (uint128 liq,,,, uint128 owed0, uint128 owed1) = IAlgebraPool(address(hypervisor.pool())).positions(key); 

/// @audit uint128 -> uint256
/// @audit uint128 -> uint256
387:         return (amt0 + uint256(owed0), amt1 + uint256(owed1)); 

/// @audit contract INFTPool -> address
391:         if (msg.sender == address(nftPool) && tokenId == 0) { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit bytes memory -> string
73:         name = string( 
74:             abi.encodePacked(
75:                 "GMX GM ", IERC20(marketInfo.longToken).symbol(), "/", IERC20(marketInfo.shortToken).symbol()
76:             )
77:         );

/// @audit address -> address
/// @audit contract StrategyGMXGM -> address
134:         (bool success,) = address(msg.sender).call{value: address(this).balance}(""); 

/// @audit address -> address
139:       if (token == address(market) || token == tokenShort || token == tokenLong) revert BadToken(); 
/// @audit contract StrategyGMXGM -> address
140:       IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));

/// @audit contract StrategyGMXGM -> address
148:         asset.transferFrom(msg.sender, address(this), amount); 
/// @audit contract IStrategyHelper -> address
149:         asset.approve(address(strategyHelper), amount);
/// @audit contract IERC20 -> address
/// @audit contract StrategyGMXGM -> address
150:         uint256 bal = strategyHelper.swap(address(asset), tokenShort, amount, slp, address(this));

/// @audit contract IStrategyHelper -> address
163:         IERC20(tokenShort).approve(address(strategyHelper), amt); 
/// @audit contract IERC20 -> address
164:         uint256 bal = strategyHelper.swap(tokenShort, address(asset), amt, slp, msg.sender);

/// @audit literal_string "gmxgm" -> bytes32
181:         return abi.encode(bytes32("gmxgm"), assets); 

/// @audit contract StrategyGMXGM -> address
193:         uint256 bal = IERC20(tokenLong).balanceOf(address(this)); 

/// @audit contract IStrategyHelper -> address
195:             IERC20(tokenLong).approve(address(strategyHelper), bal); 
/// @audit contract StrategyGMXGM -> address
196:             strategyHelper.swap(tokenLong, tokenShort, bal, slp, address(this));

/// @audit contract StrategyGMXGM -> address
199:         bal = IERC20(tokenShort).balanceOf(address(this)); 

/// @audit contract IStrategyHelper -> address
206:             IERC20(tokenShort).approve(address(strategyHelper), haf); 
/// @audit contract StrategyGMXGM -> address
207:             uint256 out = strategyHelper.swap(tokenShort, tokenLong, haf, slp, address(this));

/// @audit contract StrategyGMXGM -> address
213:                 receiver: address(this), 
/// @audit contract StrategyGMXGM -> address
214:                 callbackContract: address(this),

/// @audit contract StrategyGMXGM -> address
257:                 receiver: address(this), 
/// @audit contract StrategyGMXGM -> address
258:                 callbackContract: address(this),

/// @audit contract StrategyGMXGM -> address
287:         IERC20(market).transfer(strategy, IERC20(market).balanceOf(address(this))); 
/// @audit contract StrategyGMXGM -> address
288:         IERC20(tokenLong).transfer(strategy, IERC20(tokenLong).balanceOf(address(this)));
/// @audit contract StrategyGMXGM -> address
289:         IERC20(tokenShort).transfer(strategy, IERC20(tokenShort).balanceOf(address(this)));

/// @audit contract StrategyGMXGM -> address
295:         uint256 val = strategyHelper.value(tokenLong, IERC20(tokenLong).balanceOf(address(this))); 
/// @audit contract StrategyGMXGM -> address
296:         val += strategyHelper.value(tokenShort, IERC20(tokenShort).balanceOf(address(this)));

/// @audit contract StrategyGMXGM -> address
298:         uint256 bal = IERC20(market).balanceOf(address(this)) + amountPendingDeposit + amountPendingWithdraw; 

/// @audit int256 -> uint256
319:         return price < 0 ? 0 : uint256(price) / 1e12; 

/// @audit contract StrategyGMXGM -> address
348:         uint256 bal = IERC20(tokenLong).balanceOf(address(this)); 
/// @audit contract IStrategyHelper -> address
349:         IERC20(tokenLong).approve(address(strategyHelper), bal);
/// @audit contract StrategyGMXGM -> address
350:         try strategyHelper.swap(tokenLong, tokenShort, bal, slippage, address(this)) {} catch {}
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit bytes memory -> string
37:             string(abi.encodePacked("SushiSwap ", IERC20(pool.token0()).symbol(), "/", IERC20(pool.token1()).symbol())); 

/// @audit uint112 -> uint256
81:             reserve0 = uint256(r0) * 1e18 / (10 ** IERC20(pair.token0()).decimals()); 
/// @audit uint112 -> uint256
82:             reserve1 = uint256(r1) * 1e18 / (10 ** IERC20(pair.token1()).decimals());

/// @audit contract StrategySushiswap -> address
91:         asset.transferFrom(msg.sender, address(this), amount); 

/// @audit contract IStrategyHelper -> address
99:             asset.approve(address(strategyHelper), amount); 
/// @audit contract IERC20 -> address
/// @audit contract IERC20 -> address
/// @audit contract StrategySushiswap -> address
100:             strategyHelper.swap(address(asset), address(tok0), haf, slp, address(this));
/// @audit contract IERC20 -> address
/// @audit contract IERC20 -> address
/// @audit contract StrategySushiswap -> address
101:             strategyHelper.swap(address(asset), address(tok1), amount - haf, slp, address(this));
/// @audit contract IUniswapV2Pair -> address
/// @audit contract StrategySushiswap -> address
102:             IERC20(tok0).transfer(address(pair), tok0.balanceOf(address(this)));
/// @audit contract IUniswapV2Pair -> address
/// @audit contract StrategySushiswap -> address
103:             IERC20(tok1).transfer(address(pair), tok1.balanceOf(address(this)));

/// @audit contract StrategySushiswap -> address
105:         pair.mint(address(this)); 
/// @audit contract StrategySushiswap -> address
106:         pair.skim(address(this));
/// @audit contract StrategySushiswap -> address
/// @audit contract IUniswapV2Pair -> address
107:         uint256 liq = IERC20(address(pair)).balanceOf(address(this));
/// @audit contract ISushiswapMiniChefV2 -> address
/// @audit contract IUniswapV2Pair -> address
108:         IERC20(address(pair)).approve(address(rewarder), liq);
/// @audit contract StrategySushiswap -> address
109:         rewarder.deposit(poolId, liq, address(this));

/// @audit contract IUniswapV2Pair -> address
123:             rewarder.withdraw(poolId, amt, address(pair)); 
/// @audit contract StrategySushiswap -> address
124:             pair.burn(address(this));

/// @audit contract StrategySushiswap -> address
128:         uint256 bal0 = tok0.balanceOf(address(this)); 
/// @audit contract StrategySushiswap -> address
129:         uint256 bal1 = tok1.balanceOf(address(this));
/// @audit contract IStrategyHelper -> address
130:         tok0.approve(address(strategyHelper), bal0);
/// @audit contract IStrategyHelper -> address
131:         tok1.approve(address(strategyHelper), bal1);
/// @audit contract IERC20 -> address
/// @audit contract IERC20 -> address
132:         uint256 amt0 = strategyHelper.swap(address(tok0), address(asset), bal0, slp, msg.sender);
/// @audit contract IERC20 -> address
/// @audit contract IERC20 -> address
133:         uint256 amt1 = strategyHelper.swap(address(tok1), address(asset), bal1, slp, msg.sender);

/// @audit contract IUniswapV2Pair -> address
149:         assets[0] = address(pool); 
/// @audit literal_string "sushi" -> bytes32
150:         return abi.encode(bytes32("sushi"), assets);

/// @audit contract StrategySushiswap -> address
159:         rewarder.harvest(poolId, address(this)); 
/// @audit contract StrategySushiswap -> address
160:         uint256 amt = rew.balanceOf(address(this));

/// @audit contract IERC20 -> address
162:         if (strategyHelper.value(address(rew), amt) < 0.5e18) return; 
/// @audit contract IStrategyHelper -> address
163:         rew.approve(address(strategyHelper), amt);
/// @audit contract IERC20 -> address
/// @audit contract StrategySushiswap -> address
164:         strategyHelper.swap(address(rew), pair.token0(), haf, slippage, address(this));
/// @audit contract IERC20 -> address
/// @audit contract StrategySushiswap -> address
165:         strategyHelper.swap(address(rew), pair.token1(), amt - haf, slippage, address(this));
/// @audit contract IUniswapV2Pair -> address
/// @audit contract StrategySushiswap -> address
166:         IERC20(pair.token0()).transfer(address(pair), IERC20(pair.token0()).balanceOf(address(this)));
/// @audit contract IUniswapV2Pair -> address
/// @audit contract StrategySushiswap -> address
167:         IERC20(pair.token1()).transfer(address(pair), IERC20(pair.token1()).balanceOf(address(this)));
/// @audit contract StrategySushiswap -> address
168:         pair.mint(address(this));
/// @audit contract StrategySushiswap -> address
169:         pair.skim(address(this));
/// @audit contract StrategySushiswap -> address
/// @audit contract IUniswapV2Pair -> address
170:         uint256 liq = IERC20(address(pair)).balanceOf(address(this));
/// @audit contract ISushiswapMiniChefV2 -> address
/// @audit contract IUniswapV2Pair -> address
171:         IERC20(address(pair)).approve(address(rewarder), liq);
/// @audit contract StrategySushiswap -> address
172:         rewarder.deposit(poolId, liq, address(this));

/// @audit contract StrategySushiswap -> address
178:         (uint256 amt,) = rewarder.userInfo(poolId, address(this)); 

/// @audit contract IUniswapV2Pair -> address
189:         IERC20 lp = IERC20(address(pool)); 
/// @audit contract StrategySushiswap -> address
190:         uint256 bal = lp.balanceOf(address(this));

/// @audit contract ISushiswapMiniChefV2 -> address
192:         lp.approve(address(rewarder), bal); 
/// @audit contract StrategySushiswap -> address
193:         rewarder.deposit(poolId, bal, address(this));
```


```solidity
📁 File: UtilFarmingBalances.sol

/// @audit contract IPositionManager -> address
22:             (bool ok, bytes memory data) = address(pm).staticcall(abi.encodeWithSelector(IPositionManager.ownerOf.selector, y)); 
```


</details>


---
### [D&#x2011;26] ~~Unused named return variables without optimizer waste gas~~
Suggestions that only apply when the optimizer is _off_ are not useful to sponsors. Why would they pay for gas optimizations if they don't have the optimizer on, and don't plan to turn it on? Only a [small minority](https://github.com/search?q=org%3Acode-423n4+%22optimizer+%3D+false%22&type=code) have the optimizer off; the majority have it set to more than [200](https://github.com/search?q=org%3Acode-423n4+optimizer_runs&type=code) runs


<i>There are 2 instaces of this issue:</i>

```solidity
📁 File: Investor.sol

466:     function getPosition(uint256 id) public view returns (Position memory p) { 
467:         p.owner = store.getAddress(keccak256(abi.encode(id, POSITIONS_OWNER)));
468:         p.start = store.getUint(keccak256(abi.encode(id, POSITIONS_START)));
469:         p.strategy = store.getUint(keccak256(abi.encode(id, POSITIONS_STRATEGY)));
470:         p.token = store.getAddress(keccak256(abi.encode(id, POSITIONS_TOKEN)));
471:         p.collateral = store.getUint(keccak256(abi.encode(id, POSITIONS_COLLATERAL)));
472:         p.borrow = store.getUint(keccak256(abi.encode(id, POSITIONS_BORROW)));
473:         p.shares = store.getUint(keccak256(abi.encode(id, POSITIONS_SHARES)));
474:         p.basis = store.getUint(keccak256(abi.encode(id, POSITIONS_BASIS)));
475:     }

488:     function getStrategy(uint256 id) public view returns (Strategy memory s) { 
489:         s.implementation = store.getAddress(keccak256(abi.encode(id, STRATEGIES_ADDRESS)));
490:         s.cap = store.getUint(keccak256(abi.encode(id, STRATEGIES_CAP)));
491:         s.status = store.getUint(keccak256(abi.encode(id, STRATEGIES_STATUS)));
492:         if (s.implementation == address(0)) revert UnknownStrategy();
493:     }
```



---
### [D&#x2011;27] ~~Use != 0 instead of > 0 for unsigned integer comparison~~
Only valid prior to Solidity version 0.8.13, and only for `require()` statements, and at least one of those is not true for the examples below

<details>
<summary><i>There are 13 instances of this issue:</i></summary>

```solidity
📁 File: PositionManager.sol

269:         if (bal > 0 && !asset.transfer(usr, bal)) revert TransferFailed(); 
```


```solidity
📁 File: StrategyCamelotV3.sol

208:         if (tokenId != 0 && totalManagedAssets() > 0) { 

305:         if (path0.length > 0) { 

308:         if (path1.length > 0) { 
```


```solidity
📁 File: StrategyGMXGM.sol

194:         if (bal > 0) { 
```


```solidity
📁 File: StrategySushiswap.sol

219:             if (value >> 128 > 0) { 

223:             if (value >> 64 > 0) { 

227:             if (value >> 32 > 0) { 

231:             if (value >> 16 > 0) { 

235:             if (value >> 8 > 0) { 

239:             if (value >> 4 > 0) { 

243:             if (value >> 2 > 0) { 

247:             if (value >> 1 > 0) result += 1; 
```


</details>


---
### [D&#x2011;28] ~~Use assembly to emit events, in order to save gas~~
For these instances, the arguments are too large to fit in the scratch space, so the finding is invalid

<details>
<summary><i>There are 11 instances of this issue:</i></summary>

```solidity
📁 File: Investor.sol

216:         emit StrategyUpdate(index, implementation, 4, 0); 

224:         emit StrategyUpdate(index, implementation, s.status, s.cap); 

230:         emit StrategyUpdate(index, s.implementation, status, s.cap); 

236:         emit StrategyUpdate(index, s.implementation, s.status, cap); 

242:         emit CollateralUpdate(token, factor, cap); 

248:         emit CollateralUpdate(token, factor, cap); 

291:         emit Open(id, borrow, collateral, strategy, token); 

385:         emit Edit(id, borrow, collateralAdjusted); 

442:         emit Kill(id, borrow, amount, collat, shares, fee); 
```


```solidity
📁 File: PositionManager.sol

147:         emit Approval(owner, spender, id); 

179:         emit Transfer(from, to, id); 
```


</details>


---
### [D&#x2011;29] ~~Use SafeCast to safely cast variables~~
There's no risk of casting smaller type to a higher one

<details>
<summary><i>There are 209 instances of this issue:</i></summary>

```solidity
📁 File: Helper.sol

/// @audit contract Helper -> address
/// @audit contract IERC20 -> address
45:         lender.flashLoanSimple(address(this), address(asset), repay, abi.encodePacked(id), 0); 

/// @audit contract IAavePool -> address
55:         require(msg.sender == address(lender), "!lender"); 
/// @audit contract Helper -> address
56:         require(initiator == address(this), "!me");
/// @audit bytes32 -> uint256
/// @audit bytes calldata -> bytes32
57:         uint256 id = uint256(bytes32(params));
/// @audit contract IInvestor -> address
58:         asset.approve(address(investor), amount);

/// @audit contract Helper -> address
65:             IERC20(a).transfer(a, IERC20(a).balanceOf(address(this))); 
/// @audit contract Helper -> address
66:             ISushi(a).burn(address(this));

/// @audit contract IAavePool -> address
71:         asset.approve(address(lender), amount+premium); 
/// @audit contract Helper -> address
72:         asset.transfer(msg.sender, asset.balanceOf(address(this)) - amount - premium);

/// @audit contract Helper -> address
78:         uint256 amount = fromAsset.balanceOf(address(this)); 
/// @audit contract IStrategyHelper -> address
79:         fromAsset.approve(address(sh), amount);
/// @audit contract IERC20 -> address
/// @audit contract Helper -> address
80:         sh.swap(_fromAsset, address(asset), amount, slippage, address(this));
```


```solidity
📁 File: Investor.sol

/// @audit contract Investor -> address
174:             if (!strategyProxy.exec(address(this))) revert InvalidFile(); 

/// @audit contract Investor -> address
177:             if (!IBank(data).exec(address(this))) revert InvalidFile(); 

/// @audit contract Investor -> address
180:             if (!IPool(data).exec(address(this))) revert InvalidFile(); 

/// @audit contract Investor -> address
252:         IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))); 

/// @audit contract IWhitelist -> address
256:         if (address(whitelist) != address(0)) { 

/// @audit contract IStrategyProxy -> address
283:             push(poolAsset, address(strategyProxy), borrow); 
/// @audit contract IStrategy -> address
284:             p.shares = strategyProxy.mint(address(si), borrow);

/// @audit contract IStrategy -> address
332:             uint256 amount = strategyProxy.burn(address(si), uint256(-borrow)); 

/// @audit contract Investor -> address
347:                     bank.transfer(p.token, address(this), cAmount); 
/// @audit contract IHelper -> address
348:                     IERC20(p.token).approve(address(helper), cAmount);
/// @audit contract Investor -> address
349:                     uint256 topup = helper.swap(p.token, poolAsset, cAmount, slippage, address(this));

/// @audit contract IPool -> address
354:             IERC20(poolAsset).approve(address(pool), amount); 

/// @audit contract IStrategyProxy -> address
365:             push(poolAsset, address(strategyProxy), uint256(borrow)); 
/// @audit contract IStrategy -> address
366:             uint256 shares = strategyProxy.mint(address(si), uint256(borrow));

/// @audit uint256 -> int256
377:             collateralAdjusted = -int256(amt); 

/// @audit contract Investor -> address
410:         IERC20(poolAsset).transferFrom(msg.sender, address(this), borrow + fee); 
/// @audit contract IPool -> address
411:         IERC20(poolAsset).approve(address(pool), borrow);
```


```solidity
📁 File: PositionManager.sol

/// @audit contract IWhitelist -> address
215:         if (address(whitelist) != address(0)) { 

/// @audit contract IInvestor -> address
259:         if (!IERC20(ast).approve(address(investor), amt)) revert TransferFailed(); 

/// @audit contract PositionManager -> address
263:         if (!IERC20(ast).transferFrom(usr, address(this), amt)) revert TransferFailed(); 

/// @audit contract PositionManager -> address
268:         uint256 bal = asset.balanceOf(address(this)); 

/// @audit bytes memory -> string
274:         return string( 
275:             abi.encodePacked(
276:                 "data:application/json;base64,",
277:                 Base64.encode(
/// @audit bytes memory -> bytes
278:                     bytes(
279:                         abi.encodePacked(
280:                             '{"name":"#',
281:                             Strings.toString(id),
282:                             '","description":"This NFT represents a leveraged farming position on Rodeo Finance. The owner of this NFT can modify or redeem the position.","image":"',
283:                             "data:image/svg+xml;base64,",
284:                             image,
285:                             '"}'
286:                         )
287:                     )
288:                 )
289:             )
290:         );

/// @audit bytes memory -> string
312:         return string( 
313:             abi.encodePacked(
314:                 '<text y="64px" x="32px" fill="white" font-family="\'Courier New\', monospace" font-weight="600" font-size="32px">#',
315:                 Strings.toString(id),
316:                 '</text><text y="111px" x="32px" fill="white" font-family="\'Courier New\', monospace" font-weight="200" font-size="24px">',
317:                 IStrategy(s.implementation).name(),
318:                 "</text>"
319:             )
320:         );

/// @audit string memory -> bytes
327:         uint256 len = bytes(str).length + 7; 
/// @audit bytes memory -> string
328:         return string(
329:             abi.encodePacked(
330:                 '<g style="transform:translate(29px, 175px)"><rect width="',
331:                 Strings.toString(7 * (len + 4)),
332:                 'px" height="26px" rx="8px" ry="8px" fill="rgba(0,0,0,0.4)" /><text x="12px" y="17px" font-family="\'Courier New\', monospace" font-size="12px" fill="white"><tspan fill="rgba(255,255,255,0.6)">Value: </tspan>',
333:                 str,
334:                 "</text></g>"
335:             )
336:         );

/// @audit string memory -> bytes
347:         uint256 len = bytes(str).length + 8; 
/// @audit bytes memory -> string
348:         return string(
349:             abi.encodePacked(
350:                 '<g style="transform:translate(29px, 205px)"><rect width="',
351:                 Strings.toString(7 * (len + 4)),
352:                 'px" height="26px" rx="8px" ry="8px" fill="rgba(0,0,0,0.4)" /><text x="12px" y="17px" font-family="\'Courier New\', monospace" font-size="12px" fill="white"><tspan fill="rgba(255,255,255,0.6)">Borrow: </tspan>',
353:                 str,
354:                 "</text></g>"
355:             )
356:         );

/// @audit string memory -> bytes
362:         uint256 len = bytes(str).length + 6; 
/// @audit bytes memory -> string
363:         return string(
364:             abi.encodePacked(
365:                 '<g style="transform:translate(29px, 235px)"><rect width="',
366:                 Strings.toString(7 * (len + 4)),
367:                 'px" height="26px" rx="8px" ry="8px" fill="rgba(0,0,0,0.4)" /><text x="12px" y="17px" font-family="\'Courier New\', monospace" font-size="12px" fill="white"><tspan fill="rgba(255,255,255,0.6)">Life: </tspan>',
368:                 str,
369:                 "</text></g>"
370:             )
371:         );

/// @audit string memory -> bytes
377:         bytes memory sr = bytes(Strings.toString(r)); 

/// @audit bytes memory -> string
381:         return string(abi.encodePacked(Strings.toString(n / x), ".", sr)); 
```


```solidity
📁 File: Store.sol

/// @audit uint256 -> int256
53:         uint256 next = uint256(int256(prev) + value); 
```


```solidity
📁 File: StrategyCamelotV3.sol

/// @audit bytes memory -> string
71:         name = string(abi.encodePacked("Camelot V3 ", hypervisor.token0().symbol(), "/", hypervisor.token1().symbol())); 

/// @audit contract IERC20 -> address
/// @audit contract IERC20 -> address
73:         if (_targetAsset != address(hypervisor.token0()) && _targetAsset != address(hypervisor.token1())) { 

/// @audit int32 -> int256
111:             if (data > uint256(int256(type(int32).max))) revert TwapPeriodTooLong(); 

/// @audit contract StrategyCamelotV3 -> address
128:             nftPool.safeTransferFrom(address(this), _nitroPool, tokenId, ""); 

/// @audit contract StrategyCamelotV3 -> address
142:         asset.transferFrom(msg.sender, address(this), amount); 

/// @audit contract IStrategyHelper -> address
147:         asset.approve(address(strategyHelper), amount); 
/// @audit contract IERC20 -> address
/// @audit contract StrategyCamelotV3 -> address
148:         strategyHelper.swap(address(asset), tgtAst, amount, slp, address(this));

/// @audit contract StrategyCamelotV3 -> address
152:             uint256 tgtAmt = IERC20(tgtAst).balanceOf(address(this)); 

/// @audit contract IHypervisor -> address
154:             address hyp = address(hypervisor); 

/// @audit contract StrategyCamelotV3 -> address
157:             liq = uniProxy.deposit(amt0, amt1, address(this), hyp, [uint256(0), 0, 0, 0]); 

/// @audit contract IERC20 -> address
162:         if (val < strategyHelper.value(address(asset), amount) * (10000 - slp) / 10000) revert PriceSlipped(); 

/// @audit contract StrategyCamelotV3 -> address
/// @audit contract StrategyCamelotV3 -> address
175:         (uint256 amt0, uint256 amt1) = hypervisor.withdraw(amt, address(this), address(this), [uint256(0), 0, 0, 0]); 

/// @audit contract IStrategyHelper -> address
177:         address strategyHelperAddress = address(strategyHelper); 

/// @audit contract IERC20 -> address
/// @audit contract IERC20 -> address
183:         bal += strategyHelper.swap(address(hypervisor.token0()), address(asset), amt0, slp, msg.sender); 
/// @audit contract IERC20 -> address
/// @audit contract IERC20 -> address
184:         bal += strategyHelper.swap(address(hypervisor.token1()), address(asset), amt1, slp, msg.sender);

/// @audit contract IERC20 -> address
186:         if (strategyHelper.value(address(asset), bal) < val * (10000 - slp) / 10000) revert PriceSlipped(); 

/// @audit contract IHypervisor -> address
202:         assets[0] = address(hypervisor); 
/// @audit literal_string "camelotv3" -> bytes32
203:         return abi.encode(bytes32("camelotv3"), assets);

/// @audit contract INFTPool -> address
/// @audit contract IHypervisor -> address
207:         IERC20(address(hypervisor)).approve(address(nftPool), amount); 

/// @audit contract INitroPool -> address
219:         if (address(nitroPool) != address(0)) { 

/// @audit contract INitroPool -> address
223:         if (address(nitroPool) != address(0)) { 
/// @audit contract StrategyCamelotV3 -> address
/// @audit contract INitroPool -> address
224:             nftPool.safeTransferFrom(address(this), address(nitroPool), tokenId, "");

/// @audit contract INitroPool -> address
236:         if (address(nitroPool) != address(0)) { 

/// @audit contract StrategyCamelotV3 -> address
241:             uint256 balance = IERC20(rewardToken1).balanceOf(address(this)); 

/// @audit contract IStrategyHelper -> address
243:                 IERC20(rewardToken1).approve(address(strategyHelper), balance); 
/// @audit contract StrategyCamelotV3 -> address
244:                 strategyHelper.swap(rewardToken1, tgtAsset, balance, slp, address(this));

/// @audit contract StrategyCamelotV3 -> address
249:             uint256 balance = IERC20(rewardToken2).balanceOf(address(this)); 

/// @audit contract IStrategyHelper -> address
251:                 IERC20(rewardToken2).approve(address(strategyHelper), balance); 
/// @audit contract StrategyCamelotV3 -> address
252:                 strategyHelper.swap(rewardToken2, tgtAsset, balance, slp, address(this));

/// @audit contract StrategyCamelotV3 -> address
257:             uint256 balance = IERC20(rewardToken3).balanceOf(address(this)); 

/// @audit contract IStrategyHelper -> address
259:                 IERC20(rewardToken3).approve(address(strategyHelper), balance); 
/// @audit contract StrategyCamelotV3 -> address
260:                 strategyHelper.swap(rewardToken3, tgtAsset, balance, slp, address(this));

/// @audit contract StrategyCamelotV3 -> address
264:         uint256 amt = IERC20(tgtAsset).balanceOf(address(this)); 

/// @audit contract IHypervisor -> address
267:         address h = address(hypervisor); 

/// @audit contract StrategyCamelotV3 -> address
270:         stake(uniProxy.deposit(amt0, amt1, address(this), h, [uint256(0), 0, 0, 0])); 

/// @audit contract INitroPool -> address
278:         if (address(nitroPool) != address(0)) { 

/// @audit contract StrategyCamelotV3 -> address
281:         nftPool.safeTransferFrom(address(this), strategy, tokenId, ""); 

/// @audit contract INitroPool -> address
288:         if (address(nitroPool) != address(0)) { 
/// @audit contract StrategyCamelotV3 -> address
/// @audit contract INitroPool -> address
289:             nftPool.safeTransferFrom(address(this), address(nitroPool), tokenId, "");

/// @audit literal_string "" -> bytes
/// @audit contract IERC20 -> address
302:         bytes memory path0 = trgtAst != address(hypervisor.token0()) ? path : bytes(""); 
/// @audit literal_string "" -> bytes
/// @audit contract IERC20 -> address
303:         bytes memory path1 = trgtAst != address(hypervisor.token1()) ? path : bytes("");

/// @audit contract IHypervisor -> address
/// @audit contract IERC20 -> address
313:             uniProxy.getDepositAmount(address(hypervisor), address(hypervisor.token0()), out0); 

/// @audit contract IERC20 -> address
323:         address token0 = address(hypervisor.token0()); 

/// @audit contract StrategyCamelotV3 -> address
326:             uint256 before = hypervisor.token1().balanceOf(address(this)); 
/// @audit contract IERC20 -> address
327:             swap(trgtAst, address(hypervisor.token1()), path, toLp1, slp);

/// @audit contract StrategyCamelotV3 -> address
329:             amt1 = hypervisor.token1().balanceOf(address(this)) - before; 

/// @audit contract StrategyCamelotV3 -> address
331:             uint256 before = hypervisor.token0().balanceOf(address(this)); 

/// @audit contract StrategyCamelotV3 -> address
333:             amt0 = hypervisor.token0().balanceOf(address(this)) - before; 

/// @audit contract IStrategyHelperUniswapV3 -> address
340:         IERC20(trgtAst).transfer(address(strategyHelperUniswapV3), toLp); 
/// @audit contract StrategyCamelotV3 -> address
341:         strategyHelperUniswapV3.swap(trgtAst, path, toLp, minOut, address(this));

/// @audit uint32 -> int32
352:         uint160 midX96 = TickMath.getSqrtRatioAtTick(int24((tickCumulatives[1] - tickCumulatives[0]) / int32(period))); 

/// @audit contract IERC20 -> address
/// @audit contract IHypervisor -> address
356:             address(hypervisor.token0()), bas0 + lim0 + hypervisor.token0().balanceOf(address(hypervisor)) 

/// @audit contract IERC20 -> address
/// @audit contract IHypervisor -> address
359:             address(hypervisor.token1()), bas1 + lim1 + hypervisor.token1().balanceOf(address(hypervisor)) 

/// @audit contract IHypervisor -> address
378:         address owner = address(hypervisor); 

/// @audit contract IAlgebraPool -> address
382:         (uint128 liq,,,, uint128 owed0, uint128 owed1) = IAlgebraPool(address(hypervisor.pool())).positions(key); 

/// @audit uint128 -> uint256
/// @audit uint128 -> uint256
387:         return (amt0 + uint256(owed0), amt1 + uint256(owed1)); 

/// @audit contract INFTPool -> address
391:         if (msg.sender == address(nftPool) && tokenId == 0) { 
```


```solidity
📁 File: StrategyGMXGM.sol

/// @audit bytes memory -> string
73:         name = string( 
74:             abi.encodePacked(
75:                 "GMX GM ", IERC20(marketInfo.longToken).symbol(), "/", IERC20(marketInfo.shortToken).symbol()
76:             )
77:         );

/// @audit address -> address
/// @audit contract StrategyGMXGM -> address
134:         (bool success,) = address(msg.sender).call{value: address(this).balance}(""); 

/// @audit address -> address
139:       if (token == address(market) || token == tokenShort || token == tokenLong) revert BadToken(); 
/// @audit contract StrategyGMXGM -> address
140:       IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));

/// @audit contract StrategyGMXGM -> address
148:         asset.transferFrom(msg.sender, address(this), amount); 
/// @audit contract IStrategyHelper -> address
149:         asset.approve(address(strategyHelper), amount);
/// @audit contract IERC20 -> address
/// @audit contract StrategyGMXGM -> address
150:         uint256 bal = strategyHelper.swap(address(asset), tokenShort, amount, slp, address(this));

/// @audit contract IStrategyHelper -> address
163:         IERC20(tokenShort).approve(address(strategyHelper), amt); 
/// @audit contract IERC20 -> address
164:         uint256 bal = strategyHelper.swap(tokenShort, address(asset), amt, slp, msg.sender);

/// @audit literal_string "gmxgm" -> bytes32
181:         return abi.encode(bytes32("gmxgm"), assets); 

/// @audit contract StrategyGMXGM -> address
193:         uint256 bal = IERC20(tokenLong).balanceOf(address(this)); 

/// @audit contract IStrategyHelper -> address
195:             IERC20(tokenLong).approve(address(strategyHelper), bal); 
/// @audit contract StrategyGMXGM -> address
196:             strategyHelper.swap(tokenLong, tokenShort, bal, slp, address(this));

/// @audit contract StrategyGMXGM -> address
199:         bal = IERC20(tokenShort).balanceOf(address(this)); 

/// @audit contract IStrategyHelper -> address
206:             IERC20(tokenShort).approve(address(strategyHelper), haf); 
/// @audit contract StrategyGMXGM -> address
207:             uint256 out = strategyHelper.swap(tokenShort, tokenLong, haf, slp, address(this));

/// @audit contract StrategyGMXGM -> address
213:                 receiver: address(this), 
/// @audit contract StrategyGMXGM -> address
214:                 callbackContract: address(this),

/// @audit contract StrategyGMXGM -> address
257:                 receiver: address(this), 
/// @audit contract StrategyGMXGM -> address
258:                 callbackContract: address(this),

/// @audit contract StrategyGMXGM -> address
287:         IERC20(market).transfer(strategy, IERC20(market).balanceOf(address(this))); 
/// @audit contract StrategyGMXGM -> address
288:         IERC20(tokenLong).transfer(strategy, IERC20(tokenLong).balanceOf(address(this)));
/// @audit contract StrategyGMXGM -> address
289:         IERC20(tokenShort).transfer(strategy, IERC20(tokenShort).balanceOf(address(this)));

/// @audit contract StrategyGMXGM -> address
295:         uint256 val = strategyHelper.value(tokenLong, IERC20(tokenLong).balanceOf(address(this))); 
/// @audit contract StrategyGMXGM -> address
296:         val += strategyHelper.value(tokenShort, IERC20(tokenShort).balanceOf(address(this)));

/// @audit contract StrategyGMXGM -> address
298:         uint256 bal = IERC20(market).balanceOf(address(this)) + amountPendingDeposit + amountPendingWithdraw; 

/// @audit contract StrategyGMXGM -> address
348:         uint256 bal = IERC20(tokenLong).balanceOf(address(this)); 
/// @audit contract IStrategyHelper -> address
349:         IERC20(tokenLong).approve(address(strategyHelper), bal);
/// @audit contract StrategyGMXGM -> address
350:         try strategyHelper.swap(tokenLong, tokenShort, bal, slippage, address(this)) {} catch {}
```


```solidity
📁 File: StrategySushiswap.sol

/// @audit bytes memory -> string
37:             string(abi.encodePacked("SushiSwap ", IERC20(pool.token0()).symbol(), "/", IERC20(pool.token1()).symbol())); 

/// @audit uint112 -> uint256
81:             reserve0 = uint256(r0) * 1e18 / (10 ** IERC20(pair.token0()).decimals()); 
/// @audit uint112 -> uint256
82:             reserve1 = uint256(r1) * 1e18 / (10 ** IERC20(pair.token1()).decimals());

/// @audit contract StrategySushiswap -> address
91:         asset.transferFrom(msg.sender, address(this), amount); 

/// @audit contract IStrategyHelper -> address
99:             asset.approve(address(strategyHelper), amount); 
/// @audit contract IERC20 -> address
/// @audit contract IERC20 -> address
/// @audit contract StrategySushiswap -> address
100:             strategyHelper.swap(address(asset), address(tok0), haf, slp, address(this));
/// @audit contract IERC20 -> address
/// @audit contract IERC20 -> address
/// @audit contract StrategySushiswap -> address
101:             strategyHelper.swap(address(asset), address(tok1), amount - haf, slp, address(this));
/// @audit contract IUniswapV2Pair -> address
/// @audit contract StrategySushiswap -> address
102:             IERC20(tok0).transfer(address(pair), tok0.balanceOf(address(this)));
/// @audit contract IUniswapV2Pair -> address
/// @audit contract StrategySushiswap -> address
103:             IERC20(tok1).transfer(address(pair), tok1.balanceOf(address(this)));

/// @audit contract StrategySushiswap -> address
105:         pair.mint(address(this)); 
/// @audit contract StrategySushiswap -> address
106:         pair.skim(address(this));
/// @audit contract StrategySushiswap -> address
/// @audit contract IUniswapV2Pair -> address
107:         uint256 liq = IERC20(address(pair)).balanceOf(address(this));
/// @audit contract ISushiswapMiniChefV2 -> address
/// @audit contract IUniswapV2Pair -> address
108:         IERC20(address(pair)).approve(address(rewarder), liq);
/// @audit contract StrategySushiswap -> address
109:         rewarder.deposit(poolId, liq, address(this));

/// @audit contract IUniswapV2Pair -> address
123:             rewarder.withdraw(poolId, amt, address(pair)); 
/// @audit contract StrategySushiswap -> address
124:             pair.burn(address(this));

/// @audit contract StrategySushiswap -> address
128:         uint256 bal0 = tok0.balanceOf(address(this)); 
/// @audit contract StrategySushiswap -> address
129:         uint256 bal1 = tok1.balanceOf(address(this));
/// @audit contract IStrategyHelper -> address
130:         tok0.approve(address(strategyHelper), bal0);
/// @audit contract IStrategyHelper -> address
131:         tok1.approve(address(strategyHelper), bal1);
/// @audit contract IERC20 -> address
/// @audit contract IERC20 -> address
132:         uint256 amt0 = strategyHelper.swap(address(tok0), address(asset), bal0, slp, msg.sender);
/// @audit contract IERC20 -> address
/// @audit contract IERC20 -> address
133:         uint256 amt1 = strategyHelper.swap(address(tok1), address(asset), bal1, slp, msg.sender);

/// @audit contract IUniswapV2Pair -> address
149:         assets[0] = address(pool); 
/// @audit literal_string "sushi" -> bytes32
150:         return abi.encode(bytes32("sushi"), assets);

/// @audit contract StrategySushiswap -> address
159:         rewarder.harvest(poolId, address(this)); 
/// @audit contract StrategySushiswap -> address
160:         uint256 amt = rew.balanceOf(address(this));

/// @audit contract IERC20 -> address
162:         if (strategyHelper.value(address(rew), amt) < 0.5e18) return; 
/// @audit contract IStrategyHelper -> address
163:         rew.approve(address(strategyHelper), amt);
/// @audit contract IERC20 -> address
/// @audit contract StrategySushiswap -> address
164:         strategyHelper.swap(address(rew), pair.token0(), haf, slippage, address(this));
/// @audit contract IERC20 -> address
/// @audit contract StrategySushiswap -> address
165:         strategyHelper.swap(address(rew), pair.token1(), amt - haf, slippage, address(this));
/// @audit contract IUniswapV2Pair -> address
/// @audit contract StrategySushiswap -> address
166:         IERC20(pair.token0()).transfer(address(pair), IERC20(pair.token0()).balanceOf(address(this)));
/// @audit contract IUniswapV2Pair -> address
/// @audit contract StrategySushiswap -> address
167:         IERC20(pair.token1()).transfer(address(pair), IERC20(pair.token1()).balanceOf(address(this)));
/// @audit contract StrategySushiswap -> address
168:         pair.mint(address(this));
/// @audit contract StrategySushiswap -> address
169:         pair.skim(address(this));
/// @audit contract StrategySushiswap -> address
/// @audit contract IUniswapV2Pair -> address
170:         uint256 liq = IERC20(address(pair)).balanceOf(address(this));
/// @audit contract ISushiswapMiniChefV2 -> address
/// @audit contract IUniswapV2Pair -> address
171:         IERC20(address(pair)).approve(address(rewarder), liq);
/// @audit contract StrategySushiswap -> address
172:         rewarder.deposit(poolId, liq, address(this));

/// @audit contract StrategySushiswap -> address
178:         (uint256 amt,) = rewarder.userInfo(poolId, address(this)); 

/// @audit contract IUniswapV2Pair -> address
189:         IERC20 lp = IERC20(address(pool)); 
/// @audit contract StrategySushiswap -> address
190:         uint256 bal = lp.balanceOf(address(this));

/// @audit contract ISushiswapMiniChefV2 -> address
192:         lp.approve(address(rewarder), bal); 
/// @audit contract StrategySushiswap -> address
193:         rewarder.deposit(poolId, bal, address(this));
```


```solidity
📁 File: UtilFarmingBalances.sol

/// @audit contract IPositionManager -> address
22:             (bool ok, bytes memory data) = address(pm).staticcall(abi.encodeWithSelector(IPositionManager.ownerOf.selector, y)); 
```


</details>


---
### [D&#x2011;30] ~~Use `string.concat()` on strings instead of `abi.encodePacked()` for clearer semantic meaning~~
These instances don't use only bytes/strings or the solidity pragma is below 0.8.12, so they're invalid


<i>There is one instance of this issue:</i>

```solidity
📁 File: Helper.sol

/// @audit doesn't use only bytes/strings
45:         lender.flashLoanSimple(address(this), address(asset), repay, abi.encodePacked(id), 0); 
```



---
### [D&#x2011;31] ~~Using `bool`s for storage incurs overhead~~
The general rule is valid, but the instances below are invalid

<details>
<summary><i>There are 15 instances of this issue:</i></summary>

```solidity
📁 File: Bank.sol

9:     mapping(address => bool) public exec; 
```


```solidity
📁 File: Investor.sol

76:     mapping(address => bool) public exec; 
```


```solidity
📁 File: InvestorStrategyProxy.sol

17:     mapping(address => bool) public exec; 
```


```solidity
📁 File: PositionManager.sol

69:     mapping(address => bool) public exec; 

74:     mapping(address => mapping(address => bool)) public isApprovedForAll; 
```


```solidity
📁 File: Store.sol

5:     mapping(address => bool) public exec; 

9:     mapping(bytes32 => bool) public boolValues; 
```


```solidity
📁 File: StrategyCamelotV3.sol

14:     mapping(address => bool) public exec; 
15:     mapping(address => bool) public keepers;
```


```solidity
📁 File: StrategyGMXGM.sol

11:     mapping(address => bool) public exec; 
12:     mapping(address => bool) public keepers;
```


```solidity
📁 File: StrategySushiswap.sol

14:     mapping(address => bool) public exec; 
15:     mapping(address => bool) public keepers;
```


```solidity
📁 File: Whitelist.sol

5:     mapping(address => bool) public exec; 
6:     mapping(address => bool) public whitelist;
```


</details>

